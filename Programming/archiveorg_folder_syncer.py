import os
import sys
import hashlib
from internetarchive import get_item, get_session

def calculate_md5(filepath):
    """Calculates the MD5 hash of a local file to compare with Archive.org."""
    hash_md5 = hashlib.md5()
    with open(filepath, "rb") as f:
        for chunk in iter(lambda: f.read(4096), b""):
            hash_md5.update(chunk)
    return hash_md5.hexdigest()

def sync_identifier_folder(identifier_folder):
    """
    Checks a specific folder against the Archive.org item with the same name.
    """
    # The folder name is assumed to be the identifier
    identifier = os.path.basename(os.path.abspath(identifier_folder))
    
    print(f"\n[{identifier}] Processing...")

    # 1. Get the Item object from Archive.org
    try:
        item = get_item(identifier)
        if not item.exists:
            print(f"  Error: Item '{identifier}' does not exist on Archive.org. Skipping.")
            return
    except Exception as e:
        print(f"  Connection Error: {e}")
        return

    # 2. Build a dictionary of Remote Files {filename: md5}
    # We filter out metadata files (xml, sqlite) usually generated by IA
    remote_files = {}
    print("  Fetching remote file list...")
    for file in item.files:
        filename = file['name']
        md5 = file.get('md5', None)
        if md5:
            remote_files[filename] = md5

    # 3. Scan Local Files
    files_to_upload = []
    
    # We walk through the local folder
    for root, dirs, files in os.walk(identifier_folder):
        for filename in files:
            local_path = os.path.join(root, filename)
            
            # Calculate the relative path (how it should appear on Archive.org)
            # If local is "myidentifier/data/file.txt", remote name is "data/file.txt"
            rel_path = os.path.relpath(local_path, start=identifier_folder)
            
            # Normalize path separators (windows '\' to unix '/')
            remote_name = rel_path.replace(os.sep, '/')

            # Skip system files like .DS_Store or Thumbs.db
            if filename.startswith('.'):
                continue

            # 4. Compare Local vs Remote
            should_upload = False
            
            if remote_name not in remote_files:
                print(f"  [NEW] Found new file: {remote_name}")
                should_upload = True
            else:
                # File exists, check content (MD5)
                local_md5 = calculate_md5(local_path)
                remote_md5 = remote_files[remote_name]
                
                if local_md5 != remote_md5:
                    print(f"  [CHANGED] Content differs for: {remote_name}")
                    should_upload = True
                else:
                    # Files are identical
                    # print(f"  [SKIP] Identical: {remote_name}") # Uncomment for verbose
                    pass

            if should_upload:
                # Add to list of files to upload
                # We store a tuple: (local_path, remote_name)
                files_to_upload.append((local_path, remote_name))

    # 5. Perform Uploads
    if files_to_upload:
        print(f"  Start uploading {len(files_to_upload)} file(s)...")
        try:
            # We iterate and upload individually to allow specific key naming
            for local_p, remote_n in files_to_upload:
                print(f"  Uploading: {remote_n}...")
                
                # 'files' argument expects a dictionary { remote_name: local_path } 
                # or a list of matches.
                # Using key-value pair ensures the remote name is exactly what we want.
                item.upload({remote_n: local_p}, verbose=True, retries=3)
                
            print(f"  Success: Synced '{identifier}'")
        except Exception as e:
            print(f"  Upload failed: {e}")
    else:
        print(f"  Up to date. No changes needed.")

def main():
    # Get current working directory
    working_dir = os.getcwd()
    
    # List all subdirectories in the current folder
    subfolders = [f.path for f in os.scandir(working_dir) if f.is_dir()]

    if not subfolders:
        print("No subfolders found in the current directory.")
        sys.exit()

    print(f"Found {len(subfolders)} folders to process.")
    
    for folder in subfolders:
        sync_identifier_folder(folder)

if __name__ == "__main__":
    # Check if user is logged in
    try:
        s = get_session()
        if not s.access_key:
            print("Error: You are not logged in.")
            print("Please run 'ia configure' in your terminal first.")
            sys.exit(1)
    except:
        pass

    main()