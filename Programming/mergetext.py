#!/usr/bin/env python3

"""
================================================================================
 SCRIPT NAME: Advanced Text File Merger
 VERSION: 2.0
 AUTHOR: Contributor
 DATE: September 5, 2025
================================================================================

PURPOSE & DESCRIPTION:
----------------------
This script is a command-line utility designed to merge multiple text-based
files (e.g., .txt, .md, .log) into a single output file. Its primary strength
lies in its intelligent sorting and content sanitization capabilities, making it
especially useful for combining sequentially named files, such as chapters of a
book or logs from a process, particularly when the content is generated by
Large Language Models (LLMs).

Core features include:
- **Numerical Sorting:** Sorts files based on the last number found in their
  filenames, ensuring a natural order (e.g., 'chap1.txt', 'chap2.txt',
  'chap10.txt') rather than a simple alphabetical sort.
- **Content Sanitization:** Safely removes markdown code fences (```) that
  wrap the entire content of a file, a common artifact from LLM API responses.
  This is done precisely, without damaging legitimate code blocks inside the text.
- **Linebreak & Hyphenation Control:** Optionally reformats text by stripping
  single line breaks within paragraphs and intelligently joining words that were
  hyphenated across lines.
- **Flexible File Handling:** Uses glob patterns to easily select files and
  intelligently determines the output file extension based on the input files.
- **User-Friendly Interface:** A robust command-line interface with clear
  help messages guides the user.

WHY THIS DOCUMENTATION IS IMPORTANT:
------------------------------------
Thorough documentation is not an afterthought; it is a critical component of
well-written software. It ensures that the script is:
- **Maintainable:** Anyone can understand the logic, the purpose of each
  function, and the reasoning behind specific implementation choices, making
  future updates or debugging far easier.
- **Usable:** Users can quickly learn how to operate the script and utilize its
  features effectively through clear explanations and examples.
- **Transparent:** The code's behavior is predictable, reducing the risk of
  unintended side effects (e.g., accidental data corruption).
Documentation of this nature should be considered a standard and required part
of any script intended for reliable and long-term use.


HOW IT WORKS (ARCHITECTURAL OVERVIEW):
--------------------------------------
1.  **Argument Parsing:** The script starts by parsing command-line arguments
    using the `argparse` module. This determines the input file pattern,
    output filename, and any operational flags (like adding linebreaks or
    stripping content).
2.  **File Discovery:** It uses `glob.glob()` to find all files in the current
    directory that match the user-provided file pattern.
3.  **Numerical Sorting:** The list of files is sorted using a custom key
    function, `get_numerical_sort_key`. This function extracts the last number
    from each filename to ensure a logical, numerical sort order.
4.  **File Merging Loop:** The script opens the target output file in write
    mode. It then iterates through the sorted list of input files.
5.  **Content Processing:** For each file, it reads the content and applies
    processing based on the user's flags:
    a. `sanitize_api_response()` is called to remove wrapping markdown fences.
    b. Linebreak stripping logic is applied if requested.
6.  **Writing to Output:** The processed content is written to the output file,
    followed by a separator (a single or double newline).
7.  **Safeguards:** The script includes checks to prevent it from merging its
    own output file on subsequent runs and handles file-not-found scenarios
    gracefully.


DETAILED FUNCTION EXPLANATIONS:
-------------------------------
`get_numerical_sort_key(filename)`:
- **Purpose:** To provide a key for Python's `sort()` method that enables
  natural sorting of filenames containing numbers.
- **Why:** A standard alphabetical sort would order `['f1.txt', 'f10.txt', 'f2.txt']`
  incorrectly. This function ensures the order is `['f1.txt', 'f2.txt', 'f10.txt']`.
- **How:** It uses a regular expression `re.findall(r'\\d+', ...)` to extract all
  sequences of digits from the filename. It specifically uses the *last* number
  found, which is a robust choice for typical versioning or chaptering schemes
  (e.g., `draft_v1_chap_10.md`). For sorting, it returns a tuple `(number, filename)`.
  Python sorts tuples element by element, so it sorts by the number first, and
  only if the numbers are identical does it use the full filename as a tie-breaker.
  If no number is found, it assigns `float('inf')` to push that file to the end
  of the list.

`sanitize_api_response(text)`:
- **Purpose:** To remove markdown code fences that enclose the entire text content.
- **Why:** LLMs often wrap their entire output this way. A naive `str.replace()`
  is dangerous because it would also remove legitimate, intentional code blocks
  within the text. This function is designed for surgical precision.
- **How:** It uses a single, powerful regular expression:
  `^\\s*```[a-z]*\\s*\\n?(.*?)\\n?\\s*```\\s*$`
  - `^` and `$` anchor the match to the absolute start and end of the string.
  - `\\s*` handles any surrounding whitespace.
  - `[a-z]*` matches the optional language identifier (e.g., 'python', 'json').
  - `(.*?)` is a non-greedy capture group for the content *inside* the fences.
  - `re.DOTALL` flag allows `.` to match newlines, so the content can span
    multiple lines.
  If this specific pattern matches, it returns only the captured content;
  otherwise, it returns the original text untouched.

`merge_text_files(...)`:
- **Purpose:** The main function that orchestrates the entire merging process.
- **How:** It ties all the logic together. It handles the logic for determining
  the final output filename (command-line argument priority), prevents the
  script from merging itself, loops through the sorted files, and calls the
  appropriate processing functions before writing the final, clean content.
  The linebreak stripping logic is also contained here, using a series of
  `re.sub` calls to handle hyphenated words, normalize paragraph breaks to
  double newlines, and replace single newlines within paragraphs with spaces.

`if __name__ == "__main__":` block:
- **Purpose:** This is standard Python practice. It ensures that the code inside
  this block only runs when the script is executed directly from the command
  line, not when it is imported as a module into another script.
- **How:** It sets up the `argparse.ArgumentParser` to define all the command-line
  arguments, flags, and help messages. It then calls `merge_text_files` with
  the parsed arguments. Noteworthy arguments include:
  - `nargs='?'`: Makes the positional output filename optional.
  - `action="store_true"`: For flags like `--linebreak` that don't take a
    value, their presence simply sets the corresponding variable to `True`.
  - `action="store_false"`: A clever way to create a flag that disables a
    default `True` behavior. Here, `--no-remove-strings` sets the
    `remove_strings` destination variable to `False`.


USAGE EXAMPLES:
---------------
1.  **Basic Merge:** Merge all `.txt` files in the current directory.
    ```
    python merge_script.py "*.txt"
    ```

2.  **Specify Output:** Merge all markdown files into a specific output file.
    ```
    python merge_script.py "*.md" "Complete_Book.md"
    ```

3.  **Using Flags:** Merge numbered chapter files, add a blank line between
    them, and strip paragraph linebreaks.
    ```
    python merge_script.py "chapter-*.txt" -o "book.txt" -lb --strip
    ```

4.  **Disable Sanitization:** Merge files but keep the wrapping markdown fences.
    ```
    python merge_script.py "*.md" --no-remove-strings
    ```

DEPENDENCIES:
-------------
This script uses only Python's standard libraries (`sys`, `glob`, `os`,
`argparse`, `re`) and requires no external packages to be installed. It is
designed to be portable and run on any system with Python 3.

================================================================================
"""

import sys
import glob
import os
import argparse
import re

def get_numerical_sort_key(filename):
    """
    Extracts the LAST numerical part from ANY filename for sorting.
    Uses regular expressions to find all sequences of digits and takes the last one.
    If extraction fails or not a number, returns a tuple that ensures
    non-numerical filenames are sorted after numerical ones, while maintaining
    alphabetical order within each group.
    """
    try:
        numerical_parts_str = re.findall(r'\d+', filename) # Find ALL sequences of digits
        if numerical_parts_str:
            last_numerical_part_str = numerical_parts_str[-1] # Get the last one from the list
            try:
                numerical_part = int(last_numerical_part_str)
                return (numerical_part, filename) # Return tuple for numerical sort primarily
            except ValueError:
                # If the part is not an integer (shouldn't happen with \d+, but for robustness)
                return (float('inf'), filename) # Treat as non-numerical
        else:
            # No numerical part found
            return (float('inf'), filename) # Treat as non-numerical
    except: # Catch any errors during regex or string operations
        return (float('inf'), filename) # Default to non-numerical


def sanitize_api_response(text):
    """
    Removes Markdown code fences from the start and end of a string.
    Handles optional language identifiers like 'json' or 'markdown'.
    """
    if not text:
        return ""
    # Regex to find a markdown block with an optional language identifier.
    # It captures the content inside. re.DOTALL allows '.' to match newlines.
    pattern = re.compile(r"^\s*```[a-z]*\s*\n?(.*?)\n?\s*```\s*$", re.DOTALL)
    match = pattern.match(text.strip())
    if match:
        # If the entire string is a markdown block, return the captured content.
        return match.group(1).strip()
    # If no markdown block is found, return the original (stripped) text.
    return text.strip()


def merge_text_files(file_pattern, output_filename, add_linebreak=False, strip_linebreaks=False, remove_strings=True):
    """
    Merges all text files matching the given pattern in the current working directory
    into a single output text file, in ascending numerical order of filenames
    based on the LAST number within the filename. The output file extension
    will be the same as the input file extension if not explicitly specified.

    Args:
        file_pattern (str): The file pattern to match (e.g., "*.txt").
        output_filename (str): The name of the output file. If None, defaults to "merged_output.txt",
                                     but the extension will be derived from the input file pattern.
        add_linebreak (bool, optional):  If True, adds a blank line between merged files.
                                        Defaults to False.
        strip_linebreaks (bool, optional): If True, enables stripping of linebreaks within paragraphs,
                                        joining hyphenated words split across lines. Replaces single newlines
                                        within paragraphs with spaces, joins hyphenated words split across lines,
                                        and normalizes multiple newlines to paragraph breaks. Defaults to False.
        remove_strings (bool, optional): If True, removes markdown code fences that wrap the entire content of a file.
                                        Defaults to True.
    """
    try:
        # Get a list of files matching the pattern in the current directory
        files_to_merge = glob.glob(file_pattern)

        if not files_to_merge:
            print(f"No files found matching pattern: {file_pattern}")
            return

        # Determine output extension from file_pattern if output_filename is not provided or is still default
        if output_filename is None or output_filename == "merged_output.txt":
            base_output_name = "merged_output"
            pattern_parts = file_pattern.split('.')
            if len(pattern_parts) > 1:
                output_extension = pattern_parts[-1] # Take the last part after the dot as extension
                output_filename = f"{base_output_name}.{output_extension}"
            else:
                output_filename = "merged_output.txt" # Default to .txt if no extension in pattern
        elif output_filename: # if output_filename is provided from command line, use it as is
            pass # use the provided output_filename

        # Sort the files list numerically based on the LAST number in filename
        files_to_merge.sort(key=get_numerical_sort_key)

        # Remove the automatically named 'merged_output.ext' or user provided output_filename from the list if it's present and not intended to be merged.
        # This prevents merging the output file into itself on subsequent runs if the pattern matches it.
        if output_filename in files_to_merge:
            files_to_merge.remove(output_filename)


        print(f"Merging files in numerical ascending order (by last number in filename): {files_to_merge}")
        print(f"Output file will be: {output_filename}")

        with open(output_filename, 'w', encoding='utf-8') as outfile:
            for filename in files_to_merge:
                try:
                    with open(filename, 'r', encoding='utf-8') as infile:
                        content = infile.read()

                        if remove_strings:
                            content = sanitize_api_response(content)

                        if strip_linebreaks:
                            # 1. Join hyphenated words across lines
                            while True: # Loop to handle multiple hyphenated words in sequence
                                original_content = content
                                content = re.sub(r'(\w)-\n(\w?)', r'\1\2', content, flags=re.MULTILINE)
                                if content == original_content: # No more hyphenated words found in this pass
                                    break

                            # 2. Normalize paragraph breaks (ensure double newlines for paragraphs)
                            content = re.sub(r'\n{2,}', '\n\n', content)

                            # 3. Remove single newlines within paragraphs (replace with spaces)
                            content = re.sub(r'(?<!\n)\n(?!\n)', ' ', content)


                        outfile.write(content)
                        if add_linebreak:
                            outfile.write("\n\n")  # Add a separator (blank line) if the flag is set
                        else:
                            outfile.write("\n") # Add a separator (newline)

                    print(f"  - Merged: {filename}")
                except Exception as e:
                    print(f"  - Error reading file: {filename} - {e}")

        print(f"\nSuccessfully merged files into: {output_filename}")

    except Exception as e:
        print(f"An error occurred: {e}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Merge text files matching a pattern. By default, it removes markdown fences (e.g., ```markdown) that wrap the entire file content.\nOutput file extension is the same as input extension by default (e.g., merged_output.md for '*.md').\nFilenames are sorted based on the LAST number found in the filename.\nYou can specify the output filename as a second positional argument after the file pattern, or using -o/--output.",
                                     formatter_class=argparse.RawTextHelpFormatter) # for multiline help text
    parser.add_argument("file_pattern", help="The file pattern to match (e.g., '*.txt', '*.md')")
    parser.add_argument("output_filename_pos", nargs='?', default=None, help="Optional output filename. If provided, overrides default output name and -o/--output.") # Positional argument for output filename
    parser.add_argument("-o", "--output", default="merged_output.txt", help="The name of the output file (default: merged_output.txt, extension derived from input pattern if not specified). Positional output filename argument takes precedence.")
    parser.add_argument("-lb", "--linebreak", action="store_true", help="Add a blank line between merged files.")
    parser.add_argument("-strip", "--strip", action="store_true", help="Enable stripping of linebreaks within paragraphs, joining hyphenated words.\nReplaces single newlines within paragraphs with spaces, joins hyphenated\nwords split across lines, and normalizes multiple newlines to paragraph breaks.")
    parser.add_argument("--no-remove-strings", action="store_false", dest="remove_strings", default=True, help="Disable removal of markdown fences that wrap the entire file content.")

    args = parser.parse_args()

    file_pattern = args.file_pattern
    # Determine output filename priority: positional arg > -o/--output > default/derived
    output_filename = args.output_filename_pos if args.output_filename_pos else args.output
    add_linebreak = args.linebreak
    strip_linebreaks = args.strip
    remove_strings = args.remove_strings

    merge_text_files(file_pattern, output_filename=output_filename, add_linebreak=add_linebreak, strip_linebreaks=strip_linebreaks, remove_strings=remove_strings)