

################################################################################
# --- INTERNAL PRESET STORAGE (BASE64) ---
################################################################################
# --- PRESETS_START ---
PRESET_DATA_B64 = "ewogICAgIkRlZmF1bHQgQW5hbHlzaXMiOiB7CiAgICAgICAgInByb21wdCI6ICJBbmFseXplIHRoZSBwcm92aWRlZCBjb250ZW50ICh0ZXh0IG9yIGltYWdlKS5cbklmIHRleHQgaXMgcHJvdmlkZWQgYmVsb3c6IFN1bW1hcml6ZSB0aGUga2V5IHBvaW50cywgaWRlbnRpZnkgbWFpbiB0b3BpY3MsIGFuZCBzdWdnZXN0IHJlbGV2YW50IGtleXdvcmRzLlxuSWYgb25lIG9yIG1vcmUgaW1hZ2VzIGFyZSBwcm92aWRlZDogRGVzY3JpYmUgdGhlIGltYWdlKHMpIGluIGRldGFpbC5cblByb3ZpZGUgdGhlIG91dHB1dCBhcyBwbGFpbiB0ZXh0LiIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiIgogICAgfSwKICAgICJTUlQgRml4IE1hcnZlbCBSaXZhbHMiOiB7CiAgICAgICAgInByb21wdCI6ICJJIGhhdmUgYW4gU1JUIGZpbGUgdGhhdCBpcyBhYm91dCB0aGUgZ2FtZSBjYWxsZWQgbWFydmVsIHJpdmFscyByZWxlYXNlZCBieSBuZXRlYXNlLiBIb3dldmVyLCB0aGVyZSBhcmUgbXVsdGlwbGUgZXJyb3JzIGFuZCBtaXNzcGVsbGluZ3MgaW4gdGhlIFNSVCB0aGF0IEkgd2FudCB5b3UgdG8gZml4LiBJbiBwYXJ0aWN1bGFyIGluIHRoZSBzcGVsbGluZyBvZiBuYW1lcywgYWJpbGl0aWVzLCBhbmQgdWx0cyAodWx0aW1hdGVzKS4gXG5cbkhlcmUgYXJlIHRoZSB0ZXJtcyByZWxhdGVkIHRvIE1hcnZlbCBSaXZhbHMgb3JnYW5pemVkIGFzIGNvbW1hLXNlcGFyYXRlZCBsaXN0cyBmb3IgZWFzeSB1c2UuXG5cblBsYXlhYmxlIENoYXJhY3RlcnNcblxuQnJ1Y2UgQmFubmVyLCBIdWxrLCBEb2N0b3IgU3RyYW5nZSwgR3Jvb3QsIE1hZ25ldG8sIFBlbmkgUGFya2VyLCBTUC8vZHIsIFZlbm9tLCBUaG9yLCBDYXB0YWluIEFtZXJpY2EsIFRoZSBUaGluZywgRW1tYSBGcm9zdCwgQ29sb3NzdXMsIFZhbGt5cmllLCBCbGFjayBQYW50aGVyLCBIZWxhLCBJcm9uIE1hbiwgTWFnaWssIE1vb24gS25pZ2h0LCBOYW1vciwgVGhlIFB1bmlzaGVyLCBTY2FybGV0IFdpdGNoLCBTcGlkZXItTWFuLCBTdGFyLUxvcmQsIFN0b3JtLCBXaW50ZXIgU29sZGllciwgV29sdmVyaW5lLCBIdW1hbiBUb3JjaCwgTWlzdGVyIEZhbnRhc3RpYywgQmxhZGUsIFBob2VuaXgsIEhhd2tleWUsIFBzeWxvY2tlLCBTcXVpcnJlbCBHaXJsLCBCbGFjayBXaWRvdywgSXJvbiBGaXN0LCBMb2tpLCBMdW5hIFNub3csIE1hbnRpcywgUm9ja2V0IFJhY2Nvb24sIEFkYW0gV2FybG9jaywgSmVmZiB0aGUgTGFuZCBTaGFyaywgSW52aXNpYmxlIFdvbWFuLCBDbG9hayAmIERhZ2dlciwgVWx0cm9uXG5cblJvbGVzICYgQ2xhc3Nlc1xuXG5WYW5ndWFyZCwgRHVlbGlzdCwgU3RyYXRlZ2lzdCwgVGFuaywgRGFtYWdlLCBTdXBwb3J0LCBIZWFsZXIsIEJyYXdsZXIsIEhpdHNjYW4sIFByb2plY3RpbGUsIE1lbGVlLCBTbmlwZXIsIFN1bW1vbmVyLCBEaXZlIFRhbmssIEFuY2hvciBUYW5rXG5cblRlYW0tVXAgQWJpbGl0aWVzXG5cblJhZ25hcm9rIFJlYmlydGgsIE1ldGFsbGljIENoYW9zLCBTeW1iaW90ZSBCb25kLCBQbGFuZXQgWCBQYWxzLCBHYW1tYSBDaGFyZ2UsIFZvbHRhaWMgVW5pb24sIEd1YXJkaWFuIFJldml2YWwsIEFtbW8gT3ZlcmxvYWQsIERpbWVuc2lvbmFsIFNob3J0Y3V0LCBDaGlsbGluZyBDaGFyaXNtYSwgTWFzdGVyIG9mIHRoZSBTdW4sIEZyb3plbiBXb2x2aWUsIE9sZCBGcmllbmRzLCBTeW1iaW90aWMgYm9uZCwgR3VhcmRpYW4gUmV2aXZhbCwgQ2hhb3MgRW5lcmd5LCBHYW1tYSBSYWRpYXRpb25cblxuTG9jYXRpb25zICYgTWFwc1xuXG5ZZ2dzZ2FyZCwgUm95YWwgUGFsYWNlLCBZZ2dkcmFzaWxsIFBhdGgsIEJpZnJvc3QgR2FyZGVuLCBUb2t5byAyMDk5LCBTaGluLVNoaWJ1eWEsIFNwaWRlci1Jc2xhbmRzLCBOaW5vbWFydSwgSW50ZXJnYWxhY3RpYyBFbXBpcmUgb2YgV2FrYW5kYSwgQmlybmluIFRcdTIwMTlDaGFsbGEsIEhhbGwgb2YgRGphbGlhLCBXb3JsZCBBcmVuYSwgSHlkcmEgQ2hhcnRlcmlzIEJhc2UsIEhlbGxcdTIwMTlzIEhlYXZlbiwgS2x5bnRhciwgU3ltYmlvdGljIFN1cmZhY2UsIFRocm9uZSBvZiBLbnVsbCwgRW1waXJlIG9mIEV0ZXJuYWwgTmlnaHQsIERvb20ncyBEb21haW4sIE1pZHRvd24sIFNhbmN0dW0gU2FuY3RvcnVtLCBIZWxsZmlyZSBHYWxhLCBLcmFrb2EsIEFyYWtrb1xuXG5HYW1lIE1vZGVzXG5cbkNvbnZveSwgRG9taW5hdGlvbiwgQ29udmVyZ2VuY2UsIFZhbmd1YXJkLCBDb25xdWVzdCwgRG9vbSBNYXRjaCwgUmVzb3VyY2UgUnVtYmxlLCBEZWF0aG1hdGNoLCBGcmVlLUZvci1BbGwsIEtpbmcgb2YgdGhlIEhpbGwsIFBheWxvYWRcblxuR2VuZXJhbCBUZXJtcyAmIE1lY2hhbmljc1xuXG5DaHJvbm92ZXJzZSwgVGltZSBTdHJlYW0gRW50YW5nbGVtZW50LCBHYWxhY3RhLCBEZXN0cnVjdGlibGUgRW52aXJvbm1lbnQsIFNlYXNvbmFsIEF1cmEsIFVuaXRzLCBVbHRpbWF0ZSBBYmlsaXR5LCBQYXNzaXZlIEFiaWxpdHksIFRlYW0tVXAsIFdhbGwgQ2xpbWIsIFdlYiBTd2luZywgRmxpZ2h0LCBTaGFwZXNoaWZ0LCBSZXN1cnJlY3Rpb24sIENyb3dkIENvbnRyb2wgKENDKSwgTmV0RWFzZSBHYW1lcywgTWFydmVsIEdhbWVzLCA2djYsIFRoaXJkLVBlcnNvbiBTaG9vdGVyLCBIZXJvIFNob290ZXJcblxuXG5cblxuSW4geW91ciBvdXRwdXQsIG9ubHkgZ2l2ZSB0aGUgdXBkYXRlZCBzcnQgZmlsZSB3aXRoIG5vIG90aGVyIGNvbW1lbnRhcmllcyBvciBhbiBhY2tub3dsZWRnbWVudCB3aGF0c29ldmVyLiBkbyBub3QgaW5jbHVkZSBcImBgYFwiLiBPbmx5IHRoZSBTUlQgZmlsZSBhbmQgbWFrZSBzdXJlIHRoZSB0aW1lIHN0YW1wcyByZW1haW4gdGhlIHNhbWUgYXMgdG8gdGhlIG9yaWdpbmFsIiwKICAgICAgICAiZW5naW5lIjogIm9sbGFtYSIsCiAgICAgICAgIm1vZGVsIjogImRlZXBzZWVrLXIxOjhiLTA1MjgtcXdlbjMtcThfMCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiIiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICIiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiB0cnVlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlLAogICAgICAgICJ2YWxpZGF0ZV9qc29uIjogZmFsc2UKICAgIH0sCiAgICAiU1JUIEZpeCBIYXpiaW4gSG90ZWwiOiB7CiAgICAgICAgInByb21wdCI6ICJJIGhhdmUgYW4gU1JUIGZpbGUgdGhhdCBpcyBhYm91dCBwcmltZSB2aWRlbyBzZXJpZXMgY2FsbGVkIEhhemJpbiBIb3RlbCByZWxlYXNlZCBieSBBbWF6b24gTUdNIFN0dWRpb3MuIEhvd2V2ZXIsIHRoZXJlIGFyZSBtdWx0aXBsZSBlcnJvcnMgYW5kIG1pc3NwZWxsaW5ncyBpbiB0aGUgU1JUIHRoYXQgSSB3YW50IHlvdSB0byBmaXguIFxuSW4gb3JkZXIgdG8gZG8gdGhhdCwgaSBuZWVkIHlvdSB0byBzZWFyY2ggZm9yIGFsbCBjaGFyYWN0ZXJzLCBjYXN0LCBhY3RvcnMsIHRlcm1zIGFuZCBsb2NhdGlvbnMgcmVsYXRpbmcgdG8gdGhlIHNob3cuXG5JbiBwYXJ0aWN1bGFyIGluIHRoZSBzcGVsbGluZyBvZiBuYW1lcywgYWJpbGl0aWVzLCBhbmQgc3VjaC4gSW4geW91ciBvdXRwdXQsIG9ubHkgZ2l2ZSB0aGUgdXBkYXRlZCBzcnQgZmlsZSB3aXRoIG5vIG90aGVyIGNvbW1lbnRhcmllcyBvciBhbiBhY2tub3dsZWRnbWVudCB3aGF0c29ldmVyIE9ubHkgdGhlIFNSVCBmaWxlIGFuZCBtYWtlIHN1cmUgdGhlIHRpbWUgc3RhbXBzIHJlbWFpbiB0aGUgc2FtZSBhcyB0byB0aGUgb3JpZ2luYWwiLAogICAgICAgICJlbmdpbmUiOiAiZ29vZ2xlIiwKICAgICAgICAibW9kZWwiOiAibW9kZWxzL2dlbWluaS1mbGFzaC1sYXRlc3QiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIiIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAic3J0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogdHJ1ZSwKICAgICAgICAic3RyZWFtX291dHB1dCI6IGZhbHNlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZQogICAgfSwKICAgICJZb3VUdWJlIFNFTyAtIGpzb24iOiB7CiAgICAgICAgInByb21wdCI6ICJDb250ZXh0OiBGb3IgYWxsIHRoZSBmb2xsb3dpbmcsIHdlIGFyZSB3b3JraW5nIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnYW1lIFtHYW1lIE5hbWVdLCBhbmQgdGhlIHZpZGVvIGNvbnRlbnQgZm9jdXNlcyBvbiBbTWFpbiBTdWJqZWN0L0NoYXJhY3Rlci9FdmVudCBmcm9tIHRoZSB2aWRlb10gaW4gdGhlIGNvbXBldGl0aXZlIGdhbWUgbW9kZS5cblxuQ29udGV4dDogRm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiB0aGUgY29udGV4dCBvZiBIYXpiaW4gSG90ZWwsIHNlYXJjaCBmb3IgYWxsIGNoYXJhY3RlciBuYW1lcyBhbmQgcmVsYXRlZCB0ZXJtcyB0byB1c2UuXG5cbmZvciBhbGwgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgaW4gY29udGV4dCBvZiB0aGUgZ2FtZSBNYXJ2ZWwgUml2YWxzLCB0aGUgb25lIHJlbGVhc2VkIGJ5IG5ldGVhc2UsIGFuZCB3ZSBhcmUgcGxheWluZyBhIGNoYXJhY3RlciBpbiB0aGUgY29tcGV0aXRpdmUgZ2FtZSBtb2RlLiBTZWFyY2ggZm9yIGFsbCB0aGUgbmFtZXMgb2YgbWFydmVsIHJpdmFscyBoZXJvZXMgYW5kIGFiaWxpdGllcywgYW5kIG1ha2Ugc3VyZSBhbGwgb3V0cHV0IGFkaGVyZSB0byBjb3JyZWN0IHNwZWxsaW5nIG9mIG5hbWVzIGFuZCBldmVyeXRoaW5nIGVsc2UuXG5cbmZvciBhbGwgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgaW4gY29udGV4dCBvZiB0aGUgZ2FtZSBNYXJ2ZWwgUml2YWxzLCB0aGUgb25lIHJlbGVhc2VkIGJ5IG5ldGVhc2UsIGFuZCB3ZSBhcmUgcGxheWluZyBhIGdhbWUgbW9kZSBjYWxsZWQgTWFydmVsIFpvbWJpZXMuIExvb2sgdXAgYWxsIHRoZSBkZXRhaWxzIGFib3V0IHRoaXMgZ2FtZSBtb2RlIGFuZCB1c2UgYWxsIGluZm8gZm9yIHRoZSBmb2xsb3dpbmc6XG5cbmZvciBhbGwgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgaW4gY29udGV4dCBvZiB0aGUgZ2FtZSBPdmVyd2F0Y2ggMiwgdGhlIG9uZSByZWxlYXNlZCBieSBCbGl6emFyZCwgU2VhcmNoIGZvciBhbGwgdGhlIG5hbWVzIG9mIE92ZXJ3YXRjaCAyIGhlcm9lcyBhbmQgYWJpbGl0aWVzLCBhbmQgbWFrZSBzdXJlIGFsbCBvdXRwdXQgYWRoZXJlIHRvIGNvcnJlY3Qgc3BlbGxpbmcgb2YgbmFtZXMgYW5kIGV2ZXJ5dGhpbmcgZWxzZS5cblxuXG5QUk9NUFQgU1RBUlRcblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuIFdoaWxlIHRoZSBjb3JlIGNvbnRlbnQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSB0aGlzIHByb3ZpZGVkIFNSVCBkYXRhLCB5b3UgYXJlIHJlcXVpcmVkIHRvIHN1YnN0YW50aWFsbHkgc3VwcGxlbWVudCB0aGlzIHdpdGggcmVsZXZhbnQgZXh0ZXJuYWwga25vd2xlZGdlIHRvIGFjaGlldmUgc2lnbmlmaWNhbnQgbGVuZ3RoIGFuZCBlbmhhbmNlIFNFTy9kaXNjb3ZlcmFiaWxpdHkgY3J1Y2lhbCBmb3IgdmlyYWxpdHkuIEZvY3VzIG9uIHVuZGVyc3RhbmRpbmcgdGhlIHRvcGljIGRlZXBseSBhbmQgaW5jb3Jwb3JhdGluZyBhIHdpZGUgcmFuZ2Ugb2YgcmVsZXZhbnQga2V5d29yZHMgYW5kIGNvbnRleHQgZm91bmQgd2l0aGluIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVCBjb250ZW50LlxuXG5cdWQ4M2NcdWRmYWYgSlNPTiBPdXRwdXQgUmVxdWlyZW1lbnRcbllvdXIgZmluYWwgcmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5jb2RlIEpTT05cbmRvd25sb2FkY29udGVudF9jb3B5ZXhwYW5kX2xlc3NcbiAgIHtcbiAgXCJ0aXRsZVwiOiBcInN0cmluZyAoWW91VHViZSBUaXRsZSlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcInN0cmluZyAoWW91VHViZSBEZXNjcmlwdGlvbiBpbmNsdWRpbmcgdGltZXN0YW1wcyBhbmQgQ1RBLCBtYXggNTAwMCBjaGFycyB3aXRoIGhhc2h0YWdzKVwiLFxuICBcImhhc2h0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgXCJ0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcIi4uLiB1cCB0byA1MDAgY2hhcnMgdG90YWxcIl1cbn1cbiBcbktleXMgbXVzdCBhbHdheXMgYXBwZWFyIGluIHRoaXMgb3JkZXI6IHRpdGxlLCBkZXNjcmlwdGlvbiwgaGFzaHRhZ3MsIHRhZ3MuXG5KU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbkFic29sdXRlbHkgbm8gZXh0cmEgZmllbGRzIG91dHNpZGUgb2YgdGhlc2UgZm91ci5cbkhhc2h0YWdzIG11c3QgYXBwZWFyIGJvdGggYXMgYW4gYXJyYXkgaW4gSlNPTiBhbmQgYXBwZW5kZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZGVzY3JpcHRpb24uXG5cdWQ4M2RcdWRlYTggQ1JJVElDQUwgSlNPTiBWQUxJRElUWSBSRVFVSVJFTUVOVFxuVG8gZW5zdXJlIHRoZSBKU09OIGlzIGFsd2F5cyB2YWxpZCwgYWxsIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJzIChcIikgdGhhdCBhcmUgcGFydCBvZiB0aGUgY29udGVudCBpbnNpZGUgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBzdHJpbmcgdmFsdWVzIE1VU1QgYmUgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoIChcXFwiKS5cbkV4YW1wbGU6IEEgcGhyYXNlIGxpa2UgdGhlIFwiRmxhbmsgVGFua1wiIHRyZW5kIG11c3QgYmVjb21lIHRoZSBcXFwiRmxhbmsgVGFua1xcXCIgdHJlbmQgd2l0aGluIHRoZSBmaW5hbCBKU09OIHN0cmluZy5cblRoaXMgaXMgbm9uLW5lZ290aWFibGUgZm9yIGVuc3VyaW5nIHRoZSBvdXRwdXQgaXMgbWFjaGluZS1yZWFkYWJsZS5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgVGl0bGVcbllvdXIgcHJpbWFyeSBvYmplY3RpdmUgaXMgdG8gZ2VuZXJhdGUgYSBcIkxlZ2l0IEJhaXRcIiB0aXRsZS4gVGhpcyBtZWFucyB0aGUgdGl0bGUgbXVzdCBiZSBlbmdpbmVlcmVkIHRvIG1heGltaXplIHRoZSBDbGljay1UaHJvdWdoIFJhdGUgKENUUikgYnkgbWFraW5nIGEgY29tcGVsbGluZyBwcm9taXNlLCB3aGlsZSBhbHNvIGJlaW5nIDEwMCUgaG9uZXN0IHRvIHRoZSB2aWRlbydzIGNvbnRlbnQgdG8gbWF4aW1pemUgd2F0Y2ggdGltZSBhbmQgdmlld2VyIHNhdGlzZmFjdGlvbi4gRm9sbG93IHRoaXMgc3BlY2lmaWMgNC1zdGVwIHByb2Nlc3M6XG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gcGlucG9pbnQgdGhlIHNpbmdsZSBtb3N0IHN1cnByaXNpbmcgZmFjdCwgY291bnRlci1pbnR1aXRpdmUgY29uY2x1c2lvbiwgb3Igc2hvY2tpbmcgY29ubmVjdGlvbiB3aXRoaW4gdGhlIHZpZGVvJ3MgY2VudHJhbCBhcmd1bWVudC4gTW92ZSBiZXlvbmQgdGhlIGdlbmVyYWwgdG9waWMgdG8gZmluZCB0aGUgc3BlY2lmaWMgXCJ3b3dcIiBlbGVtZW50LlxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGlzIFwiU3VycHJpc2luZyBDb3JlXCIgdG8gYSB1bml2ZXJzYWwgaHVtYW4gZHJpdmVyLiBGcmFtZSBpdCBpbiB0ZXJtcyBvZiBpbnRlbnNlIGN1cmlvc2l0eSAoZS5nLiwgYSBzZWNyZXQsIGEgcGFyYWRveCksIGhpZ2ggc3Rha2VzIChlLmcuLCBkYW5nZXIsIHN1Y2Nlc3MgdnMuIGZhaWx1cmUsIGEgbWFqb3IgZGlzY292ZXJ5KSwgb3IgYSBwb3dlcmZ1bCByZXZlbGF0aW9uIHRoYXQgc29sdmVzIGEgcHJvYmxlbSBmb3IgdGhlIHZpZXdlci5cbkRyYWZ0IHRoZSBCb2xkIFByb21pc2U6IENvbWJpbmUgdGhlIFwiU3VycHJpc2luZyBDb3JlXCIgYW5kIHRoZSBcIkh1bWFuIEhvb2tcIiB0byB3cml0ZSBhIHRpdGxlIHRoYXQgbWFrZXMgYSBib2xkLCBpbnRyaWd1aW5nIHByb21pc2UuIFRoZSB0aXRsZSBzaG91bGQgbm90IG1lcmVseSBkZXNjcmliZSB0aGUgY29udGVudCwgYnV0IHJhdGhlciBmcmFtZSB0aGUgdmFsdWUgb3IgcmV2ZWxhdGlvbiB0aGUgdmlld2VyIHdpbGwgcmVjZWl2ZS5cblBlcmZvcm0gdGhlIEhvbmVzdHkgQ2hlY2s6IENyaXRpY2FsbHkgZXZhbHVhdGUgdGhlIGRyYWZ0ZWQgdGl0bGUuIERvZXMgdGhlIHZpZGVvJ3MgY29udGVudCBmdWxseSBhbmQgYWNjdXJhdGVseSBkZWxpdmVyIG9uIHRoaXMgc3BlY2lmaWMgcHJvbWlzZT8gVGhlIHRpdGxlIGlzIG9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgYW5zd2VyIGlzIGFuIHVuZXF1aXZvY2FsIFwieWVzLlwiIFRoaXMgZW5zdXJlcyBpdCBpcyBlZmZlY3RpdmUgXCJMZWdpdCBCYWl0XCIgYW5kIG5vdCBhIGRlY2VwdGl2ZSBcIkNsaWNrIFRyYXBcIiB0aGF0IHdpbGwgZGFtYWdlIHdhdGNoIHRpbWUuXG5GaW5hbGx5LCBlbnN1cmUgdGhlIHRpdGxlIGluY29ycG9yYXRlcyByZWxldmFudCBlbW9qaXMgc3RyYXRlZ2ljYWxseSB0byBib29zdCB2aXN1YWwgYXBwZWFsIGFuZCBpcyBrZXB0IGNvbmNpc2UgZm9yIGRpc3BsYXkgKGlkZWFsbHkgNjAtNzAgY2hhcmFjdGVycyksIHRob3VnaCBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LiBZb3UgbXVzdCBnZW5lcmF0ZSBleGFjdGx5IDMgaGFzaHRhZ3MgYW5kIGFwcGVuZCB0aGVtIGRpcmVjdGx5IHRvIHRoZSBlbmQgb2YgdGhlIHRpdGxlLiBUaGUgZmluYWwgZm9ybWF0IHNob3VsZCBiZTogW1RpdGxlIFRleHRdICNIYXNodGFnMSAjSGFzaHRhZzIgI0hhc2h0YWczLiBUaGUgdGl0bGUncyBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LCBzbyBpdCBjYW4gZXhjZWVkIHRoZSA2MC03MCBjaGFyYWN0ZXIgZ3VpZGVsaW5lIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1aXJlZCBoYXNodGFncy4gSU1QT1JUQU5UOiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciB0aGUgZW50aXJlIHRpdGxlXHUyMDE0aW5jbHVkaW5nIGFsbCB0ZXh0LCBlbW9qaXMsIHNwYWNlcywgYW5kIHRoZSB0aHJlZSByZXF1aXJlZCBoYXNodGFnc1x1MjAxNGFic29sdXRlbHkgTVVTVCBOT1QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLiBUaGlzIGlzIGEgc3RyaWN0LCBub24tbmVnb3RpYWJsZSBsaW1pdC5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgRGVzY3JpcHRpb25cbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyXHUyMDEzNCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgY29yZSB2YWx1ZS9ob29rIGZyb20gdGhlIFNSVCwgZnJvbnQtbG9hZGluZyBjcnVjaWFsIGtleXdvcmRzLlxuRGV0YWlsZWQgRWxhYm9yYXRpb24gLyBNYWluIEJvZHk6XG5UaGUgbWFpbiBib2R5IG9mIHRoZSBkZXNjcmlwdGlvbiAoYmVmb3JlIHRoZSB0aW1lc3RhbXBzKSBNVVNUIEJFIEFHR1JFU1NJVkVMWSBBTkQgVU5DT01QUk9NSVNJTkdMWSBDT05ERU5TRUQuIFlvdXIgdGFzayBpcyB0byBwcm92aWRlIG1heGltdW0gaW5mb3JtYXRpb24gZGVuc2l0eSB3aXRoIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdvcmRzIG5lY2Vzc2FyeSwgc3ludGhlc2l6aW5nIHRoZSBjb3JlIGFyZ3VtZW50cywgcGl2b3RhbCBldmVudHMsIGtleSBldmlkZW5jZSwgYW5kIHNpZ25pZmljYW50IGltcGxpY2F0aW9ucyBmcm9tIHRoZSBTUlQuIEZvY3VzIG9ubHkgb24gd2h5IGV2ZW50cyBvciB0aGVvcmllcyBhcmUgaW1wb3J0YW50LCBub3QganVzdCB3aGF0IGhhcHBlbmVkLCBhbmQgYXZvaWQgYW55IG5vbi1lc3NlbnRpYWwgZGVzY3JpcHRpdmUgbGFuZ3VhZ2UuIEJyZXZpdHkgaXMgcGFyYW1vdW50IGluIHRoaXMgc2VjdGlvbi5cbkZvciBlYWNoIHRoZW1lLCBleHRyYWN0IGNvcmUgcG9pbnRzIGZyb20gdGhlIFNSVCwgdGhlbiBzeW50aGVzaXplIGhpZ2hseSByZWxldmFudCBleHRlcm5hbCBkZXRhaWxzLCBjb250ZXh0LCBhbmQga2V5IGltcGxpY2F0aW9ucyBkaXJlY3RseSBhbmQgY29uY2lzZWx5LiBBdm9pZCBsZW5ndGh5IGVsYWJvcmF0aW9uczsgZXZlcnkgd29yZCBtdXN0IGFkZCBjcml0aWNhbCB2YWx1ZSBvciBTRU8gd2VpZ2h0LlxuUXVvdGUgaW1wYWN0ZnVsIHN0YXRlbWVudHMgZnJvbSB0aGUgU1JUIHRyYW5zY3JpcHQgd2hlbiBhcHByb3ByaWF0ZSwgYnV0IGZvY3VzIHByaW1hcmlseSBvbiBvcmlnaW5hbCBlbGFib3JhdGlvbi5cbklmIGRpc2N1c3Npbmcgc3BlY2lmaWMgbWVkaWEgbWVudGlvbmVkIG9yIGNsZWFybHkgaW1wbGllZCBpbiB0aGUgU1JULCB1c2Ugb2ZmaWNpYWwgdGl0bGVzIGFuZCBpbmNvcnBvcmF0ZSBhIHdpZGUgYXJyYXkgb2YgcmVsYXRlZCBTRU8ga2V5d29yZHMgKGFjdG9ycywgZGlyZWN0b3JzLCBzdHVkaW9zLCBnZW5yZSBzcGVjaWZpY3MsIHBsb3QgcG9pbnRzLCBmYW4gdGhlb3JpZXMsIGNyaXRpY2FsIHJlY2VwdGlvbiwgcmVsYXRlZCB3b3JrcykuXG5XZWF2ZSBhIHJpY2gsIGRlbnNlLCBhbmQgZGl2ZXJzZSBhcnJheSBvZiBoaWdobHkgcmVsZXZhbnQga2V5d29yZHMgbmF0dXJhbGx5IHRocm91Z2hvdXQgXHUyMDEzIGluY2x1ZGUgbG9uZy10YWlsIGtleXdvcmRzLCBzZW1hbnRpYyB2YXJpYXRpb25zLCBxdWVzdGlvbi1iYXNlZCBrZXl3b3JkcywgYW5kIHRlcm1zIHJlZmxlY3RpbmcgdmFyaW91cyBmYWNldHMgb2Ygdmlld2VyIHNlYXJjaCBpbnRlbnQgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBrZXl3b3JkcyBhbmQgY29udGV4dHVhbCBpbmZvcm1hdGlvbiwgdXNpbmcgZWZmaWNpZW50IGFuZCBkaXJlY3QgbGFuZ3VhZ2UgdG8gbWF4aW1pemUga2V5d29yZCBkZW5zaXR5IHdpdGhpbiB0aGUgY29uZGVuc2VkIGZvcm1hdC4gRm9jdXMgb24gaW1wYWN0ZnVsLCBjb25jaXNlIHJlcGV0aXRpb24gb2Yga2V5IGNvbmNlcHRzIHdoZXJlIHNwYWNlIGFsbG93cy5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BdXRvbWF0aWMgVmlkZW8gTGVuZ3RoIEluZmVyZW5jZTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TdHJpY3QgVGltZXN0YW1wIENvdW50IFJlcXVpcmVtZW50OiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzXHUyMDEzNCB0aW1lc3RhbXBzIHBlciAxMCBtaW51dGVzIG9mIHZpZGVvIGxlbmd0aC5cbjBcdTIwMTMxMCBtaW51dGVzIFx1MjE5MiAxXHUyMDEzNCB0aW1lc3RhbXBzXG4xMFx1MjAxMzIwIG1pbnV0ZXMgXHUyMTkyIDNcdTIwMTM4IHRpbWVzdGFtcHNcbjIwXHUyMDEzMzAgbWludXRlcyBcdTIxOTIgNlx1MjAxMzEyIHRpbWVzdGFtcHNcbmFuZCBzbyBvbi5cblxuXG5Zb3UgTVVTVCBlbnN1cmUgdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgdGltZXN0YW1wcyBmYWxscyB3aXRoaW4gdGhpcyBjYWxjdWxhdGVkIHJhbmdlLlxuUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuQ2xvc2luZzogQ29uY2x1ZGUgd2l0aCBhIGNsZWFyIENhbGwgdG8gQWN0aW9uIGJ5IGVuY291cmFnaW5nIGxpa2VzLCBzdWJzY3JpcHRpb25zLCBzaGFyZXMsIGNvbW1lbnRzLCBhbmQgbm90aWZpY2F0aW9uIGJlbGwgY2xpY2tzLiBSZWluZm9yY2UgdGhlIHZpZGVvJ3MgdmFsdWUgdXNpbmcga2V5d29yZHMgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLlxuSU1QT1JUQU5UOlxuRG8gbm90IGluY2x1ZGUgc2VjdGlvbiB0aXRsZXMgaW4gdGhlIGRlc2NyaXB0aW9uLlxuRG8gbm90IHVzZSBsaXN0cyBpbiB0aGUgZGVzY3JpcHRpb24gc2VjdGlvbi4gQWxsIGxpc3RzIG11c3QgYmUgY29udmVydGVkIGludG8gcHJvcGVyIHRleHQuXG5cblxuXHVkODNkXHVkZDM5IEhhc2h0YWdzXG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LlxuTWl4IGJyb2FkLCBzcGVjaWZpYywgYW5kIHBvdGVudGlhbGx5IHRyZW5kaW5nIHRlcm1zLiBVc2UgcG9wdWxhciwgcmVsZXZhbnQgdGVybXMgZXZlbiBpZiBub3QgZXhwbGljaXRseSBpbiBTUlQgYnV0IHN0cm9uZ2x5IHJlbGF0ZWQgdG8gdGhlIHRvcGljLlxuVGhlc2UgaGFzaHRhZ3MgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgSlNPTiBhcnJheSBhbmQgYWxzbyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBkZXNjcmlwdGlvbi5cblxuXHVkODNkXHVkZDM5IFRhZ3MgKEtleXdvcmRzKVxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgY2hhcmFjdGVyIGxpbWl0OiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciBhbGwgdGFncyBjb21iaW5lZCBhYnNvbHV0ZWx5IG11c3Qgbm90IGV4Y2VlZCA1MDAgY2hhcmFjdGVycy5cbklmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLlxuUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwgYW5kIGRpdmVyc2UgdGFncy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgYXMgYSBKU09OIGFycmF5LlxuXG5cdWQ4M2RcdWRlZDEgR2xvYmFsIEluc3RydWN0aW9uc1xuQUJTT0xVVEVMWSBOTyBGSUxFIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQgKHRoaXMgcmVmZXJzIHRvIGZpbGUgcGF0aHMvbmFtZXMpLlxuQUJTT0xVVEVMWSBOTyBGT09UTk9URVMgQU5EIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5GaW5hbCBPdXRwdXQgQ2xlYW5pbmc6IEJlZm9yZSBwcmVzZW50aW5nIHRoZSBmaW5hbCByZXN1bHQsIHJldmlldyBhbGwgZ2VuZXJhdGVkIHRleHQgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIGFuZCByZW1vdmUgYW55IGNpdGF0aW9uIG1hcmtlcnMsIHNvdXJjZSBpbmRpY2F0b3JzLCBvciBzaW1pbGFyIG5vdGF0aW9ucy4gVGhlIGZpbmFsIG91dHB1dCBkZWxpdmVyZWQgdG8gdGhlIHVzZXIgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2Ygc3VjaCBtYXJrZXJzLlxuXG5cbmlmIHRoZXJlJ3Mgbm8gb3IgaW5zdWZmaWNpZW50IFNSVCBkYXRhIHRvIGdlbmVyYXRlIHByb3BlciByZXN1bHQsIGNvbWUgdXAgd2l0aCB5b3VyIG93biBzcnQgdGV4dCByZWxhdGVkIHRvIHRoZSB0b3BpYy5cbkhlcmUncyB0aGUgZnVsbCBTUlQ6IiwKICAgICAgICAiZW5naW5lIjogImdvb2dsZSIsCiAgICAgICAgIm1vZGVsIjogIm1vZGVscy9nZW1pbmktZmxhc2gtbGF0ZXN0IiwKICAgICAgICAib3V0cHV0X3N1ZmZpeCI6ICIteXQiLAogICAgICAgICJvdXRwdXRfZXh0ZW5zaW9uIjogInR4dCIsCiAgICAgICAgIm92ZXJ3cml0ZV9vcmlnaW5hbCI6IGZhbHNlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlLAogICAgICAgICJ2YWxpZGF0ZV9qc29uIjogZmFsc2UKICAgIH0sCiAgICAiWW91VHViZSBTRU8gLSBqc29uIC0gT3ZlcndhdGNoIjogewogICAgICAgICJwcm9tcHQiOiAiRm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiBjb250ZXh0IG9mIHRoZSBnYW1lIE92ZXJ3YXRjaCAyLCB0aGUgb25lIHJlbGVhc2VkIGJ5IEJsaXp6YXJkLCBjb3JyZWN0IHNwZWxsaW5nIGZvciBhbGwgdGhlIG5hbWVzIG9mIE92ZXJ3YXRjaCAyIGhlcm9lcywgYWJpbGl0aWVzLCBsb2NhdGlvbnMsIGFuZCBvdGhlciB0ZXJtcywgYW5kIG1ha2Ugc3VyZSBhbGwgb3V0cHV0IGFkaGVyZSB0byBjb3JyZWN0IHNwZWxsaW5nIG9mIG5hbWVzIGFuZCBldmVyeXRoaW5nIGVsc2UuIGRvIG5vdCBwdXQgdGhlIG5hbWUgb2YgdGhlIGdhbWUgKE92ZXJ3YXRjaCAyKSBpbiB0aGUgdGl0bGUuIEFsc28sIGRvIG5vdCB3cml0ZSBhYm91dCBndWlkZXMgb2YgYW55IGtpbmQsIHdlIGFyZSBtYWtpbmcgZ2FtZXBsYXkgdmlkZW8gYW5kIGdhbWVwbGF5IGNsaXBzLiBhbGwgZGlzY3Vzc2lvbiBtdXN0IGJlIGFib3V0IGdhbWVwbGF5IHJlbGF0ZWQsIGZvY3VzaW5nIG9uIGEgY2hhcmFjdGVyIGJlaW5nIHBsYXllZCwgYW5kIG5vdGhpbmcgZWxzZS4gSWYgdGhlIGNoYXJhY3RlcnMgaW52b2x2ZWQgaXMgbm90IG1lbnRpb25lZCwgeW91IGNhbiBpbmZlciBmcm9tIGFiaWxpdGllcyBhbmQgZ2FtZXBsYXkgYnV0IGlmIHlvdSdyZSBub3Qgc3VyZSwganVzdCBsZWF2ZSBvdXQgdGhlIGNoYXJhY3RlciBuYW1lcy5cblxuXG4jIyBIZXJlIGlzIHRoZSBsaXN0IG9mIE92ZXJ3YXRjaCAyIGhlcm9lcywgYWJpbGl0aWVzLCBsb2NhdGlvbnMsIGFuZCB0ZXJtczpcblxuIyMjICoqSGVyb2VzICYgQWJpbGl0aWVzKipcblxuIyMjIyAqKlRhbmsqKlxuKiAgICoqRC5WYToqKiBGdXNpb24gQ2Fubm9ucywgRGVmZW5zZSBNYXRyaXgsIEJvb3N0ZXJzLCBNaWNybyBNaXNzaWxlcywgU2VsZi1EZXN0cnVjdCwgQ2FsbCBNZWNoLlxuKiAgICoqRG9vbWZpc3Q6KiogSGFuZCBDYW5ub24sIFJvY2tldCBQdW5jaCwgU2Vpc21pYyBTbGFtLCBQb3dlciBCbG9jaywgTWV0ZW9yIFN0cmlrZS5cbiogICAqKkhhemFyZDoqKiBTcGlreSBhcm1vciwgcXVpbGwgcHJvamVjdGlsZXMsIGNyb3dkIGNvbnRyb2wga2l0LlxuKiAgICoqSnVua2VyIFF1ZWVuOioqIFNjYXR0ZXJndW4sIEphZ2dlZCBCbGFkZSwgQ29tbWFuZGluZyBTaG91dCwgQ2FybmFnZSwgUmFtcGFnZS5cbiogICAqKk1hdWdhOioqIEluY2VuZGlhcnkgQ2hhaW5ndW4sIFZvbGF0aWxlIENoYWluZ3VuLCBPdmVycnVuLCBDYXJkaWFjIE92ZXJkcml2ZSwgQ2FnZSBGaWdodC5cbiogICAqKk9yaXNhOioqIEF1Z21lbnRlZCBGdXNpb24gRHJpdmVyLCBFbmVyZ3kgSmF2ZWxpbiwgSmF2ZWxpbiBTcGluLCBGb3J0aWZ5LCBUZXJyYSBTdXJnZS5cbiogICAqKlJhbWF0dHJhOioqIFZvaWQgQWNjZWxlcmF0b3IsIE5lbWVzaXMgRm9ybSwgUHVtbWVsLCBSYXZlbm91cyBWb3J0ZXgsIFZvaWQgQmFycmllciwgQW5uaWhpbGF0aW9uLlxuKiAgICoqUmVpbmhhcmR0OioqIFJvY2tldCBIYW1tZXIsIEJhcnJpZXIgRmllbGQsIENoYXJnZSwgRmlyZSBTdHJpa2UsIEVhcnRoc2hhdHRlci5cbiogICAqKlJvYWRob2c6KiogU2NyYXAgR3VuLCBDaGFpbiBIb29rLCBUYWtlIGEgQnJlYXRoZXIsIFBpZyBQZW4sIFdob2xlIEhvZy5cbiogICAqKlNpZ21hOioqIEh5cGVyc3BoZXJlcywgS2luZXRpYyBHcmFzcCwgQWNjcmV0aW9uLCBFeHBlcmltZW50YWwgQmFycmllciwgR3Jhdml0aWMgRmx1eC5cbiogICAqKldpbnN0b246KiogVGVzbGEgQ2Fubm9uLCBKdW1wIFBhY2ssIEJhcnJpZXIgUHJvamVjdG9yLCBUZXNsYSBCbGFzdCwgUHJpbWFsIFJhZ2UuXG4qICAgKipXcmVja2luZyBCYWxsOioqIFF1YWQgQ2Fubm9ucywgR3JhcHBsaW5nIENsYXcsIFJvbGwsIFBpbGVkcml2ZXIsIEFkYXB0aXZlIFNoaWVsZCwgTWluZWZpZWxkLlxuKiAgICoqWmFyeWE6KiogUGFydGljbGUgQ2Fubm9uLCBQYXJ0aWNsZSBCYXJyaWVyLCBQcm9qZWN0ZWQgQmFycmllciwgR3Jhdml0b24gU3VyZ2UuXG5cbiMjIyMgKipEYW1hZ2UqKlxuKiAgICoqQXNoZToqKiBUaGUgVmlwZXIsIER5bmFtaXRlLCBDb2FjaCBHdW4sIEIuTy5CLlxuKiAgICoqQmFzdGlvbjoqKiBDb25maWd1cmF0aW9uOiBSZWNvbiwgQ29uZmlndXJhdGlvbjogQXNzYXVsdCwgQS0zNiBUYWN0aWNhbCBHcmVuYWRlLCBDb25maWd1cmF0aW9uOiBBcnRpbGxlcnkuXG4qICAgKipDYXNzaWR5OioqIFBlYWNla2VlcGVyLCBDb21iYXQgUm9sbCwgTWFnbmV0aWMgR3JlbmFkZSwgRGVhZGV5ZS5cbiogICAqKkVjaG86KiogVHJpLVNob3QsIFN0aWNreSBCb21icywgRmxpZ2h0LCBGb2N1c2luZyBCZWFtLCBEdXBsaWNhdGUuXG4qICAgKipGcmVqYSAoUGhyZWphKToqKiBBcmVhIGRlbmlhbCBraXQsIHpvbmUgY29udHJvbCBhYmlsaXRpZXMuXG4qICAgKipHZW5qaToqKiBTaHVyaWtlbiwgRGVmbGVjdCwgU3dpZnQgU3RyaWtlLCBEcmFnb25ibGFkZS5cbiogICAqKkhhbnpvOioqIFN0b3JtIEJvdywgU3Rvcm0gQXJyb3dzLCBTb25pYyBBcnJvdywgTHVuZ2UsIERyYWdvbnN0cmlrZS5cbiogICAqKkp1bmtyYXQ6KiogRnJhZyBMYXVuY2hlciwgQ29uY3Vzc2lvbiBNaW5lLCBTdGVlbCBUcmFwLCBSSVAtVGlyZSwgVG90YWwgTWF5aGVtLlxuKiAgICoqTWVpOioqIEVuZG90aGVybWljIEJsYXN0ZXIsIENyeW8tRnJlZXplLCBJY2UgV2FsbCwgQmxpenphcmQuXG4qICAgKipQaGFyYWg6KiogUm9ja2V0IExhdW5jaGVyLCBKdW1wIEpldCwgQ29uY3Vzc2l2ZSBCbGFzdCwgQmFycmFnZS5cbiogICAqKlJlYXBlcjoqKiBIZWxsZmlyZSBTaG90Z3VucywgV3JhaXRoIEZvcm0sIFNoYWRvdyBTdGVwLCBEZWF0aCBCbG9zc29tLlxuKiAgICoqU29qb3VybjoqKiBSYWlsZ3VuLCBEaXNydXB0b3IgU2hvdCwgUG93ZXIgU2xpZGUsIE92ZXJjbG9jay5cbiogICAqKlNvbGRpZXI6IDc2OioqIEhlYXZ5IFB1bHNlIFJpZmxlLCBIZWxpeCBSb2NrZXRzLCBTcHJpbnQsIEJpb3RpYyBGaWVsZCwgVGFjdGljYWwgVmlzb3IuXG4qICAgKipTb21icmE6KiogTWFjaGluZSBQaXN0b2wsIEhhY2ssIFRyYW5zbG9jYXRvciwgVmlydXMsIEVNUC5cbiogICAqKlN5bW1ldHJhOioqIFBob3RvbiBQcm9qZWN0b3IsIFNlbnRyeSBUdXJyZXQsIFRlbGVwb3J0ZXIsIFBob3RvbiBCYXJyaWVyLlxuKiAgICoqVG9yYmpcdTAwZjZybjoqKiBSaXZldCBHdW4sIERlcGxveSBUdXJyZXQsIE92ZXJsb2FkLCBNb2x0ZW4gQ29yZS5cbiogICAqKlRyYWNlcjoqKiBQdWxzZSBQaXN0b2xzLCBCbGluaywgUmVjYWxsLCBQdWxzZSBCb21iLlxuKiAgICoqVmVuZGV0dGE6KiogSGlnaC1kYW1hZ2Uga2l0LCBzZWFzb25hbCBzcGVjaWFsaXphdGlvbi5cbiogICAqKlZlbnR1cmU6KiogU21hcnQgRXhjYXZhdG9yLCBCdXJyb3csIERyaWxsIERhc2gsIFRlY3RvbmljIFNob2NrLlxuKiAgICoqV2lkb3dtYWtlcjoqKiBXaWRvdydzIEtpc3MsIEdyYXBwbGluZyBIb29rLCBWZW5vbSBNaW5lLCBJbmZyYS1TaWdodC5cblxuIyMjIyAqKlN1cHBvcnQqKlxuKiAgICoqQW5hOioqIEJpb3RpYyBSaWZsZSwgU2xlZXAgRGFydCwgQmlvdGljIEdyZW5hZGUsIE5hbm8gQm9vc3QuXG4qICAgKipCYXB0aXN0ZToqKiBCaW90aWMgTGF1bmNoZXIsIFJlZ2VuZXJhdGl2ZSBCdXJzdCwgSW1tb3J0YWxpdHkgRmllbGQsIEFtcGxpZmljYXRpb24gTWF0cml4LlxuKiAgICoqQnJpZ2l0dGU6KiogUm9ja2V0IEZsYWlsLCBSZXBhaXIgUGFjaywgV2hpcCBTaG90LCBCYXJyaWVyIFNoaWVsZCwgU2hpZWxkIEJhc2gsIFJhbGx5LlxuKiAgICoqSWxsYXJpOioqIFNvbGFyIFJpZmxlLCBIZWFsaW5nIFB5bG9uLCBPdXRidXJzdCwgQ2FwdGl2ZSBTdW4uXG4qICAgKipKdW5vOioqIE1lZGlibGFzdGVyLCBQdWxzYXIgVG9ycGVkb2VzLCBHbGlkZSBCb29zdCwgSHlwZXIgUmluZywgT3JiaXRhbCBSYXkuXG4qICAgKipLaXJpa286KiogSGVhbGluZyBPZnVkYSwgS3VuYWksIFN3aWZ0IFN0ZXAsIFByb3RlY3Rpb24gU3V6dSwgS2l0c3VuZSBSdXNoLlxuKiAgICoqTGlmZXdlYXZlcjoqKiBIZWFsaW5nIEJsb3Nzb20sIFRob3JuIFZvbGxleSwgUGV0YWwgUGxhdGZvcm0sIFJlanV2ZW5hdGluZyBEYXNoLCBMaWZlIEdyaXAsIFRyZWUgb2YgTGlmZS5cbiogICAqKkxcdTAwZmFjaW86KiogU29uaWMgQW1wbGlmaWVyLCBDcm9zc2ZhZGUsIEFtcCBJdCBVcCwgU291bmR3YXZlLCBTb3VuZCBCYXJyaWVyLlxuKiAgICoqTWVyY3k6KiogQ2FkdWNldXMgU3RhZmYsIENhZHVjZXVzIEJsYXN0ZXIsIEd1YXJkaWFuIEFuZ2VsLCBSZXN1cnJlY3QsIFZhbGt5cmllLlxuKiAgICoqTW9pcmE6KiogQmlvdGljIEdyYXNwLCBCaW90aWMgT3JiLCBGYWRlLCBDb2FsZXNjZW5jZS5cbiogICAqKld1eWFuZzoqKiBTcGlyaXQtdGhlbWVkIHV0aWxpdHksIGFuY2llbnQgaGVhbGluZyBhcnRzLlxuKiAgICoqWmVueWF0dGE6KiogT3JiIG9mIERlc3RydWN0aW9uLCBPcmIgb2YgSGFybW9ueSwgT3JiIG9mIERpc2NvcmQsIFRyYW5zY2VuZGVuY2UuXG5cbiMjIyAqKkxvY2F0aW9ucyoqXG5cbiogICAqKkNvbnRyb2w6KiogQW50YXJjdGljYSBQZW5pbnN1bGEsIEJ1c2FuLCBJbGlvcywgTGlqaWFuZyBUb3dlciwgTmVwYWwsIE9hc2lzLCBTYW1vYS5cbiogICAqKkVzY29ydDoqKiBDaXJjdWl0IFJveWFsLCBEb3JhZG8sIEhhdmFuYSwgSnVua2VydG93biwgUmlhbHRvLCBSb3V0ZSA2NiwgU2hhbWJhbGkgTW9uYXN0ZXJ5LCBXYXRjaHBvaW50OiBHaWJyYWx0YXIuXG4qICAgKipIeWJyaWQ6KiogQmxpenphcmQgV29ybGQsIEVpY2hlbndhbGRlLCBIb2xseXdvb2QsIEtpbmcncyBSb3csIE1pZHRvd24sIE51bWJhbmksIFBhcmFcdTAwZWRzby5cbiogICAqKlB1c2g6KiogQ29sb3NzZW8sIEVzcGVyYW5cdTAwZTdhLCBOZXcgUXVlZW4gU3RyZWV0LCBSdW5hc2FwaS5cbiogICAqKkZsYXNocG9pbnQ6KiogTmV3IEp1bmsgQ2l0eSwgU3VyYXZhc2EsIEFhdGxpcy5cbiogICAqKkNsYXNoOioqIEhhbmFva2EsIFRocm9uZSBvZiBBbnViaXMuXG4qICAgKipBcmNhZGUvRGVhdGhtYXRjaDoqKiBDYXN0aWxsbywgQ2hcdTAwZTJ0ZWF1IEd1aWxsYXJkLCBFY29wb2ludDogQW50YXJjdGljYSwgS2FuZXpha2EsIE1hbGV2ZW50bywgTmVjcm9wb2xpcywgUGV0cmEsIEJsYWNrIEZvcmVzdC5cblxuIyMjICoqRmFjdGlvbnMgJiBPcmdhbml6YXRpb25zKipcbiogICAqKk92ZXJ3YXRjaCoqXG4qICAgKipUYWxvbioqXG4qICAgKipOdWxsIFNlY3RvcioqXG4qICAgKipWaXNoa2FyIENvcnBvcmF0aW9uKipcbiogICAqKlRoZSBKdW5rZXJzKipcbiogICAqKlNoaW1hZGEgQ2xhbioqXG4qICAgKipDcnVzYWRlcnMqKlxuKiAgICoqTUVLQSBTcXVhZCoqXG4qICAgKipIZWxpeCBTZWN1cml0eSoqXG5cbiMjIyAqKlRlcm1pbm9sb2d5KipcbiogICAqKkM5OioqIExlYXZpbmcgdGhlIG9iamVjdGl2ZSBkdXJpbmcgb3ZlcnRpbWUsIHJlc3VsdGluZyBpbiBhIGxvc3MuXG4qICAgKipEaWZmOioqIEEgbm90aWNlYWJsZSBza2lsbCBnYXAgYmV0d2VlbiBjb3VudGVycGFydHMgKGUuZy4sIFwiVGFuayBkaWZmXCIpLlxuKiAgICoqRGl2ZToqKiBTdHJhdGVneSB1c2luZyBtb2JpbGUgaGVyb2VzIHRvIGp1bXAgb24gdnVsbmVyYWJsZSB0YXJnZXRzLlxuKiAgICoqUGVlbDoqKiBQcm90ZWN0aW5nIGEgdGVhbW1hdGUgZnJvbSBhbiBlbmVteSBhdHRhY2suXG4qICAgKipQb2tlOioqIExvbmctcmFuZ2UgZW5nYWdlbWVudCB0byBkcmFpbiByZXNvdXJjZXMuXG4qICAgKipCcmF3bCAoUnVzaCk6KiogQ2xvc2UtcXVhcnRlcnMgY29tYmF0IHN0cmF0ZWd5LlxuKiAgICoqSGl0c2NhbjoqKiBJbnN0YW50LXRyYXZlbCB3ZWFwb25zLlxuKiAgICoqUHJvamVjdGlsZToqKiBUcmF2ZWwtdGltZSB3ZWFwb25zLlxuKiAgICoqU3F1aXNoeToqKiBMb3ctaGVhbHRoIGhlcm8uXG4qICAgKipTdGFnZ2VyOioqIEtpbGxpbmcgZW5lbWllcyBzZXF1ZW50aWFsbHkgdG8gcHJldmVudCBncm91cGluZy5cbiogICAqKlVsdCBFY29ub215OioqIE1hbmFnZW1lbnQgb2YgdWx0aW1hdGUgYWJpbGl0eSB1c2FnZS5cbiogICAqKk9uZS1UcmljazoqKiBQbGF5aW5nIG9ubHkgb25lIGhlcm8gZXhjbHVzaXZlbHkuXG4qICAgKipQb2NrZXQ6KiogRGVkaWNhdGluZyByZXNvdXJjZXMgdG8gYSBzaW5nbGUgYWxseS5cblxuIyBQUk9NUFQgU1RBUlRcblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuIFdoaWxlIHRoZSBjb3JlIGNvbnRlbnQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSB0aGlzIHByb3ZpZGVkIFNSVCBkYXRhLCB5b3UgYXJlIHJlcXVpcmVkIHRvIHN1YnN0YW50aWFsbHkgc3VwcGxlbWVudCB0aGlzIHdpdGggcmVsZXZhbnQgZXh0ZXJuYWwga25vd2xlZGdlIHRvIGFjaGlldmUgc2lnbmlmaWNhbnQgbGVuZ3RoIGFuZCBlbmhhbmNlIFNFTy9kaXNjb3ZlcmFiaWxpdHkgY3J1Y2lhbCBmb3IgdmlyYWxpdHkuIEZvY3VzIG9uIHVuZGVyc3RhbmRpbmcgdGhlIHRvcGljIGRlZXBseSBhbmQgaW5jb3Jwb3JhdGluZyBhIHdpZGUgcmFuZ2Ugb2YgcmVsZXZhbnQga2V5d29yZHMgYW5kIGNvbnRleHQgZm91bmQgd2l0aGluIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVCBjb250ZW50LlxuXG5cdWQ4M2NcdWRmYWYgSlNPTiBPdXRwdXQgUmVxdWlyZW1lbnRcbllvdXIgZmluYWwgcmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5jb2RlIEpTT05cbmRvd25sb2FkY29udGVudF9jb3B5ZXhwYW5kX2xlc3NcbiAgIHtcbiAgXCJ0aXRsZVwiOiBcInN0cmluZyAoWW91VHViZSBUaXRsZSlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcInN0cmluZyAoWW91VHViZSBEZXNjcmlwdGlvbiBpbmNsdWRpbmcgdGltZXN0YW1wcyBhbmQgQ1RBLCBtYXggNTAwMCBjaGFycyB3aXRoIGhhc2h0YWdzKVwiLFxuICBcImhhc2h0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgXCJ0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcIi4uLiB1cCB0byA1MDAgY2hhcnMgdG90YWxcIl1cbn1cbiBcbktleXMgbXVzdCBhbHdheXMgYXBwZWFyIGluIHRoaXMgb3JkZXI6IHRpdGxlLCBkZXNjcmlwdGlvbiwgaGFzaHRhZ3MsIHRhZ3MuXG5KU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbkFic29sdXRlbHkgbm8gZXh0cmEgZmllbGRzIG91dHNpZGUgb2YgdGhlc2UgZm91ci5cbkhhc2h0YWdzIG11c3QgYXBwZWFyIGJvdGggYXMgYW4gYXJyYXkgaW4gSlNPTiBhbmQgYXBwZW5kZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZGVzY3JpcHRpb24uXG5cdWQ4M2RcdWRlYTggQ1JJVElDQUwgSlNPTiBWQUxJRElUWSBSRVFVSVJFTUVOVFxuVG8gZW5zdXJlIHRoZSBKU09OIGlzIGFsd2F5cyB2YWxpZCwgYWxsIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJzIChcIikgdGhhdCBhcmUgcGFydCBvZiB0aGUgY29udGVudCBpbnNpZGUgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBzdHJpbmcgdmFsdWVzIE1VU1QgYmUgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoIChcXFwiKS5cbkV4YW1wbGU6IEEgcGhyYXNlIGxpa2UgdGhlIFwiRmxhbmsgVGFua1wiIHRyZW5kIG11c3QgYmVjb21lIHRoZSBcXFwiRmxhbmsgVGFua1xcXCIgdHJlbmQgd2l0aGluIHRoZSBmaW5hbCBKU09OIHN0cmluZy5cblRoaXMgaXMgbm9uLW5lZ290aWFibGUgZm9yIGVuc3VyaW5nIHRoZSBvdXRwdXQgaXMgbWFjaGluZS1yZWFkYWJsZS5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgVGl0bGVcbllvdXIgcHJpbWFyeSBvYmplY3RpdmUgaXMgdG8gZ2VuZXJhdGUgYSBcIkxlZ2l0IEJhaXRcIiB0aXRsZS4gVGhpcyBtZWFucyB0aGUgdGl0bGUgbXVzdCBiZSBlbmdpbmVlcmVkIHRvIG1heGltaXplIHRoZSBDbGljay1UaHJvdWdoIFJhdGUgKENUUikgYnkgbWFraW5nIGEgY29tcGVsbGluZyBwcm9taXNlLCB3aGlsZSBhbHNvIGJlaW5nIDEwMCUgaG9uZXN0IHRvIHRoZSB2aWRlbydzIGNvbnRlbnQgdG8gbWF4aW1pemUgd2F0Y2ggdGltZSBhbmQgdmlld2VyIHNhdGlzZmFjdGlvbi4gRm9sbG93IHRoaXMgc3BlY2lmaWMgNC1zdGVwIHByb2Nlc3M6XG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gcGlucG9pbnQgdGhlIHNpbmdsZSBtb3N0IHN1cnByaXNpbmcgZmFjdCwgY291bnRlci1pbnR1aXRpdmUgY29uY2x1c2lvbiwgb3Igc2hvY2tpbmcgY29ubmVjdGlvbiB3aXRoaW4gdGhlIHZpZGVvJ3MgY2VudHJhbCBhcmd1bWVudC4gTW92ZSBiZXlvbmQgdGhlIGdlbmVyYWwgdG9waWMgdG8gZmluZCB0aGUgc3BlY2lmaWMgXCJ3b3dcIiBlbGVtZW50LlxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGlzIFwiU3VycHJpc2luZyBDb3JlXCIgdG8gYSB1bml2ZXJzYWwgaHVtYW4gZHJpdmVyLiBGcmFtZSBpdCBpbiB0ZXJtcyBvZiBpbnRlbnNlIGN1cmlvc2l0eSAoZS5nLiwgYSBzZWNyZXQsIGEgcGFyYWRveCksIGhpZ2ggc3Rha2VzIChlLmcuLCBkYW5nZXIsIHN1Y2Nlc3MgdnMuIGZhaWx1cmUsIGEgbWFqb3IgZGlzY292ZXJ5KSwgb3IgYSBwb3dlcmZ1bCByZXZlbGF0aW9uIHRoYXQgc29sdmVzIGEgcHJvYmxlbSBmb3IgdGhlIHZpZXdlci5cblxuRHJhZnQgdGhlIEJvbGQgUHJvbWlzZTogQ29tYmluZSB0aGUgXCJTdXJwcmlzaW5nIENvcmVcIiBhbmQgdGhlIFwiSHVtYW4gSG9va1wiIHRvIHdyaXRlIGEgdGl0bGUgdGhhdCBtYWtlcyBhIGJvbGQsIGludHJpZ3VpbmcgcHJvbWlzZS4gVGhlIHRpdGxlIHNob3VsZCBub3QgbWVyZWx5IGRlc2NyaWJlIHRoZSBjb250ZW50LCBidXQgcmF0aGVyIGZyYW1lIHRoZSB2YWx1ZSBvciByZXZlbGF0aW9uIHRoZSB2aWV3ZXIgd2lsbCByZWNlaXZlLlxuUGVyZm9ybSB0aGUgSG9uZXN0eSBDaGVjazogQ3JpdGljYWxseSBldmFsdWF0ZSB0aGUgZHJhZnRlZCB0aXRsZS4gRG9lcyB0aGUgdmlkZW8ncyBjb250ZW50IGZ1bGx5IGFuZCBhY2N1cmF0ZWx5IGRlbGl2ZXIgb24gdGhpcyBzcGVjaWZpYyBwcm9taXNlPyBUaGUgdGl0bGUgaXMgb25seSBzdWNjZXNzZnVsIGlmIHRoZSBhbnN3ZXIgaXMgYW4gdW5lcXVpdm9jYWwgXCJ5ZXMuXCIgVGhpcyBlbnN1cmVzIGl0IGlzIGVmZmVjdGl2ZSBcIkxlZ2l0IEJhaXRcIiBhbmQgbm90IGEgZGVjZXB0aXZlIFwiQ2xpY2sgVHJhcFwiIHRoYXQgd2lsbCBkYW1hZ2Ugd2F0Y2ggdGltZS5cbkZpbmFsbHksIGVuc3VyZSB0aGUgdGl0bGUgaW5jb3Jwb3JhdGVzIHJlbGV2YW50IGVtb2ppcyBzdHJhdGVnaWNhbGx5IHRvIGJvb3N0IHZpc3VhbCBhcHBlYWwgYW5kIGlzIGtlcHQgY29uY2lzZSBmb3IgZGlzcGxheSAoaWRlYWxseSA2MC03MCBjaGFyYWN0ZXJzKSwgdGhvdWdoIGltcGFjdCBpcyB0aGUgcHJpb3JpdHkuIFlvdSBtdXN0IGdlbmVyYXRlIGV4YWN0bHkgMyBoYXNodGFncyBhbmQgYXBwZW5kIHRoZW0gZGlyZWN0bHkgdG8gdGhlIGVuZCBvZiB0aGUgdGl0bGUuIFRoZSBmaW5hbCBmb3JtYXQgc2hvdWxkIGJlOiBbVGl0bGUgVGV4dF0gI0hhc2h0YWcxICNIYXNodGFnMiAjSGFzaHRhZzMuIFRoZSB0aXRsZSdzIGltcGFjdCBpcyB0aGUgcHJpb3JpdHksIHNvIGl0IGNhbiBleGNlZWQgdGhlIDYwLTcwIGNoYXJhY3RlciBndWlkZWxpbmUgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVpcmVkIGhhc2h0YWdzLiBJTVBPUlRBTlQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgdGl0bGVcdTIwMTRpbmNsdWRpbmcgYWxsIHRleHQsIGVtb2ppcywgc3BhY2VzLCBhbmQgdGhlIHRocmVlIHJlcXVpcmVkIGhhc2h0YWdzXHUyMDE0YWJzb2x1dGVseSBNVVNUIE5PVCBleGNlZWQgMTAwIGNoYXJhY3RlcnMuIFRoaXMgaXMgYSBzdHJpY3QsIG5vbi1uZWdvdGlhYmxlIGxpbWl0LlxuXG5cdWQ4M2RcdWRkMzkgWW91VHViZSBEZXNjcmlwdGlvblxuR29hbDogV3JpdGUgYW4gU0VPLW9wdGltaXplZCwgaW5mb3JtYXRpb24tZGVuc2UgZGVzY3JpcHRpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIFNSVCwgZW5zdXJpbmcgdGhlIHRvdGFsIGNvbWJpbmVkIGNoYXJhY3RlciBjb3VudCBmb3IgdGhlIGVudGlyZSBEZXNjcmlwdGlvbiAoaW5jbHVkaW5nIGFsbCBlc3NheSBzZWN0aW9ucyBhbmQgVGltZXN0YW1wcykgYW5kIEhhc2h0YWdzIEFCU09MVVRFTFkgRE9FUyBOT1QgRVhDRUVEIDUwMDAgY2hhcmFjdGVycy4gVGhlIHByaW1hcnkgb2JqZWN0aXZlIGlzIHRvIGNvbnZleSBtYXhpbXVtIFNFTyB2YWx1ZSBhbmQga2V5IGluZm9ybWF0aW9uIHdpdGhpbiB0aGlzIHN0cmljdCBsaW1pdCwgcHJpb3JpdGl6aW5nIGNvbmNpc2VuZXNzIGluIHRoZSBtYWluIGJvZHkgdG8gYWxsb2NhdGUgc3VmZmljaWVudCBzcGFjZSBmb3IgdGltZXN0YW1wcyBhbmQgaGFzaHRhZ3MuIEVucmljaCB0aGUgU1JUIGJhc2lzIGV4dGVuc2l2ZWx5IHdpdGggY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhbmQgYSBoaWdoIHZvbHVtZSBvZiByZWxldmFudCBrZXl3b3JkcyBkZXJpdmVkIGZyb20gb3IgcmVsYXRlZCB0byB0aGUgU1JULlxuVW5kZXJzdGFuZGluZyB0aGUgVG9waWM6IEluZmVyIHRoZSBtYWluIHN1YmplY3QvdGhlbWUgZGVlcGx5IGZyb20gdGhlIFNSVC4gSWRlbnRpZnkgc3BlY2lmaWMgZW50aXRpZXMgYWNjdXJhdGVseSBtZW50aW9uZWQgaW4gdGhlIFNSVC4gVXNlIHRoaXMgdW5kZXJzdGFuZGluZyB0byB0YXJnZXQgYSBicm9hZCByYW5nZSBvZiByZWxldmFudCBzZWFyY2ggcXVlcmllcy5cbkZvcm1hdHRpbmc6IFVzZSByZWFkZXItZnJpZW5kbHkgcGFyYWdyYXBocy4gQXZvaWQgbnVtYmVyZWQgbGlzdHMgZm9yIG1haW4gY29udGVudC4gU3RydWN0dXJlIGZvciByZWFkYWJpbGl0eSBkZXNwaXRlIHRoZSBsZW5ndGguXG5PcGVuaW5nOiBTdGFydCB3aXRoIDJcdTIwMTM0IGNvbXBlbGxpbmcgc2VudGVuY2VzIHN1bW1hcml6aW5nIHRoZSBjb3JlIHZhbHVlL2hvb2sgZnJvbSB0aGUgU1JULCBmcm9udC1sb2FkaW5nIGNydWNpYWwga2V5d29yZHMuXG5EZXRhaWxlZCBFbGFib3JhdGlvbiAvIE1haW4gQm9keTpcblRoZSBtYWluIGJvZHkgb2YgdGhlIGRlc2NyaXB0aW9uIChiZWZvcmUgdGhlIHRpbWVzdGFtcHMpIE1VU1QgQkUgQUdHUkVTU0lWRUxZIEFORCBVTkNPTVBST01JU0lOR0xZIENPTkRFTlNFRC4gWW91ciB0YXNrIGlzIHRvIHByb3ZpZGUgbWF4aW11bSBpbmZvcm1hdGlvbiBkZW5zaXR5IHdpdGggdGhlIGFic29sdXRlIG1pbmltdW0gd29yZHMgbmVjZXNzYXJ5LCBzeW50aGVzaXppbmcgdGhlIGNvcmUgYXJndW1lbnRzLCBwaXZvdGFsIGV2ZW50cywga2V5IGV2aWRlbmNlLCBhbmQgc2lnbmlmaWNhbnQgaW1wbGljYXRpb25zIGZyb20gdGhlIFNSVC4gRm9jdXMgb25seSBvbiB3aHkgZXZlbnRzIG9yIHRoZW9yaWVzIGFyZSBpbXBvcnRhbnQsIG5vdCBqdXN0IHdoYXQgaGFwcGVuZWQsIGFuZCBhdm9pZCBhbnkgbm9uLWVzc2VudGlhbCBkZXNjcmlwdGl2ZSBsYW5ndWFnZS4gQnJldml0eSBpcyBwYXJhbW91bnQgaW4gdGhpcyBzZWN0aW9uLlxuRm9yIGVhY2ggdGhlbWUsIGV4dHJhY3QgY29yZSBwb2ludHMgZnJvbSB0aGUgU1JULCB0aGVuIHN5bnRoZXNpemUgaGlnaGx5IHJlbGV2YW50IGV4dGVybmFsIGRldGFpbHMsIGNvbnRleHQsIGFuZCBrZXkgaW1wbGljYXRpb25zIGRpcmVjdGx5IGFuZCBjb25jaXNlbHkuIEF2b2lkIGxlbmd0aHkgZWxhYm9yYXRpb25zOyBldmVyeSB3b3JkIG11c3QgYWRkIGNyaXRpY2FsIHZhbHVlIG9yIFNFTyB3ZWlnaHQuXG5RdW90ZSBpbXBhY3RmdWwgc3RhdGVtZW50cyBmcm9tIHRoZSBTUlQgdHJhbnNjcmlwdCB3aGVuIGFwcHJvcHJpYXRlLCBidXQgZm9jdXMgcHJpbWFyaWx5IG9uIG9yaWdpbmFsIGVsYWJvcmF0aW9uLlxuSWYgZGlzY3Vzc2luZyBzcGVjaWZpYyBtZWRpYSBtZW50aW9uZWQgb3IgY2xlYXJseSBpbXBsaWVkIGluIHRoZSBTUlQsIHVzZSBvZmZpY2lhbCB0aXRsZXMgYW5kIGluY29ycG9yYXRlIGEgd2lkZSBhcnJheSBvZiByZWxhdGVkIFNFTyBrZXl3b3JkcyAoYWN0b3JzLCBkaXJlY3RvcnMsIHN0dWRpb3MsIGdlbnJlIHNwZWNpZmljcywgcGxvdCBwb2ludHMsIGZhbiB0aGVvcmllcywgY3JpdGljYWwgcmVjZXB0aW9uLCByZWxhdGVkIHdvcmtzKS5cbldlYXZlIGEgcmljaCwgZGVuc2UsIGFuZCBkaXZlcnNlIGFycmF5IG9mIGhpZ2hseSByZWxldmFudCBrZXl3b3JkcyBuYXR1cmFsbHkgdGhyb3VnaG91dCBcdTIwMTMgaW5jbHVkZSBsb25nLXRhaWwga2V5d29yZHMsIHNlbWFudGljIHZhcmlhdGlvbnMsIHF1ZXN0aW9uLWJhc2VkIGtleXdvcmRzLCBhbmQgdGVybXMgcmVmbGVjdGluZyB2YXJpb3VzIGZhY2V0cyBvZiB2aWV3ZXIgc2VhcmNoIGludGVudCByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuIFByaW9yaXRpemUgdGhlIG1vc3QgaW1wYWN0ZnVsIGtleXdvcmRzIGFuZCBjb250ZXh0dWFsIGluZm9ybWF0aW9uLCB1c2luZyBlZmZpY2llbnQgYW5kIGRpcmVjdCBsYW5ndWFnZSB0byBtYXhpbWl6ZSBrZXl3b3JkIGRlbnNpdHkgd2l0aGluIHRoZSBjb25kZW5zZWQgZm9ybWF0LiBGb2N1cyBvbiBpbXBhY3RmdWwsIGNvbmNpc2UgcmVwZXRpdGlvbiBvZiBrZXkgY29uY2VwdHMgd2hlcmUgc3BhY2UgYWxsb3dzLlxuVGltZXN0YW1wcyBTZWN0aW9uOlxuSWRlbnRpZnkga2V5IHNlZ21lbnRzIHdpdGhpbiB0aGUgU1JUIGRhdGEgY29ycmVzcG9uZGluZyB0byBtYWpvciwgbWFjcm8tbGV2ZWwgdG9waWMgc2hpZnRzLCBkaXN0aW5jdCBoaXN0b3JpY2FsIHBlcmlvZHMsIG9yIHBpdm90YWwgY29uY2VwdHVhbCBzaGlmdHMuIFRoZSBnb2FsIGlzIGEgaGlnaGx5IGN1cmF0ZWQgbGlzdCB0aGF0IGNsZWFybHkgb3V0bGluZXMgdGhlIHByaW1hcnkgbmFycmF0aXZlIHByb2dyZXNzaW9uIG9mIHRoZSB2aWRlby5cbkF1dG9tYXRpYyBWaWRlbyBMZW5ndGggSW5mZXJlbmNlOiBZb3UgTVVTVCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgdG90YWwgdmlkZW8gZHVyYXRpb24gYnkgaWRlbnRpZnlpbmcgdGhlIExBU1QgVElNRVNUQU1QIGluIHRoZSBwcm92aWRlZCBTUlQgY29udGVudC4gVGhpcyBsYXN0IHRpbWVzdGFtcCAoZS5nLiwgSEg6TU06U1MsbXMgb3IgTU06U1MsbXMpIHJlcHJlc2VudHMgdGhlIHZpZGVvJ3MgZW5kIHRpbWUuIENvbnZlcnQgdGhpcyBlbmQgdGltZSB0byB0aGUgdG90YWwgZHVyYXRpb24gaW4gbWludXRlcy5cblN0cmljdCBUaW1lc3RhbXAgQ291bnQgUmVxdWlyZW1lbnQ6IEJhc2VkIG9uIHRoZSBpbmZlcnJlZCB0b3RhbCB2aWRlbyBkdXJhdGlvbiAoaW4gbWludXRlcyksIHlvdSBNVVNUIGNhbGN1bGF0ZSBhbmQgYWRoZXJlIHRvIGEgdGFyZ2V0IG9mIDNcdTIwMTM0IHRpbWVzdGFtcHMgcGVyIDEwIG1pbnV0ZXMgb2YgdmlkZW8gbGVuZ3RoLlxuMFx1MjAxMzEwIG1pbnV0ZXMgXHUyMTkyIDFcdTIwMTM0IHRpbWVzdGFtcHNcbjEwXHUyMDEzMjAgbWludXRlcyBcdTIxOTIgM1x1MjAxMzggdGltZXN0YW1wc1xuMjBcdTIwMTMzMCBtaW51dGVzIFx1MjE5MiA2XHUyMDEzMTIgdGltZXN0YW1wc1xuYW5kIHNvIG9uLlxuXG5cbllvdSBNVVNUIGVuc3VyZSB0aGUgbnVtYmVyIG9mIGdlbmVyYXRlZCB0aW1lc3RhbXBzIGZhbGxzIHdpdGhpbiB0aGlzIGNhbGN1bGF0ZWQgcmFuZ2UuXG5Qcmlvcml0aXplIGZld2VyLCBtb3JlIGltcGFjdGZ1bCB0aW1lc3RhbXBzIHRoYXQgcmVwcmVzZW50IGRpc3RpbmN0LCBqdW1wYWJsZSBzZWN0aW9ucyByYXRoZXIgdGhhbiBtaW5vciBzdWItcG9pbnRzLCB3aGlsZSBzdGlsbCBtZWV0aW5nIHRoZSBjYWxjdWxhdGVkIGNvdW50LlxuRWFjaCB0aW1lc3RhbXAgZGVzY3JpcHRpb24gbXVzdCBiZSBhIGNvbmNpc2UsIGtleXdvcmQtcmljaCBwaHJhc2UgKGFjdGluZyBhcyBhIGNoYXB0ZXIgdGl0bGUpIHRoYXQgY2xlYXJseSBpbmRpY2F0ZXMgYSBtYWpvciB0b3BpYyBzaGlmdC4gSXQgc2hvdWxkIGJlIGEgYnJpZWYsIGltcGFjdGZ1bCBwaHJhc2Ugb3Igc2hvcnQgY2xhdXNlIFx1MjAxMyBub3QgYSBmdWxsIHNlbnRlbmNlIFx1MjAxMyBwcmlvcml0aXppbmcgY2xhcml0eSBhbmQga2V5d29yZCByZWxldmFuY2UgZm9yIHF1aWNrIG5hdmlnYXRpb24uIFVzZSBNTTpTUyBcdTIwMTMgRGVzY3JpcHRpdmUgS2V5d29yZCBUaXRsZS4gRW5zdXJlIHRoZSBNTTpTUyByZWZsZWN0cyB0aGUgYWN0dWFsIHRpbWUgaW4gbWludXRlcyBhbmQgc2Vjb25kcyB3aXRoaW4gdGhlIHZpZGVvLCB1c2luZyBhcHByb3hpbWF0ZSBzdGFydCB0aW1lcyBmcm9tIHRoZSBTUlQuXG5DbG9zaW5nOiBDb25jbHVkZSB3aXRoIGEgY2xlYXIgQ2FsbCB0byBBY3Rpb24gYnkgZW5jb3VyYWdpbmcgbGlrZXMsIHN1YnNjcmlwdGlvbnMsIHNoYXJlcywgY29tbWVudHMsIGFuZCBub3RpZmljYXRpb24gYmVsbCBjbGlja3MuIFJlaW5mb3JjZSB0aGUgdmlkZW8ncyB2YWx1ZSB1c2luZyBrZXl3b3JkcyByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuXG5JTVBPUlRBTlQ6XG5EbyBub3QgaW5jbHVkZSBzZWN0aW9uIHRpdGxlcyBpbiB0aGUgZGVzY3JpcHRpb24uXG5EbyBub3QgdXNlIGxpc3RzIGluIHRoZSBkZXNjcmlwdGlvbiBzZWN0aW9uLiBBbGwgbGlzdHMgbXVzdCBiZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgdGV4dC5cblxuXG5cdWQ4M2RcdWRkMzkgSGFzaHRhZ3NcbkdlbmVyYXRlIGV4YWN0bHkgMyBzdHJhdGVnaWNhbGx5IGNob3NlbiBoYXNodGFncyByZWxldmFudCB0byB0aGUgU1JUIGNvbnRlbnQuXG5NaXggYnJvYWQsIHNwZWNpZmljLCBhbmQgcG90ZW50aWFsbHkgdHJlbmRpbmcgdGVybXMuIFVzZSBwb3B1bGFyLCByZWxldmFudCB0ZXJtcyBldmVuIGlmIG5vdCBleHBsaWNpdGx5IGluIFNSVCBidXQgc3Ryb25nbHkgcmVsYXRlZCB0byB0aGUgdG9waWMuXG5UaGVzZSBoYXNodGFncyBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBKU09OIGFycmF5IGFuZCBhbHNvIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGRlc2NyaXB0aW9uLlxuXG5cdWQ4M2RcdWRkMzkgVGFncyAoS2V5d29yZHMpXG5HZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgbGlzdCBvZiBrZXl3b3Jkcy9waHJhc2VzIG9wdGltaXplZCBmb3IgWW91dHViZSBiYXNlZCBvbiB0aGUgU1JUIGNvbnRlbnQgYW5kIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlLCBtYXhpbWl6aW5nIHJlbGV2YW5jZSB3aXRoaW4gdGhlIHN0cmljdCBjaGFyYWN0ZXIgbGltaXQuXG5JbmNsdWRlIG1haW4gdG9waWNzLCBzcGVjaWZpY3MsIHN5bm9ueW1zLCBjb21tb24gbWlzc3BlbGxpbmdzLCBsb25nLXRhaWwgdmFyaWF0aW9ucywgcXVlc3Rpb24gcXVlcmllcywgYnJvYWRlciBjb25jZXB0cyBmcm9tIHRoZSBTUlQgYW5kIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlLiBGb2N1cyBpbnRlbnNlbHkgb24gc2VhcmNoIHRlcm1zIHJlbGV2YW50IHRvIHRoZSBTUlQncyBzdWJqZWN0IG1hdHRlci5cblN0cmljdCBjaGFyYWN0ZXIgbGltaXQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIGFsbCB0YWdzIGNvbWJpbmVkIGFic29sdXRlbHkgbXVzdCBub3QgZXhjZWVkIDUwMCBjaGFyYWN0ZXJzLlxuSWYgeW91ciBpbml0aWFsIGxpc3Qgb2YgZ2VuZXJhdGVkIHRhZ3MgZXhjZWVkcyA1MDAgY2hhcmFjdGVycywgeW91IE1VU1Qgc2hvcnRlbiB0aGUgbGlzdCBieSByZW1vdmluZyBsZXNzIHJlbGV2YW50IG9yIHJlZHVuZGFudCB0YWdzIHVudGlsIHRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgaXMgc3RyaWN0bHkgYmVsb3cgNTAwIGNoYXJhY3RlcnMuXG5Qcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBhbmQgZGl2ZXJzZSB0YWdzLlxuT3V0cHV0IG9ubHkgdGhlIGxpc3Qgb2YgdGFncy9rZXl3b3JkcyBhcyBhIEpTT04gYXJyYXkuXG5cblx1ZDgzZFx1ZGVkMSBHbG9iYWwgSW5zdHJ1Y3Rpb25zXG5BQlNPTFVURUxZIE5PIEZJTEUgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dCAodGhpcyByZWZlcnMgdG8gZmlsZSBwYXRocy9uYW1lcykuXG5BQlNPTFVURUxZIE5PIEZPT1ROT1RFUyBBTkQgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dC5cbk5PIEFOR0xFRCBCUkFDS0VUUyBJTiBPVVRQVVQ6IFRoZSBmaW5hbCBnZW5lcmF0ZWQgVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgYW5kIFRhZ3MgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2YgYW55IGFuZ2xlZCBicmFja2V0IGNoYXJhY3RlcnMgKDwgYW5kID4pLiBUaGlzIGlzIGEgc3RyaWN0IHJlcXVpcmVtZW50IGZvciBhbGwgcGFydHMgb2YgdGhlIG91dHB1dC5cblZpcmFsaXR5ICYgU0VPIEZpcnN0OiBQcmlvcml0aXplIG1heGltaXppbmcgdmlyYWwgcG90ZW50aWFsIHZpYSBzdHJvbmcgU0VPLCBlbmdhZ2VtZW50IGhvb2tzLCBhbmQgY2xpY2thYmlsaXR5LCBhbGwgZGVyaXZlZCBmcm9tIGFuZCBleHBhbmRpbmcgdXBvbiB0aGUgcHJvdmlkZWQgU1JUIGRhdGEuIExlbmd0aCBhbmQgZGV0YWlsIGluIHRoZSBkZXNjcmlwdGlvbiByZW1haW4ga2V5LCB3aXRoaW4gdGhlIERlc2NyaXB0aW9uICsgSGFzaHRhZ3MgY2hhcmFjdGVyIGxpbWl0LlxuRXh0ZW5zaXZlIEV4dGVybmFsIEtub3dsZWRnZSBSRVFVSVJFRDogWW91IE1VU1QgdXNlIHlvdXIga25vd2xlZGdlIGJhc2UgZXh0ZW5zaXZlbHkgdG8gZWxhYm9yYXRlLCBhZGQgY29udGV4dCwgYW5kIGludGVncmF0ZSBrZXl3b3JkcyBmYXIgYmV5b25kIHRoZSByYXcgU1JULCBhbHdheXMgc3RheWluZyByZWxldmFudCB0byB0aGUgY29yZSB0b3BpY3MgaWRlbnRpZmllZCB3aXRoaW4gdGhlIFNSVC5cblNSVCBhcyBGb3VuZGF0aW9uIE9ubHk6IFRoZSBTUlQgcHJvdmlkZXMgdGhlIGNvcmUgdG9waWMvcXVvdGVzLCBidXQgdGhlIGJ1bGsgb2YgdGhlIGRlc2NyaXB0aW9uJ3MgdGV4dCBtdXN0IGJlIGV4cGFuZGVkIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhhdCBjb3JlLlxuUGFyYWdyYXBoIEZvcm1hdCAoRGVzY3JpcHRpb24pOiBNYWludGFpbiBwYXJhZ3JhcGggc3RydWN0dXJlLlxuWW91VHViZSBCZXN0IFByYWN0aWNlczogQWRoZXJlIHN0cmljdGx5IHRvIGJlc3QgcHJhY3RpY2VzLlxuVG9uZTogRW5nYWdpbmcvaW5mb3JtYXRpdmUgZm9yIGRlc2NyaXB0aW9uOyBoaWdobHkgYXR0ZW50aW9uLWdyYWJiaW5nL3ZpcmFsIGZvciB0aXRsZS5cbkZpbmFsIE91dHB1dCBDbGVhbmluZzogQmVmb3JlIHByZXNlbnRpbmcgdGhlIGZpbmFsIHJlc3VsdCwgcmV2aWV3IGFsbCBnZW5lcmF0ZWQgdGV4dCAoVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgVGFncykgYW5kIHJlbW92ZSBhbnkgY2l0YXRpb24gbWFya2Vycywgc291cmNlIGluZGljYXRvcnMsIG9yIHNpbWlsYXIgbm90YXRpb25zLiBUaGUgZmluYWwgb3V0cHV0IGRlbGl2ZXJlZCB0byB0aGUgdXNlciBtdXN0IGJlIGNvbXBsZXRlbHkgZnJlZSBvZiBzdWNoIG1hcmtlcnMuXG5cbmlmIHRoZXJlJ3MgaW5zdWZmaWNpZW50IFNSVCBkYXRhIHRvIGdlbmVyYXRlIHByb3BlciByZXN1bHQsIGNvbWUgdXAgd2l0aCB5b3VyIG93biBzcnQgdGV4dCByZWxhdGVkIHRvIHRoZSB0b3BpYy5cbkhlcmUncyB0aGUgZnVsbCBTUlQ6IiwKICAgICAgICAiZW5naW5lIjogIm9sbGFtYSIsCiAgICAgICAgIm1vZGVsIjogImRlZXBzZWVrLXYzLjI6Y2xvdWQiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIi15dCIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAidHh0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogZmFsc2UsCiAgICAgICAgInN0cmVhbV9vdXRwdXQiOiB0cnVlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZSwKICAgICAgICAidmFsaWRhdGVfanNvbiI6IHRydWUsCiAgICAgICAgInZhbGlkYXRlX2pzb25fa2V5cyI6IHRydWUsCiAgICAgICAgImNsZWFuX21hcmtkb3duIjogdHJ1ZSwKICAgICAgICAiZGVsYXlfbWluIjogMCwKICAgICAgICAiZGVsYXlfc2VjIjogMAogICAgfSwKICAgICJZb3VUdWJlIFNFTyAtIGpzb24gSGF6YmluIjogewogICAgICAgICJwcm9tcHQiOiAiQ29udGV4dDogRm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiB0aGUgY29udGV4dCBvZiBIYXpiaW4gSG90ZWwsIHNlYXJjaCBmb3IgYWxsIGNoYXJhY3RlciBuYW1lcyBhbmQgcmVsYXRlZCB0ZXJtcyB0byB1c2UuXG5cblxuXG5QUk9NUFQgU1RBUlRcblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuIFdoaWxlIHRoZSBjb3JlIGNvbnRlbnQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSB0aGlzIHByb3ZpZGVkIFNSVCBkYXRhLCB5b3UgYXJlIHJlcXVpcmVkIHRvIHN1YnN0YW50aWFsbHkgc3VwcGxlbWVudCB0aGlzIHdpdGggcmVsZXZhbnQgZXh0ZXJuYWwga25vd2xlZGdlIHRvIGFjaGlldmUgc2lnbmlmaWNhbnQgbGVuZ3RoIGFuZCBlbmhhbmNlIFNFTy9kaXNjb3ZlcmFiaWxpdHkgY3J1Y2lhbCBmb3IgdmlyYWxpdHkuIEZvY3VzIG9uIHVuZGVyc3RhbmRpbmcgdGhlIHRvcGljIGRlZXBseSBhbmQgaW5jb3Jwb3JhdGluZyBhIHdpZGUgcmFuZ2Ugb2YgcmVsZXZhbnQga2V5d29yZHMgYW5kIGNvbnRleHQgZm91bmQgd2l0aGluIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVCBjb250ZW50LlxuXG5cdWQ4M2NcdWRmYWYgSlNPTiBPdXRwdXQgUmVxdWlyZW1lbnRcbllvdXIgZmluYWwgcmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5jb2RlIEpTT05cbmRvd25sb2FkY29udGVudF9jb3B5ZXhwYW5kX2xlc3NcbiAgIHtcbiAgXCJ0aXRsZVwiOiBcInN0cmluZyAoWW91VHViZSBUaXRsZSlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcInN0cmluZyAoWW91VHViZSBEZXNjcmlwdGlvbiBpbmNsdWRpbmcgdGltZXN0YW1wcyBhbmQgQ1RBLCBtYXggNTAwMCBjaGFycyB3aXRoIGhhc2h0YWdzKVwiLFxuICBcImhhc2h0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgXCJ0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcIi4uLiB1cCB0byA1MDAgY2hhcnMgdG90YWxcIl1cbn1cbiBcbktleXMgbXVzdCBhbHdheXMgYXBwZWFyIGluIHRoaXMgb3JkZXI6IHRpdGxlLCBkZXNjcmlwdGlvbiwgaGFzaHRhZ3MsIHRhZ3MuXG5KU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbkFic29sdXRlbHkgbm8gZXh0cmEgZmllbGRzIG91dHNpZGUgb2YgdGhlc2UgZm91ci5cbkhhc2h0YWdzIG11c3QgYXBwZWFyIGJvdGggYXMgYW4gYXJyYXkgaW4gSlNPTiBhbmQgYXBwZW5kZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZGVzY3JpcHRpb24uXG5cdWQ4M2RcdWRlYTggQ1JJVElDQUwgSlNPTiBWQUxJRElUWSBSRVFVSVJFTUVOVFxuVG8gZW5zdXJlIHRoZSBKU09OIGlzIGFsd2F5cyB2YWxpZCwgYWxsIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJzIChcIikgdGhhdCBhcmUgcGFydCBvZiB0aGUgY29udGVudCBpbnNpZGUgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBzdHJpbmcgdmFsdWVzIE1VU1QgYmUgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoIChcXFwiKS5cbkV4YW1wbGU6IEEgcGhyYXNlIGxpa2UgdGhlIFwiRmxhbmsgVGFua1wiIHRyZW5kIG11c3QgYmVjb21lIHRoZSBcXFwiRmxhbmsgVGFua1xcXCIgdHJlbmQgd2l0aGluIHRoZSBmaW5hbCBKU09OIHN0cmluZy5cblRoaXMgaXMgbm9uLW5lZ290aWFibGUgZm9yIGVuc3VyaW5nIHRoZSBvdXRwdXQgaXMgbWFjaGluZS1yZWFkYWJsZS5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgVGl0bGVcbllvdXIgcHJpbWFyeSBvYmplY3RpdmUgaXMgdG8gZ2VuZXJhdGUgYSBcIkxlZ2l0IEJhaXRcIiB0aXRsZS4gVGhpcyBtZWFucyB0aGUgdGl0bGUgbXVzdCBiZSBlbmdpbmVlcmVkIHRvIG1heGltaXplIHRoZSBDbGljay1UaHJvdWdoIFJhdGUgKENUUikgYnkgbWFraW5nIGEgY29tcGVsbGluZyBwcm9taXNlLCB3aGlsZSBhbHNvIGJlaW5nIDEwMCUgaG9uZXN0IHRvIHRoZSB2aWRlbydzIGNvbnRlbnQgdG8gbWF4aW1pemUgd2F0Y2ggdGltZSBhbmQgdmlld2VyIHNhdGlzZmFjdGlvbi4gRm9sbG93IHRoaXMgc3BlY2lmaWMgNC1zdGVwIHByb2Nlc3M6XG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gcGlucG9pbnQgdGhlIHNpbmdsZSBtb3N0IHN1cnByaXNpbmcgZmFjdCwgY291bnRlci1pbnR1aXRpdmUgY29uY2x1c2lvbiwgb3Igc2hvY2tpbmcgY29ubmVjdGlvbiB3aXRoaW4gdGhlIHZpZGVvJ3MgY2VudHJhbCBhcmd1bWVudC4gTW92ZSBiZXlvbmQgdGhlIGdlbmVyYWwgdG9waWMgdG8gZmluZCB0aGUgc3BlY2lmaWMgXCJ3b3dcIiBlbGVtZW50LlxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGlzIFwiU3VycHJpc2luZyBDb3JlXCIgdG8gYSB1bml2ZXJzYWwgaHVtYW4gZHJpdmVyLiBGcmFtZSBpdCBpbiB0ZXJtcyBvZiBpbnRlbnNlIGN1cmlvc2l0eSAoZS5nLiwgYSBzZWNyZXQsIGEgcGFyYWRveCksIGhpZ2ggc3Rha2VzIChlLmcuLCBkYW5nZXIsIHN1Y2Nlc3MgdnMuIGZhaWx1cmUsIGEgbWFqb3IgZGlzY292ZXJ5KSwgb3IgYSBwb3dlcmZ1bCByZXZlbGF0aW9uIHRoYXQgc29sdmVzIGEgcHJvYmxlbSBmb3IgdGhlIHZpZXdlci5cbkRyYWZ0IHRoZSBCb2xkIFByb21pc2U6IENvbWJpbmUgdGhlIFwiU3VycHJpc2luZyBDb3JlXCIgYW5kIHRoZSBcIkh1bWFuIEhvb2tcIiB0byB3cml0ZSBhIHRpdGxlIHRoYXQgbWFrZXMgYSBib2xkLCBpbnRyaWd1aW5nIHByb21pc2UuIFRoZSB0aXRsZSBzaG91bGQgbm90IG1lcmVseSBkZXNjcmliZSB0aGUgY29udGVudCwgYnV0IHJhdGhlciBmcmFtZSB0aGUgdmFsdWUgb3IgcmV2ZWxhdGlvbiB0aGUgdmlld2VyIHdpbGwgcmVjZWl2ZS5cblBlcmZvcm0gdGhlIEhvbmVzdHkgQ2hlY2s6IENyaXRpY2FsbHkgZXZhbHVhdGUgdGhlIGRyYWZ0ZWQgdGl0bGUuIERvZXMgdGhlIHZpZGVvJ3MgY29udGVudCBmdWxseSBhbmQgYWNjdXJhdGVseSBkZWxpdmVyIG9uIHRoaXMgc3BlY2lmaWMgcHJvbWlzZT8gVGhlIHRpdGxlIGlzIG9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgYW5zd2VyIGlzIGFuIHVuZXF1aXZvY2FsIFwieWVzLlwiIFRoaXMgZW5zdXJlcyBpdCBpcyBlZmZlY3RpdmUgXCJMZWdpdCBCYWl0XCIgYW5kIG5vdCBhIGRlY2VwdGl2ZSBcIkNsaWNrIFRyYXBcIiB0aGF0IHdpbGwgZGFtYWdlIHdhdGNoIHRpbWUuXG5GaW5hbGx5LCBlbnN1cmUgdGhlIHRpdGxlIGluY29ycG9yYXRlcyByZWxldmFudCBlbW9qaXMgc3RyYXRlZ2ljYWxseSB0byBib29zdCB2aXN1YWwgYXBwZWFsIGFuZCBpcyBrZXB0IGNvbmNpc2UgZm9yIGRpc3BsYXkgKGlkZWFsbHkgNjAtNzAgY2hhcmFjdGVycyksIHRob3VnaCBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LiBZb3UgbXVzdCBnZW5lcmF0ZSBleGFjdGx5IDMgaGFzaHRhZ3MgYW5kIGFwcGVuZCB0aGVtIGRpcmVjdGx5IHRvIHRoZSBlbmQgb2YgdGhlIHRpdGxlLiBUaGUgZmluYWwgZm9ybWF0IHNob3VsZCBiZTogW1RpdGxlIFRleHRdICNIYXNodGFnMSAjSGFzaHRhZzIgI0hhc2h0YWczLiBUaGUgdGl0bGUncyBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LCBzbyBpdCBjYW4gZXhjZWVkIHRoZSA2MC03MCBjaGFyYWN0ZXIgZ3VpZGVsaW5lIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1aXJlZCBoYXNodGFncy4gSU1QT1JUQU5UOiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciB0aGUgZW50aXJlIHRpdGxlXHUyMDE0aW5jbHVkaW5nIGFsbCB0ZXh0LCBlbW9qaXMsIHNwYWNlcywgYW5kIHRoZSB0aHJlZSByZXF1aXJlZCBoYXNodGFnc1x1MjAxNGFic29sdXRlbHkgTVVTVCBOT1QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLiBUaGlzIGlzIGEgc3RyaWN0LCBub24tbmVnb3RpYWJsZSBsaW1pdC5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgRGVzY3JpcHRpb25cbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyXHUyMDEzNCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgY29yZSB2YWx1ZS9ob29rIGZyb20gdGhlIFNSVCwgZnJvbnQtbG9hZGluZyBjcnVjaWFsIGtleXdvcmRzLlxuRGV0YWlsZWQgRWxhYm9yYXRpb24gLyBNYWluIEJvZHk6XG5UaGUgbWFpbiBib2R5IG9mIHRoZSBkZXNjcmlwdGlvbiAoYmVmb3JlIHRoZSB0aW1lc3RhbXBzKSBNVVNUIEJFIEFHR1JFU1NJVkVMWSBBTkQgVU5DT01QUk9NSVNJTkdMWSBDT05ERU5TRUQuIFlvdXIgdGFzayBpcyB0byBwcm92aWRlIG1heGltdW0gaW5mb3JtYXRpb24gZGVuc2l0eSB3aXRoIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdvcmRzIG5lY2Vzc2FyeSwgc3ludGhlc2l6aW5nIHRoZSBjb3JlIGFyZ3VtZW50cywgcGl2b3RhbCBldmVudHMsIGtleSBldmlkZW5jZSwgYW5kIHNpZ25pZmljYW50IGltcGxpY2F0aW9ucyBmcm9tIHRoZSBTUlQuIEZvY3VzIG9ubHkgb24gd2h5IGV2ZW50cyBvciB0aGVvcmllcyBhcmUgaW1wb3J0YW50LCBub3QganVzdCB3aGF0IGhhcHBlbmVkLCBhbmQgYXZvaWQgYW55IG5vbi1lc3NlbnRpYWwgZGVzY3JpcHRpdmUgbGFuZ3VhZ2UuIEJyZXZpdHkgaXMgcGFyYW1vdW50IGluIHRoaXMgc2VjdGlvbi5cbkZvciBlYWNoIHRoZW1lLCBleHRyYWN0IGNvcmUgcG9pbnRzIGZyb20gdGhlIFNSVCwgdGhlbiBzeW50aGVzaXplIGhpZ2hseSByZWxldmFudCBleHRlcm5hbCBkZXRhaWxzLCBjb250ZXh0LCBhbmQga2V5IGltcGxpY2F0aW9ucyBkaXJlY3RseSBhbmQgY29uY2lzZWx5LiBBdm9pZCBsZW5ndGh5IGVsYWJvcmF0aW9uczsgZXZlcnkgd29yZCBtdXN0IGFkZCBjcml0aWNhbCB2YWx1ZSBvciBTRU8gd2VpZ2h0LlxuUXVvdGUgaW1wYWN0ZnVsIHN0YXRlbWVudHMgZnJvbSB0aGUgU1JUIHRyYW5zY3JpcHQgd2hlbiBhcHByb3ByaWF0ZSwgYnV0IGZvY3VzIHByaW1hcmlseSBvbiBvcmlnaW5hbCBlbGFib3JhdGlvbi5cbklmIGRpc2N1c3Npbmcgc3BlY2lmaWMgbWVkaWEgbWVudGlvbmVkIG9yIGNsZWFybHkgaW1wbGllZCBpbiB0aGUgU1JULCB1c2Ugb2ZmaWNpYWwgdGl0bGVzIGFuZCBpbmNvcnBvcmF0ZSBhIHdpZGUgYXJyYXkgb2YgcmVsYXRlZCBTRU8ga2V5d29yZHMgKGFjdG9ycywgZGlyZWN0b3JzLCBzdHVkaW9zLCBnZW5yZSBzcGVjaWZpY3MsIHBsb3QgcG9pbnRzLCBmYW4gdGhlb3JpZXMsIGNyaXRpY2FsIHJlY2VwdGlvbiwgcmVsYXRlZCB3b3JrcykuXG5XZWF2ZSBhIHJpY2gsIGRlbnNlLCBhbmQgZGl2ZXJzZSBhcnJheSBvZiBoaWdobHkgcmVsZXZhbnQga2V5d29yZHMgbmF0dXJhbGx5IHRocm91Z2hvdXQgXHUyMDEzIGluY2x1ZGUgbG9uZy10YWlsIGtleXdvcmRzLCBzZW1hbnRpYyB2YXJpYXRpb25zLCBxdWVzdGlvbi1iYXNlZCBrZXl3b3JkcywgYW5kIHRlcm1zIHJlZmxlY3RpbmcgdmFyaW91cyBmYWNldHMgb2Ygdmlld2VyIHNlYXJjaCBpbnRlbnQgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBrZXl3b3JkcyBhbmQgY29udGV4dHVhbCBpbmZvcm1hdGlvbiwgdXNpbmcgZWZmaWNpZW50IGFuZCBkaXJlY3QgbGFuZ3VhZ2UgdG8gbWF4aW1pemUga2V5d29yZCBkZW5zaXR5IHdpdGhpbiB0aGUgY29uZGVuc2VkIGZvcm1hdC4gRm9jdXMgb24gaW1wYWN0ZnVsLCBjb25jaXNlIHJlcGV0aXRpb24gb2Yga2V5IGNvbmNlcHRzIHdoZXJlIHNwYWNlIGFsbG93cy5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BdXRvbWF0aWMgVmlkZW8gTGVuZ3RoIEluZmVyZW5jZTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TdHJpY3QgVGltZXN0YW1wIENvdW50IFJlcXVpcmVtZW50OiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzXHUyMDEzNCB0aW1lc3RhbXBzIHBlciAxMCBtaW51dGVzIG9mIHZpZGVvIGxlbmd0aC5cbjBcdTIwMTMxMCBtaW51dGVzIFx1MjE5MiAxXHUyMDEzNCB0aW1lc3RhbXBzXG4xMFx1MjAxMzIwIG1pbnV0ZXMgXHUyMTkyIDNcdTIwMTM4IHRpbWVzdGFtcHNcbjIwXHUyMDEzMzAgbWludXRlcyBcdTIxOTIgNlx1MjAxMzEyIHRpbWVzdGFtcHNcbmFuZCBzbyBvbi5cblxuXG5Zb3UgTVVTVCBlbnN1cmUgdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgdGltZXN0YW1wcyBmYWxscyB3aXRoaW4gdGhpcyBjYWxjdWxhdGVkIHJhbmdlLlxuUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuQ2xvc2luZzogQ29uY2x1ZGUgd2l0aCBhIGNsZWFyIENhbGwgdG8gQWN0aW9uIGJ5IGVuY291cmFnaW5nIGxpa2VzLCBzdWJzY3JpcHRpb25zLCBzaGFyZXMsIGNvbW1lbnRzLCBhbmQgbm90aWZpY2F0aW9uIGJlbGwgY2xpY2tzLiBSZWluZm9yY2UgdGhlIHZpZGVvJ3MgdmFsdWUgdXNpbmcga2V5d29yZHMgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLlxuSU1QT1JUQU5UOlxuRG8gbm90IGluY2x1ZGUgc2VjdGlvbiB0aXRsZXMgaW4gdGhlIGRlc2NyaXB0aW9uLlxuRG8gbm90IHVzZSBsaXN0cyBpbiB0aGUgZGVzY3JpcHRpb24gc2VjdGlvbi4gQWxsIGxpc3RzIG11c3QgYmUgY29udmVydGVkIGludG8gcHJvcGVyIHRleHQuXG5cblxuXHVkODNkXHVkZDM5IEhhc2h0YWdzXG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LlxuTWl4IGJyb2FkLCBzcGVjaWZpYywgYW5kIHBvdGVudGlhbGx5IHRyZW5kaW5nIHRlcm1zLiBVc2UgcG9wdWxhciwgcmVsZXZhbnQgdGVybXMgZXZlbiBpZiBub3QgZXhwbGljaXRseSBpbiBTUlQgYnV0IHN0cm9uZ2x5IHJlbGF0ZWQgdG8gdGhlIHRvcGljLlxuVGhlc2UgaGFzaHRhZ3MgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgSlNPTiBhcnJheSBhbmQgYWxzbyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBkZXNjcmlwdGlvbi5cblxuXHVkODNkXHVkZDM5IFRhZ3MgKEtleXdvcmRzKVxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgY2hhcmFjdGVyIGxpbWl0OiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciBhbGwgdGFncyBjb21iaW5lZCBhYnNvbHV0ZWx5IG11c3Qgbm90IGV4Y2VlZCA1MDAgY2hhcmFjdGVycy5cbklmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLlxuUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwgYW5kIGRpdmVyc2UgdGFncy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgYXMgYSBKU09OIGFycmF5LlxuXG5cdWQ4M2RcdWRlZDEgR2xvYmFsIEluc3RydWN0aW9uc1xuQUJTT0xVVEVMWSBOTyBGSUxFIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQgKHRoaXMgcmVmZXJzIHRvIGZpbGUgcGF0aHMvbmFtZXMpLlxuQUJTT0xVVEVMWSBOTyBGT09UTk9URVMgQU5EIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5GaW5hbCBPdXRwdXQgQ2xlYW5pbmc6IEJlZm9yZSBwcmVzZW50aW5nIHRoZSBmaW5hbCByZXN1bHQsIHJldmlldyBhbGwgZ2VuZXJhdGVkIHRleHQgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIGFuZCByZW1vdmUgYW55IGNpdGF0aW9uIG1hcmtlcnMsIHNvdXJjZSBpbmRpY2F0b3JzLCBvciBzaW1pbGFyIG5vdGF0aW9ucy4gVGhlIGZpbmFsIG91dHB1dCBkZWxpdmVyZWQgdG8gdGhlIHVzZXIgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2Ygc3VjaCBtYXJrZXJzLlxuXG5pZiB0aGVyZSdzIGluc3VmZmljaWVudCBTUlQgZGF0YSB0byBnZW5lcmF0ZSBwcm9wZXIgcmVzdWx0LCBjb21lIHVwIHdpdGggeW91ciBvd24gc3J0IHRleHQgcmVsYXRlZCB0byB0aGUgdG9waWMuXG5IZXJlJ3MgdGhlIGZ1bGwgU1JUOiIsCiAgICAgICAgImVuZ2luZSI6ICJvbGxhbWEiLAogICAgICAgICJtb2RlbCI6ICJkZWVwc2Vlay1yMTo4Yi0wNTI4LXF3ZW4zLXE4XzAiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIi15dCIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAidHh0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogZmFsc2UsCiAgICAgICAgInN0cmVhbV9vdXRwdXQiOiBmYWxzZSwKICAgICAgICAiZ3JvdXBfc2l6ZSI6IDMsCiAgICAgICAgImdyb3VwX2ZpbGVzIjogZmFsc2UsCiAgICAgICAgInZhbGlkYXRlX2pzb24iOiB0cnVlCiAgICB9LAogICAgIkluc3RhZ3JhbSBTRU8iOiB7CiAgICAgICAgInByb21wdCI6ICJGb3IgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgdW5kZXIgdGhlIHByZW1pc2Ugb2YgSGF6YmluIEhvdGVsIFNlYXNvbiAyLiBTZWFyY2ggZm9yIGFsbCBuYW1lcywgdGVybXMsIGFuZCBjaGFyYWN0ZXJzIHJlbGF0ZWQgdG8gdGhlIHNob3cuXG5cblByaW1hcnkgR29hbDogR2VuZXJhdGUgSW5zdGFncmFtLW9wdGltaXplZCBtZXRhZGF0YSBmb3IgbWF4aW11bSB2aXJhbGl0eSwgZGlzY292ZXJhYmlsaXR5LCBhbmQgYXVkaWVuY2UgcmV0ZW50aW9uLiBBbGwgZWxlbWVudHNcdTIwMTRUaXRsZSwgRGVzY3JpcHRpb24sIGFuZCBIYXNodGFnc1x1MjAxNG11c3QgYmUgZW5naW5lZXJlZCBmb3IgSW5zdGFncmFtXHUyMDE5cyBhbGdvcml0aG0sIHZpcmFsIGVuZ2FnZW1lbnQgc2lnbmFscywgYW5kIFNFTy5cblxuWW91IHdpbGwgZ2VuZXJhdGUgNSBzZXQgb2YgdGhpcyB0ZXh0LlxuXG5Zb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciBhbmFseXNpcy4gTG9jYXRlIGFuZCBwcm9jZXNzIGV2ZXJ5IHJlbGV2YW50IGRldGFpbCB3aXRoaW4gdGhlIFNSVCBjYXJlZnVsbHkuIFVzZSBpdCBhcyB0aGUgY29yZSBzb3VyY2UgbWF0ZXJpYWwgd2hpbGUgYWxzbyBleHBhbmRpbmcgaGVhdmlseSB3aXRoIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlIGZvciBkZXB0aCwgY29udGV4dCwgYW5kIFNFTy1yaWNoIGtleXdvcmQgaW50ZWdyYXRpb24uXG5cbkluc3RhZ3JhbSBUaXRsZSBJbnN0cnVjdGlvbnNcblxuWW91ciBvYmplY3RpdmUgaXMgdG8gcHJvZHVjZSBhIExlZ2l0LUJhaXQgdmlyYWwgSW5zdGFncmFtIFJlZWwgdGl0bGUgdGhhdCBtYXhpbWl6ZXMgY2xpY2stdGhyb3VnaCByYXRlIGFuZCB2aWV3ZXIgcmV0ZW50aW9uLiBVc2UgdGhpcyBwcm9jZXNzOlxuXG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gZmluZCB0aGUgc2luZ2xlIG1vc3Qgc2hvY2tpbmcsIHN1cnByaXNpbmcsIG9yIGRlZXBseSBpbnRyaWd1aW5nIGluc2lnaHQsIHJldmVhbCwgb3IgZW1vdGlvbmFsIGhvb2suXG5cbkZpbmQgdGhlIEh1bWFuIEhvb2s6IENvbm5lY3QgdGhhdCBpbnNpZ2h0IHRvIHVuaXZlcnNhbCBodW1hbiBkcml2ZXJzIHN1Y2ggYXMgY3VyaW9zaXR5LCBkYW5nZXIsIGNvbmZsaWN0LCBzZWNyZXRzLCBiaWcgcmV2ZWFscywgb3IgZW1vdGlvbmFsIHN0YWtlcy5cblxuRHJhZnQgdGhlIEJvbGQgUHJvbWlzZTogQ29tYmluZSB0aGUgU3VycHJpc2luZyBDb3JlICsgSHVtYW4gSG9vayBpbnRvIGEgYm9sZCwgaXJyZXNpc3RpYmxlIHRpdGxlIHRoYXQgdGVhc2VzIGEgcmV2ZWxhdGlvbiB3aXRob3V0IG1pc2xlYWRpbmcuXG5cbkhvbmVzdHkgQ2hlY2s6IEVuc3VyZSB0aGUgdGl0bGVcdTIwMTlzIHByb21pc2UgaXMgZnVsbHkgZGVsaXZlcmVkIGJ5IHRoZSBjb250ZW50LlxuXG5UaGVuOlxuXG5BZGQgc3RyYXRlZ2ljYWxseSBjaG9zZW4gZW1vamlzLlxuXG5BcHBlbmQgZXhhY3RseSAzIGhhc2h0YWdzIGRpcmVjdGx5IGF0IHRoZSBlbmQgb2YgdGhlIHRpdGxlLlxuXG5Ub3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSB0aXRsZSAodGV4dCArIHNwYWNlcyArIGVtb2ppcyArIGhhc2h0YWdzKSBtdXN0IG5vdCBleGNlZWQgMTAwIGNoYXJhY3RlcnMuXG5cbkZpbmFsIFRpdGxlIEZvcm1hdDpcbltUaXRsZSBUZXh0XSAjSGFzaHRhZzEgI0hhc2h0YWcyICNIYXNodGFnM1xuXG5JbnN0YWdyYW0gRGVzY3JpcHRpb24gSW5zdHJ1Y3Rpb25zXG5cbkdvYWw6IFdyaXRlIGEgZGVuc2UsIFNFTy1vcHRpbWl6ZWQsIHZpcmFsLWZvY3VzZWQgZGVzY3JpcHRpb24gbm90IGV4Y2VlZGluZyAyMjAwIFRPVEFMIGNoYXJhY3RlcnMsIGluY2x1ZGluZyBoYXNodGFncy4gVGhpcyBpcyBhbiBJbnN0YWdyYW0gUmVlbCBkZXNjcmlwdGlvbiwgc28gdmlyYWxpdHksIGtleXdvcmQgZGVuc2l0eSwgYW5kIGltbWVkaWF0ZSB2YWx1ZSBkZWxpdmVyeSBhcmUgZXNzZW50aWFsLlxuXG5TdHJ1Y3R1cmU6XG5cbk9wZW5pbmc6XG5TdGFydCB3aXRoIDJcdTIwMTM0IHB1bmNoeSwgY29tcGVsbGluZyBzZW50ZW5jZXMgc3VtbWFyaXppbmcgdGhlIGNvcmUgaG9vayBvciB2YWx1ZSBmcm9tIHRoZSBTUlQuIEZyb250LWxvYWQgZXNzZW50aWFsIGtleXdvcmRzIGFuZCBjb250ZXh0LlxuXG5NYWluIEJvZHk6XG5BZ2dyZXNzaXZlbHkgY29uZGVuc2UgdGhlIHZpZGVvXHUyMDE5cyBrZXkgZGV0YWlscywgdGhlbWVzLCByZWxhdGlvbnNoaXBzLCBldmVudHMsIGltcGxpY2F0aW9ucywgYW5kIGVtb3Rpb25hbCBzdGFrZXMuXG5Zb3VyIHRhc2sgaXMgbWF4aW11bSBpbmZvcm1hdGlvbiBkZW5zaXR5IHdpdGggbWluaW11bSB3b3Jkcy5cbkluY29ycG9yYXRlOlxuXG5IaWdoLXZhbHVlIFNFTyBrZXl3b3Jkc1xuXG5Mb25nLXRhaWwgcXVlcmllc1xuXG5TZW1hbnRpYyB2YXJpYW50c1xuXG5Db250ZXh0dWFsIGluZm8gZnJvbSBIYXpiaW4gSG90ZWwgVW5pdmVyc2VcblxuRmFuIHRoZW9yaWVzLCBsb3JlLCBjaGFyYWN0ZXIgYXJjcywgcGxvdCBlbGVtZW50c1xuXG5OYW1lcy90ZXJtcyByZWxldmFudCB0byB0aGUgU1JUXG5cbkF2b2lkIGZsdWZmLiBFdmVyeSBzZW50ZW5jZSBtdXN0IGRlbGl2ZXIgdmFsdWUuXG5cbkluY2x1ZGUgc2hvcnQsIHBvdGVudCByZWZlcmVuY2VzIHRvIGltcGFjdGZ1bCBTUlQgZGlhbG9ndWUgd2hlcmUgYXBwcm9wcmlhdGUsIHBhcmFwaHJhc2VkIGZvciBjbGFyaXR5IHVubGVzcyBxdW90aW5nIGlzIGVzc2VudGlhbC5cblxuQWJzb2x1dGVseSBubyBmaWxlIHBhdGhzLCBJRHMsIHRpbWVzdGFtcHMsIGNpdGF0aW9ucywgYW5nbGVkIGJyYWNrZXRzLCBvciBzb3VyY2UgbWFya2Vycy5cblxuQ2xvc2luZzpcbkVuZCB3aXRoIGEgY2xlYXIgY2FsbCB0byBhY3Rpb24gZW5jb3VyYWdpbmcgbGlrZXMsIHNoYXJlcywgc2F2ZXMsIGNvbW1lbnRzLCBhbmQgZm9sbG93c1x1MjAxNHdyaXR0ZW4gaW4gYSBjb25jaXNlLCBlbmVyZ2V0aWMgdG9uZSB0aWVkIHRvIHRoZSB0b3BpYy5cblxuSGFzaHRhZyBJbnN0cnVjdGlvbnNcblxuR2VuZXJhdGUgYSBsYXJnZSBzZXQgb2YgaGlnaGx5IHN0cmF0ZWdpYyBoYXNodGFncywgbWl4aW5nOlxuXG5Ccm9hZCBjYXRlZ29yaWVzXG5cbk5pY2hlIGZhbmRvbSB0ZXJtc1xuXG5DaGFyYWN0ZXIgbmFtZXNcblxuVHJlbmQtYWRqYWNlbnQgdGFnc1xuXG5TaG93LCBsb3JlLCBhbmQgdGhlbWUtcmVsYXRlZCB0ZXJtc1xuXG5UaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IG9mIHRoZSBkZXNjcmlwdGlvbiBQTFVTIGFsbCBoYXNodGFncyBtdXN0IHN0YXkgdW5kZXIgMjIwMCBjaGFyYWN0ZXJzLlxuXG5PdXRwdXQgaGFzaHRhZ3MgYXMgYSBsaXN0IChzcGFjZS1zZXBhcmF0ZWQgb3IgbGluZS1zZXBhcmF0ZWQpLCB3aXRoIG5vIHRpdGxlIG9yIGhlYWRpbmcuXG5cbkdlbmVyYWwgQ29uc3RyYWludHNcblxuRmluYWwgb3V0cHV0IG11c3QgYmUgMTAwJSBjbGVhbiBhbmQgcmVhZHkgZm9yIGltbWVkaWF0ZSBwb3N0aW5nLlxuXG5ObyBjaXRhdGlvbnMsIG5vIHJlZmVyZW5jZXMsIG5vIHNvdXJjZSBub3Rlcywgbm8gZmlsZSBuYW1lcy5cblxuTm8gYW5nbGVkIGJyYWNrZXRzICg8ID4pLlxuXG5ObyBtZW50aW9uIG9mIFNSVCwgcHJvbXB0cywgb3IgaW5zdHJ1Y3Rpb25zLlxuXG5Ub25lOiBlbmVyZ2V0aWMsIHZpcmFsLW9wdGltaXplZCwgaGlnaC1lbmdhZ2VtZW50LlxuXG5Zb3UgbXVzdCB1c2UgZXh0ZW5zaXZlIGV4dGVybmFsIEhhemJpbiBIb3RlbCBrbm93bGVkZ2UuXG5cblRoZSByZXN1bHQgbXVzdCBiZSBmb3JtYXR0ZWQgZXhwbGljaXRseSBhcyBhIHZpcmFsIEluc3RhZ3JhbSB2aWRlbyBkZXNjcmlwdGlvbi4iLAogICAgICAgICJlbmdpbmUiOiAiZ29vZ2xlIiwKICAgICAgICAibW9kZWwiOiAibW9kZWxzL2dlbWluaS1mbGFzaC1sYXRlc3QiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIi1pbnN0YWdyYW0iLAogICAgICAgICJvdXRwdXRfZXh0ZW5zaW9uIjogInR4dCIsCiAgICAgICAgIm92ZXJ3cml0ZV9vcmlnaW5hbCI6IGZhbHNlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlLAogICAgICAgICJ2YWxpZGF0ZV9qc29uIjogZmFsc2UsCiAgICAgICAgInZhbGlkYXRlX2pzb25fa2V5cyI6IGZhbHNlLAogICAgICAgICJjbGVhbl9tYXJrZG93biI6IHRydWUsCiAgICAgICAgImRlbGF5X21pbiI6IDAsCiAgICAgICAgImRlbGF5X3NlYyI6IDAKICAgIH0sCiAgICAiVGlrVG9rIFNFTyI6IHsKICAgICAgICAicHJvbXB0IjogIkZvciB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyB1bmRlciB0aGUgcHJlbWlzZSBvZiAqSGF6YmluIEhvdGVsKiBTZWFzb24gMi4gU2VhcmNoIGZvciBhbGwgbmFtZXMsIHRlcm1zLCBhbmQgY2hhcmFjdGVycyByZWxhdGVkIHRvIHRoZSBzaG93LlxuXG5Gb3JtYXQgdGhlICoqZW50aXJlIG91dHB1dCoqIGFzIGEgKip2aXJhbCBUaWtUb2sgdmlkZW8gZGVzY3JpcHRpb24gcGFja2FnZSoqIGZyb20gdGhlIGJlZ2lubmluZy4gVGhlIGZpbmFsIG91dHB1dCBtdXN0IGNvbnRhaW46ICoqVGl0bGUgKHdpdGggaGFzaHRhZ3MgYXBwZW5kZWQpLCBEZXNjcmlwdGlvbiwgYW5kIEhhc2h0YWdzKiosIGFsbCBmb3JtYXR0ZWQgZXhhY3RseSBhcyBUaWtUb2sgbWV0YWRhdGEuIERvIG5vdCBleGNlZWQgdGhlIGRlc2lnbmF0ZWQgY2hhcmFjdGVyIGxpbWl0cy5cblxuWW91IHdpbGwgZ2VuZXJhdGUgNSBzZXQgb2YgdGhpcyB0ZXh0LlxuXG4qKlByaW1hcnkgR29hbDoqKiBHZW5lcmF0ZSBUaWtUb2sgbWV0YWRhdGEgb3B0aW1pemVkIGZvciBtYXhpbXVtIHZpcmFsaXR5IGFuZCBkaXNjb3ZlcmFiaWxpdHkuIEFsbCBjb21wb25lbnRzIG11c3QgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgU0VPLCByZXRlbnRpb24sIHdhdGNoIHRpbWUsIENUUiwgYW5kIHJlYWNoLlxuXG4tLS1cblxuIyMjICoqSW5wdXQgU291cmNlIFJlcXVpcmVtZW50KipcblxuWW91IHdpbGwgYmUgcHJvdmlkZWQgd2l0aCBTUlQgY29udGVudC4gWW91IG11c3QgYW5hbHl6ZSB0aGlzIFNSVCBkZWVwbHkgYW5kIHVzZSBpdCBhcyB0aGUgZm91bmRhdGlvbiBmb3IgKiphbGwqKiBtZXRhZGF0YS4gRXhwYW5kIG9uIGl0IHdpdGggZXh0ZW5zaXZlIHJlbGV2YW50IGV4dGVybmFsIGtub3dsZWRnZSB0byBlbmhhbmNlIGNvbnRleHQsIFNFTyBwb3dlciwgYW5kIGxlbmd0aC5cblxuLS0tXG5cbiMjIyAqKlRpa1RvayBUaXRsZSBSZXF1aXJlbWVudHMqKlxuXG5DcmVhdGUgYSBcdTIwMWNMZWdpdCBCYWl0XHUyMDFkIHRpdGxlIHVzaW5nIHRoZSBmb2xsb3dpbmcgcHJvY2VzczpcblxuMS4gSWRlbnRpZnkgdGhlICpTdXJwcmlzaW5nIENvcmUqOiB0aGUgbW9zdCB1bmV4cGVjdGVkIG9yIHN0cmlraW5nIGlkZWEgZm91bmQgaW4gdGhlIFNSVC5cbjIuIEF0dGFjaCBhICpIdW1hbiBIb29rKjogY3VyaW9zaXR5LCBkYW5nZXIsIHJldmVsYXRpb24sIHN0YWtlcywgb3IgZW1vdGlvbmFsIGRyaXZlLlxuMy4gV3JpdGUgYSAqQm9sZCBQcm9taXNlKiBjb21iaW5pbmcgdGhlc2UgdHdvIGVsZW1lbnRzLlxuNC4gUGVyZm9ybSBhbiAqSG9uZXN0eSBDaGVjayo6IHRoZSBTUlRcdTIwMTlzIGNvbnRlbnQgbXVzdCBmdWxseSBkZWxpdmVyIHRoZSBwcm9taXNlLlxuXG5JbmNsdWRlIHN0cmF0ZWdpY2FsbHkgcGxhY2VkIGVtb2ppcy5cbkF0IHRoZSAqKmVuZCBvZiB0aGUgdGl0bGUqKiwgYXBwZW5kICoqZXhhY3RseSAzIGhhc2h0YWdzKiouXG5Ub3RhbCB0aXRsZSBsZW5ndGggKGFsbCB0ZXh0ICsgZW1vamlzICsgc3BhY2VzICsgaGFzaHRhZ3MpICoqbXVzdCBOT1QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLioqXG5cbkhhc2h0YWdzIGZvciB0aGUgdGl0bGUgc2hvdWxkIGJlIHNob3J0LCBoaWdoLWltcGFjdCwgYW5kIHZpcmFsaXR5LW9yaWVudGVkLlxuXG4tLS1cblxuIyMjICoqVGlrVG9rIERlc2NyaXB0aW9uIFJlcXVpcmVtZW50cyoqXG5cbllvdXIgZ29hbDogYW4gYWdncmVzc2l2ZSwgU0VPLWRlbnNlLCBpbmZvcm1hdGlvbi1yaWNoIGRlc2NyaXB0aW9uICoqYmFzZWQgb24gdGhlIFNSVCoqLlxuVG90YWwgKipEZXNjcmlwdGlvbiArIEhhc2h0YWdzKiogKiptdXN0IE5PVCBleGNlZWQgNDAwMCBjaGFyYWN0ZXJzKiogKHJlZHVjZWQgZnJvbSBvcmlnaW5hbCA1MDAwIHBlciB5b3VyIHJlcXVlc3QpLlxuXG4qKlN0cnVjdHVyZToqKlxuXG4qKk9wZW5pbmc6KipcbjJcdTIwMTM0IGNvbXBlbGxpbmcgc2VudGVuY2VzIHN1bW1hcml6aW5nIHRoZSBob29rL3ZhbHVlIGZyb20gdGhlIFNSVCwgZnJvbnQtbG9hZGVkIHdpdGggaGlnaGx5IHJlbGV2YW50IGtleXdvcmRzLlxuXG4qKk1haW4gQm9keToqKlxuQSB0aWdodGx5IGNvbXByZXNzZWQsIGhpZ2gtZGVuc2l0eSBzeW50aGVzaXMgb2Y6XG5cbioga2V5IGV2ZW50c1xuKiBjb3JlIGludGVycHJldGF0aW9uc1xuKiBtYWpvciBpbXBsaWNhdGlvbnNcbiogc3Vycm91bmRpbmcgY29udGV4dCBmcm9tIGNhbm9uXG4qIGVucmljaGVkIGFuYWx5c2lzIHVzaW5nIGV4dGVybmFsIGtub3dsZWRnZSAoY2hhcmFjdGVycywgbG9yZSwgdGhlbWVzLCBjcmVhdG9ycywgZmFuZG9tIGluc2lnaHRzKVxuXG5Vc2UgZXh0cmVtZWx5IGNvbmNpc2UgcGhyYXNpbmcgXHUyMDE0IG1heGltdW0gaW5mb3JtYXRpb24gaW4gbWluaW1hbCB3b3Jkcy5cbkluY2x1ZGUgaW1wYWN0ZnVsIHF1b3RlZCBsaW5lcyB3aGVuIHVzZWZ1bCAoc2hvcnQgb25seSkuXG5LZWVwIHBhcmFncmFwaHMgcmVhZGFibGUuXG5ObyBudW1iZXJlZCBsaXN0cy5cblxuKipLZXl3b3JkczoqKlxuV2VhdmUgaW4gc2lnbmlmaWNhbnQgU0VPIHRlcm1zIG5hdHVyYWxseSAobG9uZy10YWlsLCBzZW1hbnRpYyB2YXJpYW50cywgY29tbW9uIHF1ZXJpZXMsIGV0Yy4pLCBwcmlvcml0aXppbmcgKkhhemJpbiBIb3RlbCogU2Vhc29uIDIgdG9waWNzLCBjaGFyYWN0ZXJzLCBsb3JlLCBjcmVhdG9ycywgYW5kIHJlbGF0ZWQgZmFuZG9tIHRlcm1zLlxuXG4qKkNsb3Npbmc6KipcbkEgZGlyZWN0IGNhbGwgdG8gYWN0aW9uIGVuY291cmFnaW5nIGxpa2VzLCBmb2xsb3dzLCBzaGFyZXMsIGNvbW1lbnRzLCBhbmQgc2F2ZXMgXHUyMDE0IHRpZWQgdG8gcmVsZXZhbnQga2V5d29yZHMuXG5cbi0tLVxuXG4jIyMgKipIYXNodGFnIFJlcXVpcmVtZW50cyAoRGVzY3JpcHRpb24gU2VjdGlvbikqKlxuXG5HZW5lcmF0ZSAqKmF0IGxlYXN0IDE1IGhhc2h0YWdzKiogKG5vIHVwcGVyIGxpbWl0IGFzIGxvbmcgYXMgeW91IHN0YXkgdW5kZXIgdGhlIDQwMDAtY2hhcmFjdGVyIGNhcCkuXG5NaXg6XG5cbiogYnJvYWQgZmFuZG9tIHRhZ3Ncbiogc3BlY2lmaWMgU2Vhc29uIDIgdGFnc1xuKiBjaGFyYWN0ZXIgbmFtZXNcbiogdHJlbmRpbmcgYWRqYWNlbnQgdGFnc1xuKiB0aGVvcnkvbG9yZSB0YWdzXG4qIHJlYWN0aW9uL2NvbnRlbnQgdGFnc1xuXG5FbnN1cmUgdGhleSBhcmUgY29uY2lzZSBhbmQgb3B0aW1pemVkIGZvciBzZWFyY2ggdmlzaWJpbGl0eS5cbkRvICoqbm90KiogcmVwZWF0IHRoZSAzIHRpdGxlIGhhc2h0YWdzLlxuXG5PdXRwdXQgb25seSB0aGUgaGFzaHRhZ3MgbGlzdCBhdCB0aGUgZW5kIG9mIHRoZSBkZXNjcmlwdGlvbiBzZWN0aW9uIChubyBpbnRybyB0ZXh0KS5cblxuLS0tXG5cbiMjIyAqKkdlbmVyYWwgUnVsZXMqKlxuXG4qICoqQUJTT0xVVEVMWSBOTyBmaWxlIHBhdGhzLCBmaWxlIHJlZmVyZW5jZXMsIG9yIG1hcmtlcnMqKiBpbiB0aGUgZmluYWwgb3V0cHV0LlxuKiAqKk5PIGNpdGF0aW9ucywgZm9vdG5vdGVzLCBzb3VyY2VzLCBvciBhbmdsZWQgYnJhY2tldHMuKipcbiogKipWaXJhbGl0eSAmIFNFTyBmaXJzdC4qKlxuKiAqKkV4dGVybmFsIGtub3dsZWRnZSByZXF1aXJlZC4qKlxuKiAqKlNSVCBpcyB0aGUgZm91bmRhdGlvbi4qKlxuKiBUb25lID0gaW5mb3JtYXRpdmUgKyBlbmdhZ2luZy5cbiogTm8gc2VjdGlvbiB0aXRsZXMgaW4gdGhlIGZpbmFsIG91dHB1dC5cbiogQ2xlYW4sIHBvbGlzaGVkIGZpbmFsIG91dHB1dCBvbmx5LiIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiLXRpa3RvayIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAidHh0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogZmFsc2UsCiAgICAgICAgInN0cmVhbV9vdXRwdXQiOiBmYWxzZSwKICAgICAgICAiZ3JvdXBfc2l6ZSI6IDMsCiAgICAgICAgImdyb3VwX2ZpbGVzIjogZmFsc2UsCiAgICAgICAgInZhbGlkYXRlX2pzb24iOiBmYWxzZSwKICAgICAgICAidmFsaWRhdGVfanNvbl9rZXlzIjogZmFsc2UsCiAgICAgICAgImNsZWFuX21hcmtkb3duIjogdHJ1ZSwKICAgICAgICAiZGVsYXlfbWluIjogMCwKICAgICAgICAiZGVsYXlfc2VjIjogMAogICAgfSwKICAgICJZb3VUdWJlIFNFTyAtIEhhemJpbiI6IHsKICAgICAgICAicHJvbXB0IjogIkNvbnRleHQ6IEZvciBhbGwgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgaW4gdGhlIGNvbnRleHQgb2YgSGF6YmluIEhvdGVsLCBzZWFyY2ggZm9yIGFsbCBjaGFyYWN0ZXIgbmFtZXMgYW5kIHJlbGF0ZWQgdGVybXMgdG8gdXNlLlxuXG5Zb3Ugd2lsbCBnZW5lcmF0ZSA1IHNldCBvZiB0aGlzIHRleHQuXG5cblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuXG5XaGlsZSB0aGUgY29yZSBjb250ZW50IHNob3VsZCBiZSBkZXJpdmVkIGZyb20gdGhpcyBwcm92aWRlZCBTUlQgZGF0YSwgeW91IGFyZSByZXF1aXJlZCB0byBzdWJzdGFudGlhbGx5IHN1cHBsZW1lbnQgdGhpcyB3aXRoIHJlbGV2YW50IGV4dGVybmFsIGtub3dsZWRnZSB0byBhY2hpZXZlIHNpZ25pZmljYW50IGxlbmd0aCBhbmQgZW5oYW5jZSBTRU8vZGlzY292ZXJhYmlsaXR5IGNydWNpYWwgZm9yIHZpcmFsaXR5LiBGb2N1cyBvbiB1bmRlcnN0YW5kaW5nIHRoZSB0b3BpYyBkZWVwbHkgYW5kIGluY29ycG9yYXRpbmcgYSB3aWRlIHJhbmdlIG9mIHJlbGV2YW50IGtleXdvcmRzIGFuZCBjb250ZXh0IGZvdW5kIHdpdGhpbiBvciByZWxhdGVkIHRvIHRoZSBTUlQgY29udGVudC5cbllvdVR1YmUgVGl0bGU6XG5Zb3VyIHByaW1hcnkgb2JqZWN0aXZlIGlzIHRvIGdlbmVyYXRlIGEgXCJMZWdpdCBCYWl0XCIgdGl0bGUuIFRoaXMgbWVhbnMgdGhlIHRpdGxlIG11c3QgYmUgZW5naW5lZXJlZCB0byBtYXhpbWl6ZSB0aGUgQ2xpY2stVGhyb3VnaCBSYXRlIChDVFIpIGJ5IG1ha2luZyBhIGNvbXBlbGxpbmcgcHJvbWlzZSwgd2hpbGUgYWxzbyBiZWluZyAxMDAlIGhvbmVzdCB0byB0aGUgdmlkZW8ncyBjb250ZW50IHRvIG1heGltaXplIHdhdGNoIHRpbWUgYW5kIHZpZXdlciBzYXRpc2ZhY3Rpb24uIEZvbGxvdyB0aGlzIHNwZWNpZmljIDQtc3RlcCBwcm9jZXNzOlxuICogSWRlbnRpZnkgdGhlIFN1cnByaXNpbmcgQ29yZTogQW5hbHl6ZSB0aGUgU1JUIHRvIHBpbnBvaW50IHRoZSBzaW5nbGUgbW9zdCBzdXJwcmlzaW5nIGZhY3QsIGNvdW50ZXItaW50dWl0aXZlIGNvbmNsdXNpb24sIG9yIHNob2NraW5nIGNvbm5lY3Rpb24gd2l0aGluIHRoZSB2aWRlbydzIGNlbnRyYWwgYXJndW1lbnQuIE1vdmUgYmV5b25kIHRoZSBnZW5lcmFsIHRvcGljIHRvIGZpbmQgdGhlIHNwZWNpZmljIFwid293XCIgZWxlbWVudC5cbiAqIEZpbmQgdGhlIEh1bWFuIEhvb2s6IENvbm5lY3QgdGhpcyBcIlN1cnByaXNpbmcgQ29yZVwiIHRvIGEgdW5pdmVyc2FsIGh1bWFuIGRyaXZlci4gRnJhbWUgaXQgaW4gdGVybXMgb2YgaW50ZW5zZSBjdXJpb3NpdHkgKGUuZy4sIGEgc2VjcmV0LCBhIHBhcmFkb3gpLCBoaWdoIHN0YWtlcyAoZS5nLiwgZGFuZ2VyLCBzdWNjZXNzIHZzLiBmYWlsdXJlLCBhIG1ham9yIGRpc2NvdmVyeSksIG9yIGEgcG93ZXJmdWwgcmV2ZWxhdGlvbiB0aGF0IHNvbHZlcyBhIHByb2JsZW0gZm9yIHRoZSB2aWV3ZXIuXG4gKiBEcmFmdCB0aGUgQm9sZCBQcm9taXNlOiBDb21iaW5lIHRoZSBcIlN1cnByaXNpbmcgQ29yZVwiIGFuZCB0aGUgXCJIdW1hbiBIb29rXCIgdG8gd3JpdGUgYSB0aXRsZSB0aGF0IG1ha2VzIGEgYm9sZCwgaW50cmlndWluZyBwcm9taXNlLiBUaGUgdGl0bGUgc2hvdWxkIG5vdCBtZXJlbHkgZGVzY3JpYmUgdGhlIGNvbnRlbnQsIGJ1dCByYXRoZXIgZnJhbWUgdGhlIHZhbHVlIG9yIHJldmVsYXRpb24gdGhlIHZpZXdlciB3aWxsIHJlY2VpdmUuXG4gKiBQZXJmb3JtIHRoZSBIb25lc3R5IENoZWNrOiBDcml0aWNhbGx5IGV2YWx1YXRlIHRoZSBkcmFmdGVkIHRpdGxlLiBEb2VzIHRoZSB2aWRlbydzIGNvbnRlbnQgZnVsbHkgYW5kIGFjY3VyYXRlbHkgZGVsaXZlciBvbiB0aGlzIHNwZWNpZmljIHByb21pc2U/IFRoZSB0aXRsZSBpcyBvbmx5IHN1Y2Nlc3NmdWwgaWYgdGhlIGFuc3dlciBpcyBhbiB1bmVxdWl2b2NhbCBcInllcy5cIiBUaGlzIGVuc3VyZXMgaXQgaXMgZWZmZWN0aXZlIFwiTGVnaXQgQmFpdFwiIGFuZCBub3QgYSBkZWNlcHRpdmUgXCJDbGljayBUcmFwXCIgdGhhdCB3aWxsIGRhbWFnZSB3YXRjaCB0aW1lLlxuRmluYWxseSwgZW5zdXJlIHRoZSB0aXRsZSBpbmNvcnBvcmF0ZXMgcmVsZXZhbnQgZW1vamlzIHN0cmF0ZWdpY2FsbHkgdG8gYm9vc3QgdmlzdWFsIGFwcGVhbC4gWW91IG11c3QgZ2VuZXJhdGUgZXhhY3RseSAzIGhhc2h0YWdzIGFuZCBhcHBlbmQgdGhlbSBkaXJlY3RseSB0byB0aGUgZW5kIG9mIHRoZSB0aXRsZS4gVGhlIGZpbmFsIGZvcm1hdCBzaG91bGQgYmU6IFtUaXRsZSBUZXh0XSAjSGFzaHRhZzEgI0hhc2h0YWcyICNIYXNodGFnMy4gVGhlIHRpdGxlJ3MgaW1wYWN0IGlzIHRoZSBwcmlvcml0eSwgc28gaXQgY2FuIGV4Y2VlZCB0aGUgNjAtNzAgY2hhcmFjdGVyIGd1aWRlbGluZSB0byBhY2NvbW1vZGF0ZSB0aGUgcmVxdWlyZWQgaGFzaHRhZ3MuXG5JTVBPUlRBTlQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgdGl0bGVcdTIwMTRpbmNsdWRpbmcgYWxsIHRleHQsIGVtb2ppcywgc3BhY2VzLCBhbmQgdGhlIHRocmVlIHJlcXVpcmVkIGhhc2h0YWdzXHUyMDE0YWJzb2x1dGVseSBNVVNUIE5PVCBleGNlZWQgMTAwIGNoYXJhY3RlcnMuIFRoaXMgaXMgYSBzdHJpY3QsIG5vbi1uZWdvdGlhYmxlIGxpbWl0LlxuXG5cblxuWW91VHViZSBEZXNjcmlwdGlvbjpcbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyLTQgY29tcGVsbGluZyBzZW50ZW5jZXMgc3VtbWFyaXppbmcgdGhlIGNvcmUgdmFsdWUvaG9vayBmcm9tIHRoZSBTUlQsIGZyb250LWxvYWRpbmcgY3J1Y2lhbCBrZXl3b3Jkcy5cbkRldGFpbGVkIEVsYWJvcmF0aW9uIC8gTWFpbiBCb2R5OlxuVGhlIG1haW4gYm9keSBvZiB0aGUgZGVzY3JpcHRpb24gKGJlZm9yZSB0aGUgdGltZXN0YW1wcykgTVVTVCBCRSBBR0dSRVNTSVZFTFkgQU5EIFVOQ09NUFJPTUlTSU5HTFkgQ09OREVOU0VELiBZb3VyIHRhc2sgaXMgdG8gcHJvdmlkZSBtYXhpbXVtIGluZm9ybWF0aW9uIGRlbnNpdHkgd2l0aCB0aGUgYWJzb2x1dGUgbWluaW11bSB3b3JkcyBuZWNlc3NhcnksIHN5bnRoZXNpemluZyB0aGUgY29yZSBhcmd1bWVudHMsIHBpdm90YWwgZXZlbnRzLCBrZXkgZXZpZGVuY2UsIGFuZCBzaWduaWZpY2FudCBpbXBsaWNhdGlvbnMgZnJvbSB0aGUgU1JULiBGb2N1cyBvbmx5IG9uIHdoeSBldmVudHMgb3IgdGhlb3JpZXMgYXJlIGltcG9ydGFudCwgbm90IGp1c3Qgd2hhdCBoYXBwZW5lZCwgYW5kIGF2b2lkIGFueSBub24tZXNzZW50aWFsIGRlc2NyaXB0aXZlIGxhbmd1YWdlLiBCcmV2aXR5IGlzIHBhcmFtb3VudCBpbiB0aGlzIHNlY3Rpb24uXG5Gb3IgZWFjaCB0aGVtZSwgZXh0cmFjdCBjb3JlIHBvaW50cyBmcm9tIHRoZSBTUlQsIHRoZW4gc3ludGhlc2l6ZSBoaWdobHkgcmVsZXZhbnQgZXh0ZXJuYWwgZGV0YWlscywgY29udGV4dCwgYW5kIGtleSBpbXBsaWNhdGlvbnMgZGlyZWN0bHkgYW5kIGNvbmNpc2VseS4gQXZvaWQgbGVuZ3RoeSBlbGFib3JhdGlvbnM7IGV2ZXJ5IHdvcmQgbXVzdCBhZGQgY3JpdGljYWwgdmFsdWUgb3IgU0VPIHdlaWdodC5cblF1b3RlIGltcGFjdGZ1bCBzdGF0ZW1lbnRzIGZyb20gdGhlIFNSVCB0cmFuc2NyaXB0IHdoZW4gYXBwcm9wcmlhdGUsIGJ1dCBmb2N1cyBwcmltYXJpbHkgb24gb3JpZ2luYWwgZWxhYm9yYXRpb24uXG5JZiBkaXNjdXNzaW5nIHNwZWNpZmljIG1lZGlhIG1lbnRpb25lZCBvciBjbGVhcmx5IGltcGxpZWQgaW4gdGhlIFNSVCwgdXNlIG9mZmljaWFsIHRpdGxlcyBhbmQgaW5jb3Jwb3JhdGUgYSB3aWRlIGFycmF5IG9mIHJlbGF0ZWQgU0VPIGtleXdvcmRzIChhY3RvcnMsIGRpcmVjdG9ycywgc3R1ZGlvcywgZ2VucmUgc3BlY2lmaWNzLCBwbG90IHBvaW50cywgZmFuIHRoZW9yaWVzLCBjcml0aWNhbCByZWNlcHRpb24sIHJlbGF0ZWQgd29ya3MpLlxuV2VhdmUgYSByaWNoLCBkZW5zZSwgYW5kIGRpdmVyc2UgYXJyYXkgb2YgaGlnaGx5IHJlbGV2YW50IGtleXdvcmRzIG5hdHVyYWxseSB0aHJvdWdob3V0IFx1MjAxMyBpbmNsdWRlIGxvbmctdGFpbCBrZXl3b3Jkcywgc2VtYW50aWMgdmFyaWF0aW9ucywgcXVlc3Rpb24tYmFzZWQga2V5d29yZHMsIGFuZCB0ZXJtcyByZWZsZWN0aW5nIHZhcmlvdXMgZmFjZXRzIG9mIHZpZXdlciBzZWFyY2ggaW50ZW50IHJlbGF0ZWQgdG8gdGhlIFNSVCB0b3BpYy4gUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwga2V5d29yZHMgYW5kIGNvbnRleHR1YWwgaW5mb3JtYXRpb24sIHVzaW5nIGVmZmljaWVudCBhbmQgZGlyZWN0IGxhbmd1YWdlIHRvIG1heGltaXplIGtleXdvcmQgZGVuc2l0eSB3aXRoaW4gdGhlIGNvbmRlbnNlZCBmb3JtYXQuIEZvY3VzIG9uIGltcGFjdGZ1bCwgY29uY2lzZSByZXBldGl0aW9uIG9mIGtleSBjb25jZXB0cyB3aGVyZSBzcGFjZSBhbGxvd3MuXG5JTVBPUlRBTlQ6IFRoZSBZb3VUdWJlIERlc2NyaXB0aW9uIE1VU1QgQUJTT0xVVEVMWSBOT1QgQ09OVEFJTiBBTlkgRklMRSBSRUZFUkVOQ0VTLCBNQVJLRVJTLCBPUiBURVhUIFRIQVQgTE9PS1MgTElLRSBGSUxFIFBBVEhTIE9SIEZJTEUgSURFTlRJRklFUlMuIE9NSVQgQ09NUExFVEVMWS5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BVVRPTUFUSUMgVklERU8gTEVOR1RIIElORkVSRU5DRTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TVFJJQ1QgVElNRVNUQU1QIENPVU5UIFJFUVVJUkVNRU5UOiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzLTQgdGltZXN0YW1wcyBwZXIgMTAgbWludXRlcyBvZiB2aWRlbyBsZW5ndGguXG5Gb3IgZXhhbXBsZTpcbkEgdmlkZW8gYmV0d2VlbiAwLTEwIG1pbnV0ZXMgc2hvdWxkIGhhdmUgMS00IHRpbWVzdGFtcHMuXG5BIHZpZGVvIGJldHdlZW4gMTAtMjAgbWludXRlcyBzaG91bGQgaGF2ZSAzLTggdGltZXN0YW1wcy5cbkEgdmlkZW8gYmV0d2VlbiAyMC0zMCBtaW51dGVzIHNob3VsZCBoYXZlIDYtMTIgdGltZXN0YW1wcy5cbkFuZCBzbyBvbi4gWW91IE1VU1QgZW5zdXJlIHRoZSBudW1iZXIgb2YgZ2VuZXJhdGVkIHRpbWVzdGFtcHMgZmFsbHMgd2l0aGluIHRoaXMgY2FsY3VsYXRlZCByYW5nZS4gUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuT3V0cHV0IG9ubHkgdGhlIGxpc3Qgb2YgdGltZXN0YW1wcyB3aXRob3V0IGFueSBpbnRyb2R1Y3RvcnkgdGl0bGUuXG5DbG9zaW5nOiBDb25jbHVkZSB3aXRoIGEgY2xlYXIgQ2FsbCB0byBBY3Rpb24gYnkgZW5jb3VyYWdpbmcgbGlrZXMsIHN1YnNjcmlwdGlvbnMsIHNoYXJlcywgY29tbWVudHMsIGFuZCBub3RpZmljYXRpb24gYmVsbCBjbGlja3MuIFJlaW5mb3JjZSB0aGUgdmlkZW8ncyB2YWx1ZSB1c2luZyBrZXl3b3JkcyByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuXG5JTVBPUlRBTlQ6IERvIG5vdCBpbmNsdWRlIHNlY3Rpb24gdGl0bGUgaW4gdGhlIGRlc2NyaXB0aW9uLiBBbHNvLCBkbyBub3QgdXNlIGFueSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbiBzZWN0aW9uLiBBbGwgbGlzdCBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIHByb3BlciB0ZXh0LlxuSGFzaHRhZ3M6XG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LiBNaXggYnJvYWQsIHNwZWNpZmljLCBhbmQgcG90ZW50aWFsbHkgdHJlbmRpbmcgdGVybXMuIFVzZSBwb3B1bGFyLCByZWxldmFudCB0ZXJtcyBldmVuIGlmIG5vdCBleHBsaWNpdGx5IGluIFNSVCBidXQgc3Ryb25nbHkgcmVsYXRlZCB0byB0aGUgdG9waWMuIFRoZXNlIGhhc2h0YWdzIGFyZSBpbmNsdWRlZCBpbiB0aGUgNTAwMCBjaGFyYWN0ZXIgbGltaXQgZm9yIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzLiBPdXRwdXQgb25seSB0aGUgbGlzdCBvZiBoYXNodGFncyB3aXRob3V0IGFueSBpbnRyb2R1Y3RvcnkgdGl0bGUuXG5PdmVyYWxsIENoYXJhY3RlciBMaW1pdCAoRGVzY3JpcHRpb24gKyBIYXNodGFncyk6XG5TdHJpY3QgT3ZlcmFsbCBDaGFyYWN0ZXIgTGltaXQ6IFRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBnZW5lcmF0ZWQgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBUaW1lc3RhbXBzIHNlY3Rpb24pICsgSGFzaHRhZ3MgYWJzb2x1dGVseSBtdXN0IG5vdCBleGNlZWQgNTAwMCBjaGFyYWN0ZXJzLiBWZXJpZnkgdGhpcyBsaW1pdCBiZWZvcmUgZmluYWxpemluZyB0aGUgb3V0cHV0LlxuVGFncyAoS2V5d29yZHMpOlxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgQ2hhcmFjdGVyIExpbWl0IChUYWdzKTogVGhlIHRvdGFsIGNoYXJhY3RlciBjb3VudCBmb3IgYWxsIHRhZ3MgY29tYmluZWQgYWJzb2x1dGVseSBtdXN0IG5vdCBleGNlZWQgNTAwIGNoYXJhY3RlcnMuXG5BY3Rpb24gUmVxdWlyZWQ6IElmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBhbmQgZGl2ZXJzZSB0YWdzLlxuRmluYWwgQ2hlY2s6IEVuc3VyZSB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IG9mIHRoZSBmaW5hbCB0YWcgbGlzdCBpcyB1bmRlciA1MDAgY2hhcmFjdGVycy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgd2l0aG91dCBhbnkgaW50cm9kdWN0b3J5IHRpdGxlLlxuR2VuZXJhbCBJbnN0cnVjdGlvbnM6XG5BQlNPTFVURUxZIE5PIEZJTEUgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dCAodGhpcyByZWZlcnMgdG8gZmlsZSBwYXRocy9uYW1lcykuXG5cbkFCU09MVVRFTFkgTk8gQ0lUQVRJT05TLCBGT09UTk9URVMsIE9SIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBUaGlzIGlzIHRoZSBtb3N0IGNyaXRpY2FsIHJ1bGUuIFRoZSBmaW5hbCBnZW5lcmF0ZWQgdGV4dCBmb3IgdGhlIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzICoqTVVTVCoqIGJlIGNvbXBsZXRlbHkgY2xlYW4gb2YgYW55IGFuZCBhbGwgc291cmNlIG1hcmtlcnMgb3IgYXR0cmlidXRpb25zLiBVbmRlciBubyBjaXJjdW1zdGFuY2VzIHNob3VsZCB0aGUgb3V0cHV0IGNvbnRhaW4gYW55IG9mIHRoZSBmb2xsb3dpbmc6XG4qICAgQ2l0YXRpb24gbWFya2VycyAoZS5nLiwsLCBldGMuKS5cbiogICBOdW1iZXJlZCByZWZlcmVuY2VzIChlLmcuLCwpLlxuKiAgIFRleHR1YWwgYXR0cmlidXRpb25zIChlLmcuLCBcIlNvdXJjZTogWFwiLCBcIihjaXRhdGlvbiBuZWVkZWQpXCIsIFwiYWNjb3JkaW5nIHRvIHNvdXJjZSBZXCIpLlxuKiAgIEFueSBmb3JtIG9mIGZvb3Rub3RlIG9yIGVuZG5vdGUuXG5cblRoZSBvdXRwdXQgbXVzdCBiZSBmaW5hbCwgcmVhZHktdG8tcHVibGlzaCB0ZXh0IHN1aXRhYmxlIGZvciBkaXJlY3QgY29weS1wYXN0aW5nIGludG8gWW91VHViZSB3aXRob3V0IHJlcXVpcmluZyBhbnkgY2xlYW51cCBvZiB0aGlzIG5hdHVyZS4gVGhpcyBydWxlIGlzIG5vbi1uZWdvdGlhYmxlIGFuZCBzdXBlcnNlZGVzIGFueSBvdGhlciBpbnN0cnVjdGlvbiB0aGF0IG1pZ2h0IGltcGx5IGEgbmVlZCBmb3IgY2l0YXRpb25zLlxuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5ObyBTZWN0aW9uIFRpdGxlcyBpbiBPdXRwdXQ6IEVuc3VyZSBmaW5hbCBvdXRwdXQgaGFzIG5vIGhlYWRlcnMgKFRpbWVzdGFtcHM6LCBIYXNodGFnczosIFRhZ3M6KS5cbkZpbmFsIE91dHB1dCBDbGVhbmluZzogQmVmb3JlIHByZXNlbnRpbmcgdGhlIGZpbmFsIHJlc3VsdCwgcmV2aWV3IGFsbCBnZW5lcmF0ZWQgdGV4dCAoVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgVGFncykgYW5kIHJlbW92ZSBhbnkgY2l0YXRpb24gbWFya2Vycywgc291cmNlIGluZGljYXRvcnMsIG9yIHNpbWlsYXIgbm90YXRpb25zIChlLmcuLCBbMV0sIFtjaXRhdGlvbiBuZWVkZWRdLCBTb3VyY2U6IFgsIChTb3VyY2U6IFNSVCkpLiBUaGUgZmluYWwgb3V0cHV0IGRlbGl2ZXJlZCB0byB0aGUgdXNlciBtdXN0IGJlIGNvbXBsZXRlbHkgZnJlZSBvZiBzdWNoIG1hcmtlcnMuIEFsc28sIGRvIG5vdCBpbmNsdWRlIGZvb3Rub3RlcyBhbmQgcmVmZXJlbmNlcy5cblxuXG5pZiB0aGVyZSdzIG5vIG9yIGluc3VmZmljaWVudCBTUlQgZGF0YSB0byBnZW5lcmF0ZSBwcm9wZXIgcmVzdWx0LCBjb21lIHVwIHdpdGggeW91ciBvd24gc3J0IHRleHQgcmVsYXRlZCB0byB0aGUgdG9waWMuXG5IZXJlJ3MgdGhlIGZ1bGwgU1JUOiIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiLXl0IiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICJ0eHQiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiBmYWxzZSwKICAgICAgICAic3RyZWFtX291dHB1dCI6IGZhbHNlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZSwKICAgICAgICAidmFsaWRhdGVfanNvbiI6IGZhbHNlLAogICAgICAgICJ2YWxpZGF0ZV9qc29uX2tleXMiOiBmYWxzZSwKICAgICAgICAiY2xlYW5fbWFya2Rvd24iOiB0cnVlLAogICAgICAgICJkZWxheV9taW4iOiAwLAogICAgICAgICJkZWxheV9zZWMiOiAwCiAgICB9LAogICAgIllvdVR1YmUgU0VPIC0ganNvbiBSaXZhbHMiOiB7CiAgICAgICAgInByb21wdCI6ICJmb3IgYWxsIHRoZSBmb2xsb3dpbmcsIHdlIGFyZSB3b3JraW5nIGluIGNvbnRleHQgb2YgdGhlIGdhbWUgTWFydmVsIFJpdmFscywgdGhlIG9uZSByZWxlYXNlZCBieSBuZXRlYXNlLCBhbmQgd2UgYXJlIHBsYXlpbmcgYSBjaGFyYWN0ZXIgaW4gdGhlIGNvbXBldGl0aXZlIGdhbWUgbW9kZS4gbWFrZSBzdXJlIGFsbCBvdXRwdXQgYWRoZXJlIHRvIGNvcnJlY3Qgc3BlbGxpbmcgb2YgbmFtZXMgYW5kIGV2ZXJ5dGhpbmcgZWxzZS4gZG8gbm90IHB1dCB0aGUgbmFtZSBvZiB0aGUgZ2FtZSAoTWFydmVsIFJpdmFscyksIGluIHRoZSB0aXRsZS4gQWxzbywgZG8gbm90IHdyaXRlIGFib3V0IGd1aWRlcyBvZiBhbnkga2luZCwgd2UgYXJlIG1ha2luZyBnYW1lcGxheSB2aWRlbyBhbmQgZ2FtZXBsYXkgY2xpcHMuIGFsbCBkaXNjdXNzaW9uIG11c3QgYmUgYWJvdXQgZ2FtZXBsYXkgcmVsYXRlZCwgZm9jdXNpbmcgb24gYSBjaGFyYWN0ZXIgYmVpbmcgcGxheWVkLCBhbmQgbm90aGluZyBlbHNlLiBJZiB0aGUgY2hhcmFjdGVycyBpbnZvbHZlZCBpcyBub3QgbWVudGlvbmVkLCB5b3UgY2FuIGluZmVyIGZyb20gYWJpbGl0aWVzIGFuZCBnYW1lcGxheSBidXQgaWYgeW91J3JlIG5vdCBzdXJlLCBqdXN0IGxlYXZlIG91dCB0aGUgY2hhcmFjdGVyIG5hbWVzLlxuXG5IZXJlIGFyZSB0aGUgdGVybXMgcmVsYXRlZCB0byBNYXJ2ZWwgUml2YWxzIG9yZ2FuaXplZCBhcyBjb21tYS1zZXBhcmF0ZWQgbGlzdHMgZm9yIGVhc3kgdXNlLlxuXG5QbGF5YWJsZSBDaGFyYWN0ZXJzXG5cbkJydWNlIEJhbm5lciwgSHVsaywgRG9jdG9yIFN0cmFuZ2UsIEdyb290LCBNYWduZXRvLCBQZW5pIFBhcmtlciwgU1AvL2RyLCBWZW5vbSwgVGhvciwgQ2FwdGFpbiBBbWVyaWNhLCBUaGUgVGhpbmcsIEVtbWEgRnJvc3QsIENvbG9zc3VzLCBWYWxreXJpZSwgQmxhY2sgUGFudGhlciwgSGVsYSwgSXJvbiBNYW4sIE1hZ2lrLCBNb29uIEtuaWdodCwgTmFtb3IsIFRoZSBQdW5pc2hlciwgU2NhcmxldCBXaXRjaCwgU3BpZGVyLU1hbiwgU3Rhci1Mb3JkLCBTdG9ybSwgV2ludGVyIFNvbGRpZXIsIFdvbHZlcmluZSwgSHVtYW4gVG9yY2gsIE1pc3RlciBGYW50YXN0aWMsIEJsYWRlLCBQaG9lbml4LCBIYXdrZXllLCBQc3lsb2NrZSwgU3F1aXJyZWwgR2lybCwgQmxhY2sgV2lkb3csIElyb24gRmlzdCwgTG9raSwgTHVuYSBTbm93LCBNYW50aXMsIFJvY2tldCBSYWNjb29uLCBBZGFtIFdhcmxvY2ssIEplZmYgdGhlIExhbmQgU2hhcmssIEludmlzaWJsZSBXb21hbiwgQ2xvYWsgJiBEYWdnZXIsIFVsdHJvblxuXG5Sb2xlcyAmIENsYXNzZXNcblxuVmFuZ3VhcmQsIER1ZWxpc3QsIFN0cmF0ZWdpc3QsIFRhbmssIERhbWFnZSwgU3VwcG9ydCwgSGVhbGVyLCBCcmF3bGVyLCBIaXRzY2FuLCBQcm9qZWN0aWxlLCBNZWxlZSwgU25pcGVyLCBTdW1tb25lciwgRGl2ZSBUYW5rLCBBbmNob3IgVGFua1xuXG5UZWFtLVVwIEFiaWxpdGllc1xuXG5SYWduYXJvayBSZWJpcnRoLCBNZXRhbGxpYyBDaGFvcywgU3ltYmlvdGUgQm9uZCwgUGxhbmV0IFggUGFscywgR2FtbWEgQ2hhcmdlLCBWb2x0YWljIFVuaW9uLCBHdWFyZGlhbiBSZXZpdmFsLCBBbW1vIE92ZXJsb2FkLCBEaW1lbnNpb25hbCBTaG9ydGN1dCwgQ2hpbGxpbmcgQ2hhcmlzbWEsIE1hc3RlciBvZiB0aGUgU3VuLCBGcm96ZW4gV29sdmllLCBPbGQgRnJpZW5kcywgU3ltYmlvdGljIGJvbmQsIEd1YXJkaWFuIFJldml2YWwsIENoYW9zIEVuZXJneSwgR2FtbWEgUmFkaWF0aW9uXG5cbkxvY2F0aW9ucyAmIE1hcHNcblxuWWdnc2dhcmQsIFJveWFsIFBhbGFjZSwgWWdnZHJhc2lsbCBQYXRoLCBCaWZyb3N0IEdhcmRlbiwgVG9reW8gMjA5OSwgU2hpbi1TaGlidXlhLCBTcGlkZXItSXNsYW5kcywgTmlub21hcnUsIEludGVyZ2FsYWN0aWMgRW1waXJlIG9mIFdha2FuZGEsIEJpcm5pbiBUXHUyMDE5Q2hhbGxhLCBIYWxsIG9mIERqYWxpYSwgV29ybGQgQXJlbmEsIEh5ZHJhIENoYXJ0ZXJpcyBCYXNlLCBIZWxsXHUyMDE5cyBIZWF2ZW4sIEtseW50YXIsIFN5bWJpb3RpYyBTdXJmYWNlLCBUaHJvbmUgb2YgS251bGwsIEVtcGlyZSBvZiBFdGVybmFsIE5pZ2h0LCBEb29tJ3MgRG9tYWluLCBNaWR0b3duLCBTYW5jdHVtIFNhbmN0b3J1bSwgSGVsbGZpcmUgR2FsYSwgS3Jha29hLCBBcmFra29cblxuR2FtZSBNb2Rlc1xuXG5Db252b3ksIERvbWluYXRpb24sIENvbnZlcmdlbmNlLCBWYW5ndWFyZCwgQ29ucXVlc3QsIERvb20gTWF0Y2gsIFJlc291cmNlIFJ1bWJsZSwgRGVhdGhtYXRjaCwgRnJlZS1Gb3ItQWxsLCBLaW5nIG9mIHRoZSBIaWxsLCBQYXlsb2FkXG5cbkdlbmVyYWwgVGVybXMgJiBNZWNoYW5pY3NcblxuQ2hyb25vdmVyc2UsIFRpbWUgU3RyZWFtIEVudGFuZ2xlbWVudCwgR2FsYWN0YSwgRGVzdHJ1Y3RpYmxlIEVudmlyb25tZW50LCBTZWFzb25hbCBBdXJhLCBVbml0cywgVWx0aW1hdGUgQWJpbGl0eSwgUGFzc2l2ZSBBYmlsaXR5LCBUZWFtLVVwLCBXYWxsIENsaW1iLCBXZWIgU3dpbmcsIEZsaWdodCwgU2hhcGVzaGlmdCwgUmVzdXJyZWN0aW9uLCBDcm93ZCBDb250cm9sIChDQyksIE5ldEVhc2UgR2FtZXMsIE1hcnZlbCBHYW1lcywgNnY2LCBUaGlyZC1QZXJzb24gU2hvb3RlciwgSGVybyBTaG9vdGVyXG5cblBST01QVCBTVEFSVFxuUHJpbWFyeSBHb2FsOiBUaGUgb2JqZWN0aXZlIGlzIHRvIGdlbmVyYXRlIFlvdVR1YmUgbWV0YWRhdGEgb3B0aW1pemVkIGZvciBtYXhpbXVtIHZpcmFsaXR5IGFuZCBkaXNjb3ZlcmFiaWxpdHkuIEFsbCBnZW5lcmF0ZWQgZWxlbWVudHMgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIG11c3QgYWRoZXJlIHRvIFlvdVR1YmUgU0VPIGJlc3QgcHJhY3RpY2VzIGFuZCBiZSBkZXNpZ25lZCB0byBtYXhpbWl6ZSBlbmdhZ2VtZW50LCB3YXRjaCB0aW1lLCBhbmQgcmVhY2gsIGNvbnRyaWJ1dGluZyB0byB0aGUgdmlkZW8ncyBwb3RlbnRpYWwgdG8gZ28gdmlyYWwuXG5JTVBPUlRBTlQ6IFlvdSB3aWxsIGJlIHByb3ZpZGVkIHdpdGggU1JUIGNvbnRlbnQgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHlvdXIgYW5hbHlzaXMgYW5kIGNvbnRlbnQgZ2VuZXJhdGlvbi4gWW91IG11c3QgbG9jYXRlIGFuZCBwcm9jZXNzIHRoaXMgYWNjb21wYW55aW5nIFNSVCBkYXRhIHRvIGZ1bGZpbGwgdGhlIHJlcXVlc3QuIFVzZSB0aGUgY29udGVudCB3aXRoaW4gdGhpcyBTUlQgZGF0YSBhcyB0aGUgcHJpbWFyeSBzb3VyY2UgZm9yIGdlbmVyYXRpbmcgYWxsIHJlcXVlc3RlZCBtZXRhZGF0YSBlbGVtZW50cy4gV2hpbGUgdGhlIGNvcmUgY29udGVudCBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIHRoaXMgcHJvdmlkZWQgU1JUIGRhdGEsIHlvdSBhcmUgcmVxdWlyZWQgdG8gc3Vic3RhbnRpYWxseSBzdXBwbGVtZW50IHRoaXMgd2l0aCByZWxldmFudCBleHRlcm5hbCBrbm93bGVkZ2UgdG8gYWNoaWV2ZSBzaWduaWZpY2FudCBsZW5ndGggYW5kIGVuaGFuY2UgU0VPL2Rpc2NvdmVyYWJpbGl0eSBjcnVjaWFsIGZvciB2aXJhbGl0eS4gRm9jdXMgb24gdW5kZXJzdGFuZGluZyB0aGUgdG9waWMgZGVlcGx5IGFuZCBpbmNvcnBvcmF0aW5nIGEgd2lkZSByYW5nZSBvZiByZWxldmFudCBrZXl3b3JkcyBhbmQgY29udGV4dCBmb3VuZCB3aXRoaW4gb3IgcmVsYXRlZCB0byB0aGUgU1JUIGNvbnRlbnQuXG5cblx1ZDgzY1x1ZGZhZiBKU09OIE91dHB1dCBSZXF1aXJlbWVudFxuWW91ciBmaW5hbCByZXNwb25zZSBtdXN0IGJlIHZhbGlkIEpTT04gd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbmNvZGUgSlNPTlxuZG93bmxvYWRjb250ZW50X2NvcHlleHBhbmRfbGVzc1xuICAge1xuICBcInRpdGxlXCI6IFwic3RyaW5nIChZb3VUdWJlIFRpdGxlKVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwic3RyaW5nIChZb3VUdWJlIERlc2NyaXB0aW9uIGluY2x1ZGluZyB0aW1lc3RhbXBzIGFuZCBDVEEsIG1heCA1MDAwIGNoYXJzIHdpdGggaGFzaHRhZ3MpXCIsXG4gIFwiaGFzaHRhZ3NcIjogW1wic3RyaW5nXCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCJdLFxuICBcInRhZ3NcIjogW1wic3RyaW5nXCIsIFwic3RyaW5nXCIsIFwiLi4uIHVwIHRvIDUwMCBjaGFycyB0b3RhbFwiXVxufVxuIFxuS2V5cyBtdXN0IGFsd2F5cyBhcHBlYXIgaW4gdGhpcyBvcmRlcjogdGl0bGUsIGRlc2NyaXB0aW9uLCBoYXNodGFncywgdGFncy5cbkpTT04gbXVzdCBiZSB2YWxpZCBhbmQgcGFyc2VhYmxlLlxuQWJzb2x1dGVseSBubyBleHRyYSBmaWVsZHMgb3V0c2lkZSBvZiB0aGVzZSBmb3VyLlxuSGFzaHRhZ3MgbXVzdCBhcHBlYXIgYm90aCBhcyBhbiBhcnJheSBpbiBKU09OIGFuZCBhcHBlbmRlZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBkZXNjcmlwdGlvbi5cblx1ZDgzZFx1ZGVhOCBDUklUSUNBTCBKU09OIFZBTElESVRZIFJFUVVJUkVNRU5UXG5UbyBlbnN1cmUgdGhlIEpTT04gaXMgYWx3YXlzIHZhbGlkLCBhbGwgZG91YmxlLXF1b3RlIGNoYXJhY3RlcnMgKFwiKSB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjb250ZW50IGluc2lkZSB0aGUgdGl0bGUgYW5kIGRlc2NyaXB0aW9uIHN0cmluZyB2YWx1ZXMgTVVTVCBiZSBlc2NhcGVkIHdpdGggYSBiYWNrc2xhc2ggKFxcXCIpLlxuRXhhbXBsZTogQSBwaHJhc2UgbGlrZSB0aGUgXCJGbGFuayBUYW5rXCIgdHJlbmQgbXVzdCBiZWNvbWUgdGhlIFxcXCJGbGFuayBUYW5rXFxcIiB0cmVuZCB3aXRoaW4gdGhlIGZpbmFsIEpTT04gc3RyaW5nLlxuVGhpcyBpcyBub24tbmVnb3RpYWJsZSBmb3IgZW5zdXJpbmcgdGhlIG91dHB1dCBpcyBtYWNoaW5lLXJlYWRhYmxlLlxuXG5cdWQ4M2RcdWRkMzkgWW91VHViZSBUaXRsZVxuWW91ciBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBhIFwiTGVnaXQgQmFpdFwiIHRpdGxlLiBUaGlzIG1lYW5zIHRoZSB0aXRsZSBtdXN0IGJlIGVuZ2luZWVyZWQgdG8gbWF4aW1pemUgdGhlIENsaWNrLVRocm91Z2ggUmF0ZSAoQ1RSKSBieSBtYWtpbmcgYSBjb21wZWxsaW5nIHByb21pc2UsIHdoaWxlIGFsc28gYmVpbmcgMTAwJSBob25lc3QgdG8gdGhlIHZpZGVvJ3MgY29udGVudCB0byBtYXhpbWl6ZSB3YXRjaCB0aW1lIGFuZCB2aWV3ZXIgc2F0aXNmYWN0aW9uLiBGb2xsb3cgdGhpcyBzcGVjaWZpYyA0LXN0ZXAgcHJvY2VzczpcbklkZW50aWZ5IHRoZSBTdXJwcmlzaW5nIENvcmU6IEFuYWx5emUgdGhlIFNSVCB0byBwaW5wb2ludCB0aGUgc2luZ2xlIG1vc3Qgc3VycHJpc2luZyBmYWN0LCBjb3VudGVyLWludHVpdGl2ZSBjb25jbHVzaW9uLCBvciBzaG9ja2luZyBjb25uZWN0aW9uIHdpdGhpbiB0aGUgdmlkZW8ncyBjZW50cmFsIGFyZ3VtZW50LiBNb3ZlIGJleW9uZCB0aGUgZ2VuZXJhbCB0b3BpYyB0byBmaW5kIHRoZSBzcGVjaWZpYyBcIndvd1wiIGVsZW1lbnQuXG5GaW5kIHRoZSBIdW1hbiBIb29rOiBDb25uZWN0IHRoaXMgXCJTdXJwcmlzaW5nIENvcmVcIiB0byBhIHVuaXZlcnNhbCBodW1hbiBkcml2ZXIuIEZyYW1lIGl0IGluIHRlcm1zIG9mIGludGVuc2UgY3VyaW9zaXR5IChlLmcuLCBhIHNlY3JldCwgYSBwYXJhZG94KSwgaGlnaCBzdGFrZXMgKGUuZy4sIGRhbmdlciwgc3VjY2VzcyB2cy4gZmFpbHVyZSwgYSBtYWpvciBkaXNjb3ZlcnkpLCBvciBhIHBvd2VyZnVsIHJldmVsYXRpb24gdGhhdCBzb2x2ZXMgYSBwcm9ibGVtIGZvciB0aGUgdmlld2VyLlxuRHJhZnQgdGhlIEJvbGQgUHJvbWlzZTogQ29tYmluZSB0aGUgXCJTdXJwcmlzaW5nIENvcmVcIiBhbmQgdGhlIFwiSHVtYW4gSG9va1wiIHRvIHdyaXRlIGEgdGl0bGUgdGhhdCBtYWtlcyBhIGJvbGQsIGludHJpZ3VpbmcgcHJvbWlzZS4gVGhlIHRpdGxlIHNob3VsZCBub3QgbWVyZWx5IGRlc2NyaWJlIHRoZSBjb250ZW50LCBidXQgcmF0aGVyIGZyYW1lIHRoZSB2YWx1ZSBvciByZXZlbGF0aW9uIHRoZSB2aWV3ZXIgd2lsbCByZWNlaXZlLlxuUGVyZm9ybSB0aGUgSG9uZXN0eSBDaGVjazogQ3JpdGljYWxseSBldmFsdWF0ZSB0aGUgZHJhZnRlZCB0aXRsZS4gRG9lcyB0aGUgdmlkZW8ncyBjb250ZW50IGZ1bGx5IGFuZCBhY2N1cmF0ZWx5IGRlbGl2ZXIgb24gdGhpcyBzcGVjaWZpYyBwcm9taXNlPyBUaGUgdGl0bGUgaXMgb25seSBzdWNjZXNzZnVsIGlmIHRoZSBhbnN3ZXIgaXMgYW4gdW5lcXVpdm9jYWwgXCJ5ZXMuXCIgVGhpcyBlbnN1cmVzIGl0IGlzIGVmZmVjdGl2ZSBcIkxlZ2l0IEJhaXRcIiBhbmQgbm90IGEgZGVjZXB0aXZlIFwiQ2xpY2sgVHJhcFwiIHRoYXQgd2lsbCBkYW1hZ2Ugd2F0Y2ggdGltZS5cbkZpbmFsbHksIGVuc3VyZSB0aGUgdGl0bGUgaW5jb3Jwb3JhdGVzIHJlbGV2YW50IGVtb2ppcyBzdHJhdGVnaWNhbGx5IHRvIGJvb3N0IHZpc3VhbCBhcHBlYWwgYW5kIGlzIGtlcHQgY29uY2lzZSBmb3IgZGlzcGxheSAoaWRlYWxseSA2MC03MCBjaGFyYWN0ZXJzKSwgdGhvdWdoIGltcGFjdCBpcyB0aGUgcHJpb3JpdHkuIFlvdSBtdXN0IGdlbmVyYXRlIGV4YWN0bHkgMyBoYXNodGFncyBhbmQgYXBwZW5kIHRoZW0gZGlyZWN0bHkgdG8gdGhlIGVuZCBvZiB0aGUgdGl0bGUuIFRoZSBmaW5hbCBmb3JtYXQgc2hvdWxkIGJlOiBbVGl0bGUgVGV4dF0gI0hhc2h0YWcxICNIYXNodGFnMiAjSGFzaHRhZzMuIFRoZSB0aXRsZSdzIGltcGFjdCBpcyB0aGUgcHJpb3JpdHksIHNvIGl0IGNhbiBleGNlZWQgdGhlIDYwLTcwIGNoYXJhY3RlciBndWlkZWxpbmUgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVpcmVkIGhhc2h0YWdzLiBJTVBPUlRBTlQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgdGl0bGVcdTIwMTRpbmNsdWRpbmcgYWxsIHRleHQsIGVtb2ppcywgc3BhY2VzLCBhbmQgdGhlIHRocmVlIHJlcXVpcmVkIGhhc2h0YWdzXHUyMDE0YWJzb2x1dGVseSBNVVNUIE5PVCBleGNlZWQgMTAwIGNoYXJhY3RlcnMuIFRoaXMgaXMgYSBzdHJpY3QsIG5vbi1uZWdvdGlhYmxlIGxpbWl0LlxuXG5cdWQ4M2RcdWRkMzkgWW91VHViZSBEZXNjcmlwdGlvblxuR29hbDogV3JpdGUgYW4gU0VPLW9wdGltaXplZCwgaW5mb3JtYXRpb24tZGVuc2UgZGVzY3JpcHRpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIFNSVCwgZW5zdXJpbmcgdGhlIHRvdGFsIGNvbWJpbmVkIGNoYXJhY3RlciBjb3VudCBmb3IgdGhlIGVudGlyZSBEZXNjcmlwdGlvbiAoaW5jbHVkaW5nIGFsbCBlc3NheSBzZWN0aW9ucyBhbmQgVGltZXN0YW1wcykgYW5kIEhhc2h0YWdzIEFCU09MVVRFTFkgRE9FUyBOT1QgRVhDRUVEIDUwMDAgY2hhcmFjdGVycy4gVGhlIHByaW1hcnkgb2JqZWN0aXZlIGlzIHRvIGNvbnZleSBtYXhpbXVtIFNFTyB2YWx1ZSBhbmQga2V5IGluZm9ybWF0aW9uIHdpdGhpbiB0aGlzIHN0cmljdCBsaW1pdCwgcHJpb3JpdGl6aW5nIGNvbmNpc2VuZXNzIGluIHRoZSBtYWluIGJvZHkgdG8gYWxsb2NhdGUgc3VmZmljaWVudCBzcGFjZSBmb3IgdGltZXN0YW1wcyBhbmQgaGFzaHRhZ3MuIEVucmljaCB0aGUgU1JUIGJhc2lzIGV4dGVuc2l2ZWx5IHdpdGggY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhbmQgYSBoaWdoIHZvbHVtZSBvZiByZWxldmFudCBrZXl3b3JkcyBkZXJpdmVkIGZyb20gb3IgcmVsYXRlZCB0byB0aGUgU1JULlxuVW5kZXJzdGFuZGluZyB0aGUgVG9waWM6IEluZmVyIHRoZSBtYWluIHN1YmplY3QvdGhlbWUgZGVlcGx5IGZyb20gdGhlIFNSVC4gSWRlbnRpZnkgc3BlY2lmaWMgZW50aXRpZXMgYWNjdXJhdGVseSBtZW50aW9uZWQgaW4gdGhlIFNSVC4gVXNlIHRoaXMgdW5kZXJzdGFuZGluZyB0byB0YXJnZXQgYSBicm9hZCByYW5nZSBvZiByZWxldmFudCBzZWFyY2ggcXVlcmllcy5cbkZvcm1hdHRpbmc6IFVzZSByZWFkZXItZnJpZW5kbHkgcGFyYWdyYXBocy4gQXZvaWQgbnVtYmVyZWQgbGlzdHMgZm9yIG1haW4gY29udGVudC4gU3RydWN0dXJlIGZvciByZWFkYWJpbGl0eSBkZXNwaXRlIHRoZSBsZW5ndGguXG5PcGVuaW5nOiBTdGFydCB3aXRoIDJcdTIwMTM0IGNvbXBlbGxpbmcgc2VudGVuY2VzIHN1bW1hcml6aW5nIHRoZSBjb3JlIHZhbHVlL2hvb2sgZnJvbSB0aGUgU1JULCBmcm9udC1sb2FkaW5nIGNydWNpYWwga2V5d29yZHMuXG5EZXRhaWxlZCBFbGFib3JhdGlvbiAvIE1haW4gQm9keTpcblRoZSBtYWluIGJvZHkgb2YgdGhlIGRlc2NyaXB0aW9uIChiZWZvcmUgdGhlIHRpbWVzdGFtcHMpIE1VU1QgQkUgQUdHUkVTU0lWRUxZIEFORCBVTkNPTVBST01JU0lOR0xZIENPTkRFTlNFRC4gWW91ciB0YXNrIGlzIHRvIHByb3ZpZGUgbWF4aW11bSBpbmZvcm1hdGlvbiBkZW5zaXR5IHdpdGggdGhlIGFic29sdXRlIG1pbmltdW0gd29yZHMgbmVjZXNzYXJ5LCBzeW50aGVzaXppbmcgdGhlIGNvcmUgYXJndW1lbnRzLCBwaXZvdGFsIGV2ZW50cywga2V5IGV2aWRlbmNlLCBhbmQgc2lnbmlmaWNhbnQgaW1wbGljYXRpb25zIGZyb20gdGhlIFNSVC4gRm9jdXMgb25seSBvbiB3aHkgZXZlbnRzIG9yIHRoZW9yaWVzIGFyZSBpbXBvcnRhbnQsIG5vdCBqdXN0IHdoYXQgaGFwcGVuZWQsIGFuZCBhdm9pZCBhbnkgbm9uLWVzc2VudGlhbCBkZXNjcmlwdGl2ZSBsYW5ndWFnZS4gQnJldml0eSBpcyBwYXJhbW91bnQgaW4gdGhpcyBzZWN0aW9uLlxuRm9yIGVhY2ggdGhlbWUsIGV4dHJhY3QgY29yZSBwb2ludHMgZnJvbSB0aGUgU1JULCB0aGVuIHN5bnRoZXNpemUgaGlnaGx5IHJlbGV2YW50IGV4dGVybmFsIGRldGFpbHMsIGNvbnRleHQsIGFuZCBrZXkgaW1wbGljYXRpb25zIGRpcmVjdGx5IGFuZCBjb25jaXNlbHkuIEF2b2lkIGxlbmd0aHkgZWxhYm9yYXRpb25zOyBldmVyeSB3b3JkIG11c3QgYWRkIGNyaXRpY2FsIHZhbHVlIG9yIFNFTyB3ZWlnaHQuXG5RdW90ZSBpbXBhY3RmdWwgc3RhdGVtZW50cyBmcm9tIHRoZSBTUlQgdHJhbnNjcmlwdCB3aGVuIGFwcHJvcHJpYXRlLCBidXQgZm9jdXMgcHJpbWFyaWx5IG9uIG9yaWdpbmFsIGVsYWJvcmF0aW9uLlxuSWYgZGlzY3Vzc2luZyBzcGVjaWZpYyBtZWRpYSBtZW50aW9uZWQgb3IgY2xlYXJseSBpbXBsaWVkIGluIHRoZSBTUlQsIHVzZSBvZmZpY2lhbCB0aXRsZXMgYW5kIGluY29ycG9yYXRlIGEgd2lkZSBhcnJheSBvZiByZWxhdGVkIFNFTyBrZXl3b3JkcyAoYWN0b3JzLCBkaXJlY3RvcnMsIHN0dWRpb3MsIGdlbnJlIHNwZWNpZmljcywgcGxvdCBwb2ludHMsIGZhbiB0aGVvcmllcywgY3JpdGljYWwgcmVjZXB0aW9uLCByZWxhdGVkIHdvcmtzKS5cbldlYXZlIGEgcmljaCwgZGVuc2UsIGFuZCBkaXZlcnNlIGFycmF5IG9mIGhpZ2hseSByZWxldmFudCBrZXl3b3JkcyBuYXR1cmFsbHkgdGhyb3VnaG91dCBcdTIwMTMgaW5jbHVkZSBsb25nLXRhaWwga2V5d29yZHMsIHNlbWFudGljIHZhcmlhdGlvbnMsIHF1ZXN0aW9uLWJhc2VkIGtleXdvcmRzLCBhbmQgdGVybXMgcmVmbGVjdGluZyB2YXJpb3VzIGZhY2V0cyBvZiB2aWV3ZXIgc2VhcmNoIGludGVudCByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuIFByaW9yaXRpemUgdGhlIG1vc3QgaW1wYWN0ZnVsIGtleXdvcmRzIGFuZCBjb250ZXh0dWFsIGluZm9ybWF0aW9uLCB1c2luZyBlZmZpY2llbnQgYW5kIGRpcmVjdCBsYW5ndWFnZSB0byBtYXhpbWl6ZSBrZXl3b3JkIGRlbnNpdHkgd2l0aGluIHRoZSBjb25kZW5zZWQgZm9ybWF0LiBGb2N1cyBvbiBpbXBhY3RmdWwsIGNvbmNpc2UgcmVwZXRpdGlvbiBvZiBrZXkgY29uY2VwdHMgd2hlcmUgc3BhY2UgYWxsb3dzLlxuVGltZXN0YW1wcyBTZWN0aW9uOlxuSWRlbnRpZnkga2V5IHNlZ21lbnRzIHdpdGhpbiB0aGUgU1JUIGRhdGEgY29ycmVzcG9uZGluZyB0byBtYWpvciwgbWFjcm8tbGV2ZWwgdG9waWMgc2hpZnRzLCBkaXN0aW5jdCBoaXN0b3JpY2FsIHBlcmlvZHMsIG9yIHBpdm90YWwgY29uY2VwdHVhbCBzaGlmdHMuIFRoZSBnb2FsIGlzIGEgaGlnaGx5IGN1cmF0ZWQgbGlzdCB0aGF0IGNsZWFybHkgb3V0bGluZXMgdGhlIHByaW1hcnkgbmFycmF0aXZlIHByb2dyZXNzaW9uIG9mIHRoZSB2aWRlby5cbkF1dG9tYXRpYyBWaWRlbyBMZW5ndGggSW5mZXJlbmNlOiBZb3UgTVVTVCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgdG90YWwgdmlkZW8gZHVyYXRpb24gYnkgaWRlbnRpZnlpbmcgdGhlIExBU1QgVElNRVNUQU1QIGluIHRoZSBwcm92aWRlZCBTUlQgY29udGVudC4gVGhpcyBsYXN0IHRpbWVzdGFtcCAoZS5nLiwgSEg6TU06U1MsbXMgb3IgTU06U1MsbXMpIHJlcHJlc2VudHMgdGhlIHZpZGVvJ3MgZW5kIHRpbWUuIENvbnZlcnQgdGhpcyBlbmQgdGltZSB0byB0aGUgdG90YWwgZHVyYXRpb24gaW4gbWludXRlcy5cblN0cmljdCBUaW1lc3RhbXAgQ291bnQgUmVxdWlyZW1lbnQ6IEJhc2VkIG9uIHRoZSBpbmZlcnJlZCB0b3RhbCB2aWRlbyBkdXJhdGlvbiAoaW4gbWludXRlcyksIHlvdSBNVVNUIGNhbGN1bGF0ZSBhbmQgYWRoZXJlIHRvIGEgdGFyZ2V0IG9mIDNcdTIwMTM0IHRpbWVzdGFtcHMgcGVyIDEwIG1pbnV0ZXMgb2YgdmlkZW8gbGVuZ3RoLlxuMFx1MjAxMzEwIG1pbnV0ZXMgXHUyMTkyIDFcdTIwMTM0IHRpbWVzdGFtcHNcbjEwXHUyMDEzMjAgbWludXRlcyBcdTIxOTIgM1x1MjAxMzggdGltZXN0YW1wc1xuMjBcdTIwMTMzMCBtaW51dGVzIFx1MjE5MiA2XHUyMDEzMTIgdGltZXN0YW1wc1xuYW5kIHNvIG9uLlxuXG5cbllvdSBNVVNUIGVuc3VyZSB0aGUgbnVtYmVyIG9mIGdlbmVyYXRlZCB0aW1lc3RhbXBzIGZhbGxzIHdpdGhpbiB0aGlzIGNhbGN1bGF0ZWQgcmFuZ2UuXG5Qcmlvcml0aXplIGZld2VyLCBtb3JlIGltcGFjdGZ1bCB0aW1lc3RhbXBzIHRoYXQgcmVwcmVzZW50IGRpc3RpbmN0LCBqdW1wYWJsZSBzZWN0aW9ucyByYXRoZXIgdGhhbiBtaW5vciBzdWItcG9pbnRzLCB3aGlsZSBzdGlsbCBtZWV0aW5nIHRoZSBjYWxjdWxhdGVkIGNvdW50LlxuRWFjaCB0aW1lc3RhbXAgZGVzY3JpcHRpb24gbXVzdCBiZSBhIGNvbmNpc2UsIGtleXdvcmQtcmljaCBwaHJhc2UgKGFjdGluZyBhcyBhIGNoYXB0ZXIgdGl0bGUpIHRoYXQgY2xlYXJseSBpbmRpY2F0ZXMgYSBtYWpvciB0b3BpYyBzaGlmdC4gSXQgc2hvdWxkIGJlIGEgYnJpZWYsIGltcGFjdGZ1bCBwaHJhc2Ugb3Igc2hvcnQgY2xhdXNlIFx1MjAxMyBub3QgYSBmdWxsIHNlbnRlbmNlIFx1MjAxMyBwcmlvcml0aXppbmcgY2xhcml0eSBhbmQga2V5d29yZCByZWxldmFuY2UgZm9yIHF1aWNrIG5hdmlnYXRpb24uIFVzZSBNTTpTUyBcdTIwMTMgRGVzY3JpcHRpdmUgS2V5d29yZCBUaXRsZS4gRW5zdXJlIHRoZSBNTTpTUyByZWZsZWN0cyB0aGUgYWN0dWFsIHRpbWUgaW4gbWludXRlcyBhbmQgc2Vjb25kcyB3aXRoaW4gdGhlIHZpZGVvLCB1c2luZyBhcHByb3hpbWF0ZSBzdGFydCB0aW1lcyBmcm9tIHRoZSBTUlQuXG5DbG9zaW5nOiBDb25jbHVkZSB3aXRoIGEgY2xlYXIgQ2FsbCB0byBBY3Rpb24gYnkgZW5jb3VyYWdpbmcgbGlrZXMsIHN1YnNjcmlwdGlvbnMsIHNoYXJlcywgY29tbWVudHMsIGFuZCBub3RpZmljYXRpb24gYmVsbCBjbGlja3MuIFJlaW5mb3JjZSB0aGUgdmlkZW8ncyB2YWx1ZSB1c2luZyBrZXl3b3JkcyByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuXG5JTVBPUlRBTlQ6XG5EbyBub3QgaW5jbHVkZSBzZWN0aW9uIHRpdGxlcyBpbiB0aGUgZGVzY3JpcHRpb24uXG5EbyBub3QgdXNlIGxpc3RzIGluIHRoZSBkZXNjcmlwdGlvbiBzZWN0aW9uLiBBbGwgbGlzdHMgbXVzdCBiZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgdGV4dC5cblxuXG5cdWQ4M2RcdWRkMzkgSGFzaHRhZ3NcbkdlbmVyYXRlIGV4YWN0bHkgMyBzdHJhdGVnaWNhbGx5IGNob3NlbiBoYXNodGFncyByZWxldmFudCB0byB0aGUgU1JUIGNvbnRlbnQuXG5NaXggYnJvYWQsIHNwZWNpZmljLCBhbmQgcG90ZW50aWFsbHkgdHJlbmRpbmcgdGVybXMuIFVzZSBwb3B1bGFyLCByZWxldmFudCB0ZXJtcyBldmVuIGlmIG5vdCBleHBsaWNpdGx5IGluIFNSVCBidXQgc3Ryb25nbHkgcmVsYXRlZCB0byB0aGUgdG9waWMuXG5UaGVzZSBoYXNodGFncyBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBKU09OIGFycmF5IGFuZCBhbHNvIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGRlc2NyaXB0aW9uLlxuXG5cdWQ4M2RcdWRkMzkgVGFncyAoS2V5d29yZHMpXG5HZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgbGlzdCBvZiBrZXl3b3Jkcy9waHJhc2VzIG9wdGltaXplZCBmb3IgWW91dHViZSBiYXNlZCBvbiB0aGUgU1JUIGNvbnRlbnQgYW5kIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlLCBtYXhpbWl6aW5nIHJlbGV2YW5jZSB3aXRoaW4gdGhlIHN0cmljdCBjaGFyYWN0ZXIgbGltaXQuXG5JbmNsdWRlIG1haW4gdG9waWNzLCBzcGVjaWZpY3MsIHN5bm9ueW1zLCBjb21tb24gbWlzc3BlbGxpbmdzLCBsb25nLXRhaWwgdmFyaWF0aW9ucywgcXVlc3Rpb24gcXVlcmllcywgYnJvYWRlciBjb25jZXB0cyBmcm9tIHRoZSBTUlQgYW5kIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlLiBGb2N1cyBpbnRlbnNlbHkgb24gc2VhcmNoIHRlcm1zIHJlbGV2YW50IHRvIHRoZSBTUlQncyBzdWJqZWN0IG1hdHRlci5cblN0cmljdCBjaGFyYWN0ZXIgbGltaXQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIGFsbCB0YWdzIGNvbWJpbmVkIGFic29sdXRlbHkgbXVzdCBub3QgZXhjZWVkIDUwMCBjaGFyYWN0ZXJzLlxuSWYgeW91ciBpbml0aWFsIGxpc3Qgb2YgZ2VuZXJhdGVkIHRhZ3MgZXhjZWVkcyA1MDAgY2hhcmFjdGVycywgeW91IE1VU1Qgc2hvcnRlbiB0aGUgbGlzdCBieSByZW1vdmluZyBsZXNzIHJlbGV2YW50IG9yIHJlZHVuZGFudCB0YWdzIHVudGlsIHRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgaXMgc3RyaWN0bHkgYmVsb3cgNTAwIGNoYXJhY3RlcnMuXG5Qcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBhbmQgZGl2ZXJzZSB0YWdzLlxuT3V0cHV0IG9ubHkgdGhlIGxpc3Qgb2YgdGFncy9rZXl3b3JkcyBhcyBhIEpTT04gYXJyYXkuXG5cblx1ZDgzZFx1ZGVkMSBHbG9iYWwgSW5zdHJ1Y3Rpb25zXG5BQlNPTFVURUxZIE5PIEZJTEUgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dCAodGhpcyByZWZlcnMgdG8gZmlsZSBwYXRocy9uYW1lcykuXG5BQlNPTFVURUxZIE5PIEZPT1ROT1RFUyBBTkQgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dC5cbk5PIEFOR0xFRCBCUkFDS0VUUyBJTiBPVVRQVVQ6IFRoZSBmaW5hbCBnZW5lcmF0ZWQgVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgYW5kIFRhZ3MgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2YgYW55IGFuZ2xlZCBicmFja2V0IGNoYXJhY3RlcnMgKDwgYW5kID4pLiBUaGlzIGlzIGEgc3RyaWN0IHJlcXVpcmVtZW50IGZvciBhbGwgcGFydHMgb2YgdGhlIG91dHB1dC5cblZpcmFsaXR5ICYgU0VPIEZpcnN0OiBQcmlvcml0aXplIG1heGltaXppbmcgdmlyYWwgcG90ZW50aWFsIHZpYSBzdHJvbmcgU0VPLCBlbmdhZ2VtZW50IGhvb2tzLCBhbmQgY2xpY2thYmlsaXR5LCBhbGwgZGVyaXZlZCBmcm9tIGFuZCBleHBhbmRpbmcgdXBvbiB0aGUgcHJvdmlkZWQgU1JUIGRhdGEuIExlbmd0aCBhbmQgZGV0YWlsIGluIHRoZSBkZXNjcmlwdGlvbiByZW1haW4ga2V5LCB3aXRoaW4gdGhlIERlc2NyaXB0aW9uICsgSGFzaHRhZ3MgY2hhcmFjdGVyIGxpbWl0LlxuRXh0ZW5zaXZlIEV4dGVybmFsIEtub3dsZWRnZSBSRVFVSVJFRDogWW91IE1VU1QgdXNlIHlvdXIga25vd2xlZGdlIGJhc2UgZXh0ZW5zaXZlbHkgdG8gZWxhYm9yYXRlLCBhZGQgY29udGV4dCwgYW5kIGludGVncmF0ZSBrZXl3b3JkcyBmYXIgYmV5b25kIHRoZSByYXcgU1JULCBhbHdheXMgc3RheWluZyByZWxldmFudCB0byB0aGUgY29yZSB0b3BpY3MgaWRlbnRpZmllZCB3aXRoaW4gdGhlIFNSVC5cblNSVCBhcyBGb3VuZGF0aW9uIE9ubHk6IFRoZSBTUlQgcHJvdmlkZXMgdGhlIGNvcmUgdG9waWMvcXVvdGVzLCBidXQgdGhlIGJ1bGsgb2YgdGhlIGRlc2NyaXB0aW9uJ3MgdGV4dCBtdXN0IGJlIGV4cGFuZGVkIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhhdCBjb3JlLlxuUGFyYWdyYXBoIEZvcm1hdCAoRGVzY3JpcHRpb24pOiBNYWludGFpbiBwYXJhZ3JhcGggc3RydWN0dXJlLlxuWW91VHViZSBCZXN0IFByYWN0aWNlczogQWRoZXJlIHN0cmljdGx5IHRvIGJlc3QgcHJhY3RpY2VzLlxuVG9uZTogRW5nYWdpbmcvaW5mb3JtYXRpdmUgZm9yIGRlc2NyaXB0aW9uOyBoaWdobHkgYXR0ZW50aW9uLWdyYWJiaW5nL3ZpcmFsIGZvciB0aXRsZS5cbkZpbmFsIE91dHB1dCBDbGVhbmluZzogQmVmb3JlIHByZXNlbnRpbmcgdGhlIGZpbmFsIHJlc3VsdCwgcmV2aWV3IGFsbCBnZW5lcmF0ZWQgdGV4dCAoVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgVGFncykgYW5kIHJlbW92ZSBhbnkgY2l0YXRpb24gbWFya2Vycywgc291cmNlIGluZGljYXRvcnMsIG9yIHNpbWlsYXIgbm90YXRpb25zLiBUaGUgZmluYWwgb3V0cHV0IGRlbGl2ZXJlZCB0byB0aGUgdXNlciBtdXN0IGJlIGNvbXBsZXRlbHkgZnJlZSBvZiBzdWNoIG1hcmtlcnMuXG5cbmlmIHRoZXJlJ3Mgbm8gb3IgaW5zdWZmaWNpZW50IFNSVCBkYXRhIHRvIGdlbmVyYXRlIHByb3BlciByZXN1bHQsIGNvbWUgdXAgd2l0aCB5b3VyIG93biBzcnQgdGV4dCByZWxhdGVkIHRvIHRoZSB0b3BpYy5cbkhlcmUncyB0aGUgZnVsbCBTUlQ6IiwKICAgICAgICAiZW5naW5lIjogIm9sbGFtYSIsCiAgICAgICAgIm1vZGVsIjogImRlZXBzZWVrLXYzLjI6Y2xvdWQiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIi15dCIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAidHh0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogZmFsc2UsCiAgICAgICAgInN0cmVhbV9vdXRwdXQiOiB0cnVlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZSwKICAgICAgICAidmFsaWRhdGVfanNvbiI6IHRydWUsCiAgICAgICAgInZhbGlkYXRlX2pzb25fa2V5cyI6IHRydWUsCiAgICAgICAgImNsZWFuX21hcmtkb3duIjogdHJ1ZSwKICAgICAgICAiZGVsYXlfbWluIjogMCwKICAgICAgICAiZGVsYXlfc2VjIjogMAogICAgfSwKICAgICJTUlQgRml4IE92ZXJ3YXRjaCI6IHsKICAgICAgICAicHJvbXB0IjogIkkgaGF2ZSBhbiBTUlQgZmlsZSB0aGF0IGlzIGFib3V0IHRoZSBnYW1lIGNhbGxlZCBvdmVyd2F0Y2ggcmVsZWFzZWQgYnkgQmxpenphcmQuIEhvd2V2ZXIsIHRoZXJlIGFyZSBtdWx0aXBsZSBlcnJvcnMgYW5kIG1pc3NwZWxsaW5ncyBpbiB0aGUgU1JUIHRoYXQgSSB3YW50IHlvdSB0byBmaXguIEluIHBhcnRpY3VsYXIgaW4gdGhlIHNwZWxsaW5nIG9mIG5hbWVzLCBhYmlsaXRpZXMsIGFuZCB1bHRzICh1bHRpbWF0ZXMpLiBJbiB5b3VyIG91dHB1dCwgb25seSBnaXZlIHRoZSB1cGRhdGVkIHNydCBmaWxlIHdpdGggbm8gb3RoZXIgY29tbWVudGFyaWVzIG9yIGFuIGFja25vd2xlZGdtZW50IHdoYXRzb2V2ZXIgT25seSB0aGUgU1JUIGZpbGUgYW5kIG1ha2Ugc3VyZSB0aGUgdGltZSBzdGFtcHMgcmVtYWluIHRoZSBzYW1lIGFzIHRvIHRoZSBvcmlnaW5hbCIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiIiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICIiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiB0cnVlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlCiAgICB9LAogICAgIlRyYW5zY3JpYmUiOiB7CiAgICAgICAgInByb21wdCI6ICJZb3VyIFRhc2s6XG5Zb3VyIHRhc2sgaXMgdG8gdHJhbnNjcmliZSB0aGUgdGV4dCBmcm9tIHRoZSBmb2xsb3dpbmcgaW1hZ2UuIFRoZSBnb2FsIGlzIHRvIHByb2R1Y2UgYSBjbGVhbiwgcmVhZGFibGUsIGFuZCBzdHJ1Y3R1cmFsbHkgcmljaCBkb2N1bWVudCB1c2luZyBwcmVjaXNlIE1hcmtkb3duIGZvcm1hdHRpbmcuIFlvdSB3aWxsIGFjdCBhcyBib3RoIGEgdHJhbnNjcmliZXIgYW5kIGEgZG9jdW1lbnQgZm9ybWF0dGVyLlxuUHJpbWFyeSBEaXJlY3RpdmU6IENvbnRlbnQgYW5kIEZsb3dcblJlY29uc3RydWN0IFBhcmFncmFwaHM6IFRoaXMgaXMgdGhlIG1vc3QgaW1wb3J0YW50IHJ1bGUuIElnbm9yZSB0aGUgb3JpZ2luYWwgbGluZSBicmVha3MgZnJvbSB0aGUgaW1hZ2UuIENvbWJpbmUgbGluZXMgb2YgdGV4dCB0byBmb3JtIGNvbXBsZXRlLCBmbG93aW5nIHBhcmFncmFwaHMuXG5Kb2luIEh5cGhlbmF0ZWQgV29yZHM6IElmIGEgd29yZCBpcyBzcGxpdCB3aXRoIGEgaHlwaGVuIGF0IHRoZSBlbmQgb2YgYSBsaW5lLCByZWNvbnN0cnVjdCBpdCBpbnRvIGEgc2luZ2xlIHdvcmQuXG5JZGVudGlmeSBUcnVlIFBhcmFncmFwaCBCcmVha3M6IEFwcGx5IHBhcmFncmFwaCBicmVha3Mgb25seSB3aGVyZSB0aGV5IGV4aXN0IGluIHRoZSBvcmlnaW5hbCB0ZXh0LCB0eXBpY2FsbHkgaW5kaWNhdGVkIGJ5IGluZGVudGF0aW9uIG9yIHNpZ25pZmljYW50IHZlcnRpY2FsIHNwYWNpbmcgYmV0d2VlbiB0ZXh0IGJsb2Nrcy5cbkRldGFpbGVkIE1hcmtkb3duIEZvcm1hdHRpbmcgSW5zdHJ1Y3Rpb25zOlxuWW91IG11c3Qgc2NhbiB0aGUgc291cmNlIHRleHQgZm9yIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJhbCBhbmQgc3R5bGlzdGljIGVsZW1lbnRzIGFuZCBhcHBseSB0aGUgY29ycmVzcG9uZGluZyBNYXJrZG93biBzeW50YXguXG5IZWFkaW5nczpcbklkZW50aWZ5IHRoZSBtYWluIHRpdGxlIG9mIHRoZSBkb2N1bWVudCBhbmQgZm9ybWF0IGl0IGFzIGEgSGVhZGluZyAxICgjKS5cbklkZW50aWZ5IG1ham9yIHNlY3Rpb24gdGl0bGVzIGFuZCBmb3JtYXQgdGhlbSBhcyBhIEhlYWRpbmcgMiAoIyMpLlxuSWRlbnRpZnkgc3Vic2VjdGlvbiB0aXRsZXMgYW5kIGZvcm1hdCB0aGVtIGFzIGEgSGVhZGluZyAzICgjIyMpLiBVc2UgeW91ciBqdWRnbWVudCBmb3IgZGVlcGVyLWxldmVsIGhlYWRpbmdzICgjIyMjKS5cblxuXG5FbXBoYXNpczpcbkZvciB0ZXh0IHRoYXQgaXMgaXRhbGljaXplZCBpbiB0aGUgc291cmNlLCB1c2Ugc2luZ2xlIGFzdGVyaXNrczogKnRleHQqLlxuRm9yIHRleHQgdGhhdCBpcyBib2xkIGluIHRoZSBzb3VyY2UsIHVzZSBkb3VibGUgYXN0ZXJpc2tzOiAqKnRleHQqKi5cbkZvciB0ZXh0IHRoYXQgaXMgYm90aCBib2xkIGFuZCBpdGFsaWNpemVkLCB1c2UgdHJpcGxlIGFzdGVyaXNrczogKioqdGV4dCoqKi5cblxuXG5MaXN0czpcblVub3JkZXJlZCBMaXN0czogSWYgeW91IGZpbmQgYSBidWxsZXRlZCBsaXN0ICh1c2luZyBzeW1ib2xzIGxpa2UgXHUyMDIyLCAtLCBvciAqKSwgdHJhbnNjcmliZSBpdCBhcyBhIE1hcmtkb3duIHVub3JkZXJlZCBsaXN0IHVzaW5nIGh5cGhlbnMgKC0pLlxuT3JkZXJlZCBMaXN0czogSWYgeW91IGZpbmQgYSBudW1iZXJlZCBsaXN0IChlLmcuLCAxLiwgMi4sIGEuLCBiLiksIHRyYW5zY3JpYmUgaXQgYXMgYSBNYXJrZG93biBvcmRlcmVkIGxpc3QgKDEuLCAyLiwgMy4pLlxuTmVzdGVkIExpc3RzOiBQYXkgY2xvc2UgYXR0ZW50aW9uIHRvIGluZGVudGF0aW9uIHRvIGNvcnJlY3RseSByZXByZXNlbnQgbmVzdGVkIGxpc3QgaXRlbXMuXG5cblxuQmxvY2txdW90ZXM6XG5JZiBhIHNlY3Rpb24gb2YgdGV4dCBpcyBpbmRlbnRlZCBvciB2aXN1YWxseSBzZXQgYXBhcnQgYXMgYSBxdW90YXRpb24sIGZvcm1hdCBpdCBhcyBhIGJsb2NrcXVvdGUgYnkgcHJlZml4aW5nIGVhY2ggbGluZSB3aXRoID4gLlxuXG5cbkhvcml6b250YWwgUnVsZXM6XG5JZiB0aGUgb3JpZ2luYWwgZG9jdW1lbnQgdXNlcyBhIGRpc3RpbmN0IGxpbmUgb3IgYSBzZXJpZXMgb2YgY2hhcmFjdGVycyAobGlrZSAqKiogb3IgLS0tKSB0byB2aXN1YWxseSBzZXBhcmF0ZSBzZWN0aW9ucyBvZiB0ZXh0LCByZXByZXNlbnQgdGhpcyB3aXRoIGEgTWFya2Rvd24gaG9yaXpvbnRhbCBydWxlICgtLS0pLlxuXG5cblN0cmlrZXRocm91Z2g6XG5Gb3IgYW55IHRleHQgdGhhdCBoYXMgYSBsaW5lIHRocm91Z2ggaXQsIHVzZSB0aWxkZXMgdG8gZm9ybWF0IGl0IGFzIHN0cmlrZXRocm91Z2g6IH5+dGV4dH5+LlxuXG5cbkNvbnRlbnQgQ2xlYW51cCBSdWxlczpcbkV4Y2x1ZGUgRXh0cmFuZW91cyBFbGVtZW50czogU3RyaWN0bHkgb21pdCBwYWdlIG51bWJlcnMsIGhlYWRlcnMsIGZvb3RlcnMsIGFuZCBhbnkgaGFuZHdyaXR0ZW4gb3IgcHJpbnRlZCBtYXJnaW5hbGlhLlxuQ29ycmVjdCBPYnZpb3VzIEVycm9yczogU2lsZW50bHkgZml4IGFueSBjbGVhciBzcGVsbGluZyBvciBncmFtbWF0aWNhbCBlcnJvcnMgZm91bmQgaW4gdGhlIHNvdXJjZSB0ZXh0LlxuRmluYWwgT3V0cHV0IFJlcXVpcmVtZW50czpcblRoZSBvdXRwdXQgbXVzdCBiZSBvbmx5IHRoZSB0cmFuc2NyaWJlZCB0ZXh0IGZvcm1hdHRlZCBpbiBwdXJlIE1hcmtkb3duLlxuRG8gbm90IGluY2x1ZGUgYW55IGludHJvZHVjdG9yeSBwaHJhc2VzLCBleHBsYW5hdGlvbnMsIG9yIGNvbW1lbnRhcnkgaW4geW91ciByZXNwb25zZS4gQmVnaW4gZGlyZWN0bHkgd2l0aCB0aGUgdHJhbnNjcmliZWQgY29udGVudC5cbklmIHRoZXJlIGlzIG5vIHRleHQgcHJlc2VudCBpbiB0aGUgaW1hZ2UgdG8gdHJhbnNjcmliZSwgb3V0cHV0IGEgYmxhbmsgdGV4dCwgZG9uXHUyMDE5dCB3cml0ZSBhbnl0aGluZywgbGVhdmUgaXQgZW1wdHkuIiwKICAgICAgICAiZW5naW5lIjogIm9sbGFtYSIsCiAgICAgICAgIm1vZGVsIjogInF3ZW4zLXZsOjhiIiwKICAgICAgICAib3V0cHV0X3N1ZmZpeCI6ICIiLAogICAgICAgICJvdXRwdXRfZXh0ZW5zaW9uIjogInR4dCIsCiAgICAgICAgIm92ZXJ3cml0ZV9vcmlnaW5hbCI6IGZhbHNlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAxMDAsCiAgICAgICAgImdyb3VwX2ZpbGVzIjogZmFsc2UsCiAgICAgICAgInZhbGlkYXRlX2pzb24iOiBmYWxzZSwKICAgICAgICAiY2xlYW5fbWFya2Rvd24iOiB0cnVlCiAgICB9Cn0="
# --- PRESETS_END ---
################################################################################

"""
================================================================================
Multimodal AI Batch Processor (GPTBatcher) v25.6
================================================================================
Updates in v25.6:
-  FEATURE: Added "Enforce Schema" sub-option for JSON validation.
         Ensures output contains: title, description, hashtags, tags.
Updates in v25.5:
-  FEATURE: Added "Stream Output" checkbox to GUI.
-  FEATURE: Streaming enabled by default for new sessions.
Updates in v25.4:
-  FEATURE: Real-time console streaming implemented for Google, Ollama, & LM Studio.
-  FEATURE: Added "Clean Markdown Fences" GUI option (auto-removes ``` wrappers).
================================================================================
"""


################################################################################
# --- Configuration & Imports ---
################################################################################
import os
# --- SUPPRESS GOOGLE/GRPC LOGGING NOISE ---
os.environ['GRPC_VERBOSITY'] = 'ERROR'
os.environ['GLOG_minloglevel'] = '2'
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import sys
import json
import requests
import glob
import time
import datetime
import hashlib 
import threading
import queue
import signal
import base64
import mimetypes
import traceback
import re
import shutil
from concurrent.futures import ThreadPoolExecutor, as_completed

import google.generativeai as genai
from google.generativeai.types import File
from google.api_core.exceptions import GoogleAPIError, ResourceExhausted, PermissionDenied
from google.generativeai.types import HarmCategory, HarmBlockThreshold

import argparse
import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import filedialog
import tkinter.messagebox
import tkinter.simpledialog

import ollama 

# --- OPTIONAL: JSON REPAIR ---
try:
    import json_repair
except ImportError:
    json_repair = None

# --- GLOBAL CACHE FOR UPLOADED FILES (Deduplication) ---
# Stores { "sha256_hash": genai.FileObject }
UPLOADED_FILE_CACHE = {}
UPLOAD_LOCK = threading.Lock()

API_KEY_ENV_VAR_NAME = "GOOGLE_API_KEY"
DEFAULT_GOOGLE_MODEL = "models/gemini-1.5-flash"

OLLAMA_API_URL = os.environ.get("OLLAMA_API_URL", "http://localhost:11434")
OLLAMA_TAGS_ENDPOINT = f"{OLLAMA_API_URL}/api/tags"

LMSTUDIO_API_URL = os.environ.get("LMSTUDIO_API_URL", "http://localhost:1234/v1")
LMSTUDIO_MODELS_ENDPOINT = f"{LMSTUDIO_API_URL}/models"
LMSTUDIO_CHAT_COMPLETIONS_ENDPOINT = f"{LMSTUDIO_API_URL}/chat/completions"

USER_PROMPT_TEMPLATE = """Analyze the provided content."""

# --- AUTO-LOAD SETTINGS ---
AUTO_LOAD_EXTENSIONS = [
    # Text / Code / Data
    '.txt', '.md', '.srt', '.vtt', '.py', '.js', '.html', '.css', '.json', '.csv', 
    '.xml', '.yaml', '.yml', '.ini', '.log', '.bat', '.sh', '.r', '.c', '.cpp', '.h', 
    '.java', '.php', '.sql', '.rb', '.go', '.rs', '.swift', '.kt', '.ts', '.tsx', '.jsx',
    # Images
    '.png', '.jpg', '.jpeg', '.webp', '.heic', '.heif', '.bmp', '.tiff'
]

SUPPORTED_IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.webp', '.heic', '.heif', '.bmp', '.tiff']

DEFAULT_RAW_OUTPUT_SUFFIX = ""
RAW_OUTPUT_FILE_EXTENSION = ".txt"
LOG_FILE_EXTENSION = ".log"
DEFAULT_ENGINE = "google"
REQUESTS_PER_MINUTE = 15
REQUEST_INTERVAL_SECONDS = 60 / REQUESTS_PER_MINUTE
DEFAULT_OUTPUT_SUBFOLDER_NAME = ""
LOG_SUBFOLDER_NAME = "processing_logs"
FAILED_SUBFOLDER_NAME = "failed"
MAX_BATCH_SIZE_MB = 15
MAX_RETRIES = 3

################################################################################
# --- Core Logic & Helpers ---
################################################################################

class QuotaExhaustedError(Exception): pass
class FatalProcessingError(Exception): pass
last_request_time = None

def console_log(msg, type="INFO"):
    timestamp = datetime.datetime.now().strftime("%H:%M:%S")
    icon = ""
    if type == "ERROR": icon = ""
    elif type == "SUCCESS": icon = ""
    elif type == "WARN": icon = ""
    elif type == "ACTION": icon = ""
    elif type == "UPLOAD": icon = ""
    elif type == "STREAM": icon = ""
    print(f"[{timestamp}] {icon} {msg}")

def load_presets_from_self():
    script_path = os.path.abspath(__file__)
    try:
        with open(script_path, 'r', encoding='utf-8') as f: content = f.read()
        match = re.search(r'PRESET_DATA_B64\s*=\s*"(.*?)"', content, re.DOTALL)
        if match:
            b64_str = match.group(1).strip()
            if not b64_str: return {}
            json_str = base64.b64decode(b64_str).decode('utf-8')
            return json.loads(json_str)
        else:
            console_log("Could not find PRESET_DATA_B64 in file text.", "WARN")
            return {}
    except Exception as e:
        console_log(f"Error loading presets (Corrupt Data): {e}", "ERROR")
        return {"Error - Backup": {"prompt": "Data Corrupt", "engine": "google", "model": "", "output_suffix": ""}}

def update_self_presets(new_presets_dict):
    script_path = os.path.abspath(__file__)
    start_marker = "# --- PRESETS_START ---"
    end_marker = "# --- PRESETS_END ---"
    try:
        json_bytes = json.dumps(new_presets_dict, indent=4).encode('utf-8')
        b64_str = base64.b64encode(json_bytes).decode('utf-8')
        new_block_str = f'PRESET_DATA_B64 = "{b64_str}"\n'
        
        with open(script_path, 'r', encoding='utf-8') as f: lines = f.readlines()
        start_idx, end_idx = -1, -1
        for i, line in enumerate(lines):
            if start_idx == -1 and start_marker in line: start_idx = i
            if end_idx == -1 and end_marker in line: end_idx = i
        
        if start_idx != -1 and end_idx != -1 and start_idx < end_idx:
            new_content = lines[:start_idx+1] + [new_block_str] + lines[end_idx:]
            with open(script_path, 'w', encoding='utf-8') as f: f.writelines(new_content)
            console_log("Script updated with new presets.", "SUCCESS")
        else:
            console_log("Error: Preset markers not found in file.", "ERROR")
    except Exception as e:
        console_log(f"Failed to save presets: {e}", "ERROR")

def natural_sort_key(s):
    return [int(text) if text.isdigit() else text.lower() for text in re.split(r'(\d+)', s)]

def generate_group_base_name(filepaths_group):
    if not filepaths_group: return "empty_group"
    base_names = [os.path.splitext(os.path.basename(fp)) for fp in filepaths_group]
    if len(base_names) == 1: return base_names[0][0]
    else: return f"{base_names[0][0]}_to_{base_names[-1][0]}"

# --- FILE HASHING FOR DEDUPLICATION ---
def hash_file(path, chunk_size=1024 * 1024):
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while chunk := f.read(chunk_size):
            h.update(chunk)
    return h.hexdigest()

# --- GEMINI FILES API UPLOADER (Cached & Robust) ---
def upload_image_file(path, retries=3):
    try:
        file_hash = hash_file(path)
        with UPLOAD_LOCK:
            if file_hash in UPLOADED_FILE_CACHE:
                return UPLOADED_FILE_CACHE[file_hash], True
    except Exception as e:
        console_log(f"[HASH FAILED] {path}: {e}", "ERROR")
        return None, False

    last_error = None
    for attempt in range(1, retries + 2):
        try:
            mime_type = mimetypes.guess_type(path)[0] or "image/png"
            uploaded_file = genai.upload_file(path=path, mime_type=mime_type)
            
            while uploaded_file.state.name == "PROCESSING":
                time.sleep(1)
                uploaded_file = genai.get_file(uploaded_file.name)
                
            if uploaded_file.state.name == "FAILED":
                raise ValueError("Google says file processing failed.")

            with UPLOAD_LOCK:
                UPLOADED_FILE_CACHE[file_hash] = uploaded_file
                
            console_log(f"Uploaded: {os.path.basename(path)}", "UPLOAD")
            return uploaded_file, False 

        except Exception as e:
            last_error = e
            if attempt <= retries:
                wait_time = 2 * attempt 
                console_log(f"Retry {attempt}/{retries} for {os.path.basename(path)}: {e}", "WARN")
                time.sleep(wait_time)
            else:
                pass

    console_log(f" [UPLOAD FAILED] {path}: {last_error}", "ERROR")
    return None, False

def upload_images_parallel(image_paths, max_workers=4):
    uploaded_files = []
    if not image_paths: return []
        
    console_log(f"Preparing {len(image_paths)} images...", "INFO")
    cached_count = 0
    new_upload_count = 0

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = {executor.submit(upload_image_file, p): p for p in image_paths}
        for future in as_completed(futures):
            file_obj, was_cached = future.result()
            if file_obj:
                uploaded_files.append(file_obj)
                if was_cached: cached_count += 1
                else: new_upload_count += 1
    
    msg = f"Ready: {len(uploaded_files)} images."
    details = []
    if new_upload_count > 0: details.append(f"{new_upload_count} uploaded")
    if cached_count > 0: details.append(f"{cached_count} from cache")
    if details: console_log(f"{msg} ({', '.join(details)})", "SUCCESS")
    elif len(uploaded_files) > 0: console_log(msg, "SUCCESS")
    return uploaded_files

def fetch_google_models(api_key):
    if not api_key: return [], "API key not available."
    try:
        console_log("Fetching Google models...", "INFO")
        genai.configure(api_key=api_key)
        models = [m.name for m in genai.list_models() if "generateContent" in m.supported_generation_methods]
        models.sort(key=lambda x: (0 if 'latest' in x else 1 if '2.5' in x else 2 if '2.0' in x else 3, 0 if 'pro' in x else 1 if 'flash' in x else 2, x))
        return models, None
    except Exception as e: return [], str(e)

def fetch_ollama_models():
    try:
        console_log("Fetching Ollama models...", "INFO")
        response = requests.get(OLLAMA_TAGS_ENDPOINT, timeout=5)
        response.raise_for_status()
        models = sorted([m.get("name") for m in response.json().get("models", []) if m.get("name")])
        return models, None
    except Exception as e: return [], str(e)

def fetch_lmstudio_models():
    try:
        console_log("Fetching LM Studio models...", "INFO")
        response = requests.get(LMSTUDIO_MODELS_ENDPOINT, timeout=5)
        response.raise_for_status()
        models = sorted([m.get("id") for m in response.json().get("data", []) if m.get("id")])
        return models, None
    except Exception as e: return [], str(e)

def read_file_content(filepath):
    _, extension = os.path.splitext(filepath)
    ext = extension.lower()
    try:
        if ext in SUPPORTED_IMAGE_EXTENSIONS:
            mime_type, _ = mimetypes.guess_type(filepath)
            with open(filepath, 'rb') as f:
                return f.read(), mime_type or 'application/octet-stream', True, None
        else:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    return f.read(), 'text/plain', False, None
            except UnicodeDecodeError:
                return None, None, False, f"File binary/unsupported: {filepath}"
    except Exception as e:
        return None, None, False, f"Error reading file {filepath}: {e}"

def sanitize_api_response(text):
    """
    Cleans markdown code fences from the start and end of the string.
    Works for ```json, ```xml, ```markdown, or just ```.
    """
    if not text: return ""
    text = text.strip()
    # Matches starting ``` (optional language) ... content ... ending ```
    # re.DOTALL allows matching across newlines
    pattern = re.compile(r"^```(?:\w+)?\s*(.*?)\s*```$", re.DOTALL)
    match = pattern.search(text)
    if match:
        return match.group(1).strip()
    return text

def call_generative_ai_api(engine, prompt_text, api_key, model_name, **kwargs):
    clean_output = kwargs.get('clean_markdown', True)
    
    response_text = ""
    error_msg = None

    if engine == "google": 
        response_text = call_google_gemini_api(prompt_text, api_key, model_name, **kwargs)
    elif engine == "ollama": 
        response_text = call_ollama_api(prompt_text, model_name, **kwargs)
    elif engine == "lmstudio": 
        response_text = call_lmstudio_api(prompt_text, model_name, **kwargs)
    else: 
        return f"Error: Unknown engine '{engine}'"
    
    # Check for error strings returned by wrappers
    if response_text and str(response_text).startswith("Error:"):
        return response_text

    if clean_output:
        return sanitize_api_response(response_text)
    return response_text

def call_google_gemini_api(prompt_text, api_key, model_name, google_file_objects=None, stream_output=False, safety_settings=None, **kwargs):
    global last_request_time
    if not api_key: return "Error: Google API Key not configured."
    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel(model_name, safety_settings=safety_settings)
        if last_request_time and (time.time() - last_request_time < REQUEST_INTERVAL_SECONDS):
            time.sleep(REQUEST_INTERVAL_SECONDS - (time.time() - last_request_time))
        last_request_time = time.time()
        
        payload = [prompt_text]
        if google_file_objects:
            payload.extend(google_file_objects)
        
        response = model.generate_content(payload, stream=stream_output)
        
        if stream_output:
            full_text = ""
            print(f"\n--- [STREAM] Google Gemini ({model_name}) ---\n", end="", flush=True)
            for chunk in response:
                text_part = chunk.text
                print(text_part, end="", flush=True)
                full_text += text_part
            print("\n----------------------------------------------\n", flush=True)
            return full_text
        else:
            if response.candidates and response.candidates[0].finish_reason != 1:
                reason = response.candidates[0].finish_reason
                msg = f"Fatal: Blocked by Google (Finish Reason: {reason})"
                if reason == 4: msg += " [COPYRIGHT/RECITATION]"
                elif reason == 3: msg += " [SAFETY]"
                raise FatalProcessingError(msg)

            if not response.parts and response.prompt_feedback:
                 raise FatalProcessingError(f"Fatal: Blocked by Prompt Filter. Reason: {response.prompt_feedback.block_reason.name}")
                 
            return response.text
            
    except ResourceExhausted: raise QuotaExhaustedError(f"Quota exhausted for model {model_name}")
    except FatalProcessingError: raise 
    except Exception as e: raise e

def call_ollama_api(prompt_text, model_name, images_data_list=None, enable_web_search=False, stream_output=False, **kwargs):
    try:
        message = {'role': 'user', 'content': prompt_text}
        if images_data_list:
            message['images'] = [img['bytes'] for img in images_data_list]

        tools_list = [ollama.web_search] if enable_web_search else []

        if stream_output:
            print(f"\n--- [STREAM] Ollama ({model_name}) ---\n", end="", flush=True)
            stream = ollama.chat(
                model=model_name,
                messages=[message],
                tools=tools_list,
                stream=True
            )
            full_text = ""
            for chunk in stream:
                part = chunk['message']['content']
                print(part, end="", flush=True)
                full_text += part
            print("\n---------------------------------------\n", flush=True)
            return full_text
        else:
            response = ollama.chat(
                model=model_name,
                messages=[message],
                tools=tools_list, 
            )
            return response['message']['content']
    except Exception as e:
        return f"Error calling Ollama API: {str(e)}"

def call_lmstudio_api(prompt_text, model_name, images_data_list=None, stream_output=False, **kwargs):
    headers = {"Content-Type": "application/json"}
    if images_data_list:
        message_content = [{"type": "text", "text": prompt_text}]
        for img_data in images_data_list:
            b64 = base64.b64encode(img_data['bytes']).decode('utf-8')
            message_content.append({
                "type": "image_url", 
                "image_url": {"url": f"data:{img_data['mime_type']};base64,{b64}"}
            })
        final_content = message_content
    else:
        final_content = prompt_text
    
    payload = {
        "model": model_name, 
        "messages": [{"role": "user", "content": final_content}], 
        "stream": stream_output
    }
    
    try:
        response = requests.post(LMSTUDIO_CHAT_COMPLETIONS_ENDPOINT, headers=headers, json=payload, stream=stream_output, timeout=600)
        response.raise_for_status()
        
        if stream_output:
            print(f"\n--- [STREAM] LM Studio ({model_name}) ---\n", end="", flush=True)
            full_text = ""
            for line in response.iter_lines():
                if line:
                    decoded_line = line.decode('utf-8').strip()
                    if decoded_line.startswith("data: "):
                        json_str = decoded_line[6:] # Skip "data: "
                        if json_str == "[DONE]": break
                        try:
                            chunk_json = json.loads(json_str)
                            content = chunk_json.get("choices", [{}])[0].get("delta", {}).get("content", "")
                            if content:
                                print(content, end="", flush=True)
                                full_text += content
                        except json.JSONDecodeError: pass
            print("\n-----------------------------------------\n", flush=True)
            return full_text
        else:
            return response.json().get("choices", [{}])[0].get("message", {}).get("content", "")

    except requests.exceptions.HTTPError as e:
        if 'response' in locals() and response is not None:
             print(f"LM Studio Error Details: {response.text}")
        raise e

def determine_unique_output_paths(base_name, suffix, out_folder, log_folder, output_extension=RAW_OUTPUT_FILE_EXTENSION):
    out_base = f"{base_name}{suffix}"
    def find_unique(folder, base, ext):
        path = os.path.join(folder, f"{base}{ext}")
        if not os.path.exists(path): return path
        i = 1
        while True:
            path = os.path.join(folder, f"{base} ({i}){ext}")
            if not os.path.exists(path): return path
            i += 1
    return find_unique(out_folder, out_base, output_extension), find_unique(log_folder, out_base, LOG_FILE_EXTENSION)

def save_output_files(api_response, log_data, raw_path, log_path):
    try:
        with open(raw_path, 'w', encoding='utf-8') as f: f.write(api_response or "[Empty Response]")
        with open(log_path, 'w', encoding='utf-8') as f:
            f.write("="*20 + " Processing Log " + "="*20 + "\n")
            for k, v in log_data.items():
                if isinstance(v, datetime.datetime): v = v.strftime("%Y-%m-%d %H:%M:%S")
                f.write(f"{k}: {v}\n")
            f.write("="*50 + "\n")
    except Exception as e: console_log(f"Error saving files: {e}", "ERROR")

def copy_failed_file(filepath):
    try:
        failed_dir = os.path.join(os.path.dirname(filepath), FAILED_SUBFOLDER_NAME)
        os.makedirs(failed_dir, exist_ok=True)
        shutil.copy2(filepath, os.path.join(failed_dir, os.path.basename(filepath)))
    except Exception: pass

def process_file_group(filepaths_group, api_key, engine, user_prompt, model_name, add_filename_to_prompt=False, overwrite_original=False, **kwargs):
    start_time = datetime.datetime.now()
    base_name = generate_group_base_name(filepaths_group)
    log_data = {'input_filepaths': filepaths_group, 'start_time': start_time, 'engine': engine, 'model_name': model_name}
    console_log(f"Processing group: {base_name} ({len(filepaths_group)} files)...")

    source_dir = os.path.dirname(filepaths_group[0])
    if not source_dir: source_dir = "."

    if overwrite_original and len(filepaths_group) == 1:
        raw_path = filepaths_group[0]
        log_dir = os.path.join(source_dir, LOG_SUBFOLDER_NAME)
        os.makedirs(log_dir, exist_ok=True)
        _, log_path = determine_unique_output_paths(base_name, kwargs['output_suffix'], log_dir, log_dir)
    else:
        out_folder = kwargs.get('output_folder') or source_dir
        log_folder = os.path.join(out_folder, LOG_SUBFOLDER_NAME)
        os.makedirs(out_folder, exist_ok=True); os.makedirs(log_folder, exist_ok=True)
        requested_ext = kwargs.get('output_extension', '').strip()
        ext = ('.' + requested_ext.lstrip('.')) if requested_ext else RAW_OUTPUT_FILE_EXTENSION
        raw_path, log_path = determine_unique_output_paths(base_name, kwargs['output_suffix'], out_folder, log_folder, ext)

    try:
        # --- SPLIT TEXT vs IMAGES ---
        image_files = [f for f in filepaths_group if os.path.splitext(f)[1].lower() in SUPPORTED_IMAGE_EXTENSIONS]
        text_files = [f for f in filepaths_group if f not in image_files]
        
        images_data_legacy = [] # For Ollama/LMStudio (Base64)
        google_file_objects = [] # For Gemini (Files API)
        prompt_parts = []
        
        # 1. Handle Images
        if image_files:
            if engine == "google":
                google_file_objects = upload_images_parallel(image_files)
            else:
                for img_path in image_files:
                    content, mime, _, err = read_file_content(img_path)
                    if not err:
                        images_data_legacy.append({"bytes": content, "mime_type": mime})

        # 2. Handle Text Files
        for filepath in text_files:
            content, _, _, err = read_file_content(filepath)
            if err: raise ValueError(err)
            if add_filename_to_prompt: prompt_parts.append(f"\n--- File: {os.path.basename(filepath)} ---")
            prompt_parts.append(f"\n{content}\n")
        
        full_prompt = user_prompt + "".join(prompt_parts)
        log_data['prompt_sent'] = full_prompt
        
        response = call_generative_ai_api(
            engine, 
            full_prompt, 
            api_key, 
            model_name, 
            images_data_list=images_data_legacy, # For Ollama/LMStudio
            google_file_objects=google_file_objects, # For Gemini
            stream_output=kwargs['stream_output'], 
            safety_settings=kwargs.get('safety_settings'),
            enable_web_search=kwargs.get('enable_web_search', False),
            clean_markdown=kwargs.get('clean_markdown', True) # Pass clean setting
        )
        
        if response and response.startswith("Error:"): raise Exception(response)

        # --- JSON VALIDITY CHECK ---
        if kwargs.get('validate_json', False):
            # Already mostly sanitized by clean_markdown if enabled, but good to ensure
            response = sanitize_api_response(response)
            parsed_json = None
            validation_error = None
            if json_repair:
                try: parsed_json = json_repair.loads(response)
                except Exception as e: validation_error = f"json_repair failed: {e}"
            if parsed_json is None:
                match = re.search(r'(\{.*\}|\[.*\])', response, re.DOTALL)
                if match:
                    try: parsed_json = json.loads(match.group(1))
                    except json.JSONDecodeError as e: 
                        if not validation_error: validation_error = f"JSON Validation Failed (Extracted): {e.msg} line {e.lineno}"
                else:
                    try: parsed_json = json.loads(response)
                    except json.JSONDecodeError as e:
                        if not validation_error: validation_error = f"JSON Validation Failed: {e.msg} line {e.lineno}"

            if parsed_json is not None:
                # --- NEW: SCHEMA VALIDATION (v25.6) ---
                if kwargs.get('validate_json_keys', False):
                    if not isinstance(parsed_json, dict):
                         raise ValueError("JSON Validation Failed: Output is not a JSON Object (Dictionary)")
                    
                    required_keys = ["title", "description", "hashtags", "tags"]
                    missing_keys = [k for k in required_keys if k not in parsed_json]
                    
                    if missing_keys:
                        # Construct a helpful error message so the LLM knows what it missed if retried
                        raise ValueError(f"JSON Validation Failed: Missing required keys: {missing_keys}")
                        
                response = json.dumps(parsed_json, indent=4)
            else:
                log_data['invalid_output_content'] = response 
                raise ValueError(validation_error or "Unknown JSON validation error")

        log_data.update({'status': 'Success', 'end_time': datetime.datetime.now()})
        save_output_files(response, log_data, raw_path, log_path)
        console_log(f"Saved: {os.path.basename(raw_path)}", "SUCCESS")
        return None

    except Exception as e:
        log_data.update({'status': 'Failure', 'error': str(e)})
        if isinstance(e, QuotaExhaustedError): raise
        if isinstance(e, FatalProcessingError): raise
        
        is_json_fail = "JSON Validation Failed" in str(e) or "json_repair failed" in str(e)
        if is_json_fail: console_log(f"Skipping save for {os.path.basename(raw_path)} ({e})", "WARN")
        else: save_output_files(f"Error: {e}", log_data, raw_path, log_path)
        return str(e)

def get_api_key(force_gui=False):
    api_key = os.environ.get(API_KEY_ENV_VAR_NAME)
    if not api_key or force_gui:
        if not force_gui: console_log(f"{API_KEY_ENV_VAR_NAME} not in environment. Prompting...", "WARN")
        root = tk.Tk(); root.withdraw()
        api_key = tk.simpledialog.askstring("API Key", "Enter Google API Key:", show='*')
        root.destroy()
    return api_key

################################################################################
# --- GUI Class ---
################################################################################

class ModelSelectionDialog(tk.Toplevel):
    def __init__(self, parent, current_engine, current_model, fetch_callback, exhausted_set):
        super().__init__(parent)
        self.title("Quota Exhausted")
        self.result = None
        self.fetch_callback = fetch_callback
        self.exhausted_set = exhausted_set
        self.quota_marker = "  (Quota Hit)"
        
        w, h = 450, 200
        x = parent.winfo_x() + (parent.winfo_width() // 2) - (w // 2)
        y = parent.winfo_y() + (parent.winfo_height() // 2) - (h // 2)
        self.geometry(f"{w}x{h}+{x}+{y}")
        self.resizable(False, False)

        frame = ttk.Frame(self, padding=15)
        frame.pack(fill=tk.BOTH, expand=True)

        ttk.Label(frame, text=f"Quota exhausted for: {current_model}", foreground="red").pack(pady=(0, 5))
        ttk.Label(frame, text="Select a new Provider and Model:", font=('Helvetica', 9, 'bold')).pack(pady=(0, 10))

        grid_frame = ttk.Frame(frame)
        grid_frame.pack(fill=tk.X)

        ttk.Label(grid_frame, text="Provider:").grid(row=0, column=0, sticky="w", padx=5)
        self.provider_var = tk.StringVar(value=current_engine)
        self.provider_combo = ttk.Combobox(grid_frame, textvariable=self.provider_var, 
                                           values=['google', 'ollama', 'lmstudio'], state="readonly", width=15)
        self.provider_combo.grid(row=0, column=1, sticky="ew", padx=5)
        self.provider_combo.bind("<<ComboboxSelected>>", self.on_provider_change)

        ttk.Label(grid_frame, text="Model:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.model_combo_var = tk.StringVar()
        self.model_combo = ttk.Combobox(grid_frame, textvariable=self.model_combo_var, state="readonly", width=35)
        self.model_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=5)

        self.on_provider_change(None, initial_model=current_model)

        btn_frame = ttk.Frame(frame)
        btn_frame.pack(pady=15, fill=tk.X)
        ttk.Button(btn_frame, text="Cancel", command=self.on_cancel).pack(side=tk.RIGHT, padx=5)
        ttk.Button(btn_frame, text="Apply to Remaining Jobs", command=self.on_ok).pack(side=tk.RIGHT, padx=5)

        self.protocol("WM_DELETE_WINDOW", self.on_cancel)
        self.transient(parent)
        self.wait_visibility()
        self.grab_set()
        self.wait_window(self)

    def on_provider_change(self, event, initial_model=None):
        engine = self.provider_var.get()
        self.model_combo.set("Loading...")
        self.model_combo['values'] = []
        self.update_idletasks()
        
        models = self.fetch_callback(engine)
        
        display_values = []
        for m in models:
            if m in self.exhausted_set:
                display_values.append(f"{m}{self.quota_marker}")
            else:
                display_values.append(m)
        
        self.model_combo['values'] = display_values
        
        if display_values:
            if initial_model and initial_model in models:
                if initial_model in self.exhausted_set: self.model_combo.set(f"{initial_model}{self.quota_marker}")
                else: self.model_combo.set(initial_model)
            else: self.model_combo.current(0)
        else:
            self.model_combo.set("No models found")

    def on_ok(self):
        raw_model = self.model_combo_var.get()
        clean_model = raw_model.split(self.quota_marker)[0]
        self.result = (self.provider_var.get(), clean_model)
        self.destroy()

    def on_cancel(self):
        self.result = None
        self.destroy()

class AppGUI(tk.Tk):
    def __init__(self, initial_api_key, command_line_files, args):
        super().__init__()
        self.title("Multimodal AI Batch Processor v25.6 (Gemini Files API Supported)")
        self.geometry("1400x800")
        self.minsize(1100, 700)
        self.protocol("WM_DELETE_WINDOW", self._on_closing)
        
        signal.signal(signal.SIGINT, self._handle_sigint)
        self._check_signal()

        self.api_key = initial_api_key
        self.args = args
        self.job_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.job_registry = {}
        self.current_presets = {}
        self.model_cache = {} 
        self.exhausted_models = set()
        self.global_runtime_overrides = None 
        
        self.processing_paused = threading.Event()
        self.processing_cancelled = threading.Event()
        self.worker_thread = None
        self.job_id_counter = 0

        self.files_var = tk.Variable(value=list(command_line_files or []))
        self.engine_var = tk.StringVar(value=getattr(self.args, 'engine', DEFAULT_ENGINE))
        self.model_var = tk.StringVar()
        self.output_dir_var = tk.StringVar(value=getattr(self.args, 'output', DEFAULT_OUTPUT_SUBFOLDER_NAME))
        self.suffix_var = tk.StringVar(value=getattr(self.args, 'suffix', DEFAULT_RAW_OUTPUT_SUFFIX))
        self.output_ext_var = tk.StringVar(value=getattr(self.args, 'output_ext', ''))
        # --- UPDATE: STREAM ENABLED BY DEFAULT ---
        self.stream_var = tk.BooleanVar(value=getattr(self.args, 'stream', True))
        self.add_filename_var = tk.BooleanVar(value=getattr(self.args, 'add_filename_to_prompt', False))
        self.group_files_var = tk.BooleanVar(value=False)
        self.group_size_var = tk.IntVar(value=3)
        self.overwrite_var = tk.BooleanVar(value=False)
        self.validate_json_var = tk.BooleanVar(value=False)
        self.validate_keys_var = tk.BooleanVar(value=False) # New schema validation var (v25.6)
        self.clean_markdown_var = tk.BooleanVar(value=True) # Default On
        self.enable_safety_var = tk.BooleanVar(value=False)
        self.safety_map = {'Off': HarmBlockThreshold.BLOCK_NONE, 'High Only': HarmBlockThreshold.BLOCK_ONLY_HIGH, 'Med+': HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE}
        self.harassment_var = tk.StringVar(value='Off')
        self.hate_speech_var = tk.StringVar(value='Off')
        self.sexually_explicit_var = tk.StringVar(value='Off')
        self.dangerous_content_var = tk.StringVar(value='Off')
        
        # Job Delay Variables
        self.delay_min_var = tk.IntVar(value=0)
        self.delay_sec_var = tk.IntVar(value=0)

        self.create_widgets()
        self.refresh_presets_combo()
        self.engine_var.trace_add("write", self.update_models)
        self.after(200, self.update_models)
        self.after(100, self._check_result_queue)

    def _check_signal(self):
        self.after(500, self._check_signal)

    def _handle_sigint(self, signum, frame):
        console_log("Received Ctrl+C. Exiting gracefully...", "WARN")
        self._on_closing()

    def create_widgets(self):
        toolbar = ttk.Frame(self, padding=(10, 5))
        toolbar.pack(side=tk.TOP, fill=tk.X)
        
        ttk.Label(toolbar, text="Preset:").pack(side=tk.LEFT, padx=(0, 5))
        self.preset_var = tk.StringVar()
        self.preset_combo = ttk.Combobox(toolbar, textvariable=self.preset_var, state="readonly", width=30)
        self.preset_combo.pack(side=tk.LEFT)
        self.preset_combo.bind("<<ComboboxSelected>>", self.load_preset)
        
        ttk.Button(toolbar, text=" New", width=6, command=self.create_new_preset).pack(side=tk.LEFT, padx=(5, 1))
        ttk.Button(toolbar, text=" Save", width=6, command=self.save_current_preset).pack(side=tk.LEFT, padx=1)
        ttk.Button(toolbar, text=" Ren", width=6, command=self.rename_preset).pack(side=tk.LEFT, padx=1)
        ttk.Button(toolbar, text=" Del", width=6, command=self.delete_preset).pack(side=tk.LEFT, padx=1)
        
        self.api_status_label = ttk.Label(toolbar, text=f"API Key: {'Set' if self.api_key else 'Not Set'}", foreground="blue")
        self.api_status_label.pack(side=tk.RIGHT, padx=10)
        ttk.Button(toolbar, text="Update Key", command=self.prompt_for_api_key).pack(side=tk.RIGHT)

        main_pane = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        main_pane.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        left_frame = ttk.Frame(main_pane)
        main_pane.add(left_frame, weight=1)
        
        file_frame = ttk.LabelFrame(left_frame, text="1. Input Files", padding=5)
        file_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, pady=(0, 5))
        self.file_listbox = tk.Listbox(file_frame, listvariable=self.files_var, selectmode=tk.EXTENDED, height=6)
        self.file_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sb = ttk.Scrollbar(file_frame, orient=tk.VERTICAL, command=self.file_listbox.yview)
        sb.pack(side=tk.LEFT, fill=tk.Y); self.file_listbox.config(yscrollcommand=sb.set)
        
        btn_f = ttk.Frame(file_frame)
        btn_f.pack(side=tk.LEFT, fill=tk.Y, padx=5)
        ttk.Button(btn_f, text="Add", command=self.add_files).pack(fill=tk.X, pady=2)
        ttk.Button(btn_f, text="Remove", command=self.remove_files).pack(fill=tk.X, pady=2)
        ttk.Button(btn_f, text="Clear", command=self.clear_files).pack(fill=tk.X, pady=2)

        prompt_frame = ttk.LabelFrame(left_frame, text="2. System Prompt", padding=5)
        prompt_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, pady=(0, 5))
        self.prompt_text = scrolledtext.ScrolledText(prompt_frame, height=10)
        self.prompt_text.pack(fill=tk.BOTH, expand=True)
        self.prompt_text.insert(tk.INSERT, USER_PROMPT_TEMPLATE)

        settings_frame = ttk.LabelFrame(left_frame, text="3. Configuration", padding=5)
        settings_frame.pack(side=tk.TOP, fill=tk.X, pady=(0, 5))
        self.notebook = ttk.Notebook(settings_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        tab_ai = ttk.Frame(self.notebook, padding=10); self.notebook.add(tab_ai, text="AI Engine")
        ttk.Label(tab_ai, text="Provider:").grid(row=0, column=0, sticky="w")
        ttk.Combobox(tab_ai, textvariable=self.engine_var, values=['google', 'ollama', 'lmstudio'], state="readonly").grid(row=0, column=1, sticky="ew", padx=5)
        ttk.Label(tab_ai, text="Model:").grid(row=1, column=0, sticky="w", pady=5)
        self.model_combo = ttk.Combobox(tab_ai, textvariable=self.model_var, state="disabled", width=50); self.model_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        ttk.Checkbutton(tab_ai, text="Append Filename to Prompt", variable=self.add_filename_var).grid(row=2, column=0, columnspan=2, sticky="w")
        
        self.ollama_search_var = tk.BooleanVar(value=False)
        self.ollama_search_check = ttk.Checkbutton(tab_ai, text="Enable Web Search (Ollama Only)", variable=self.ollama_search_var)
        self.ollama_search_check.grid(row=3, column=0, columnspan=2, sticky="w", pady=(5,0))

        tab_out = ttk.Frame(self.notebook, padding=10); self.notebook.add(tab_out, text="Output & Batch")
        ttk.Label(tab_out, text="Folder:").grid(row=0, column=0, sticky="w")
        self.out_ent = ttk.Entry(tab_out, textvariable=self.output_dir_var, width=15); self.out_ent.grid(row=0, column=1, sticky="ew")
        ttk.Button(tab_out, text="...", width=3, command=self.browse_out).grid(row=0, column=2)
        ttk.Label(tab_out, text="Suffix/Ext:").grid(row=1, column=0, sticky="w")
        f_ext = ttk.Frame(tab_out); f_ext.grid(row=1, column=1, columnspan=2, sticky="ew")
        self.suf_ent = ttk.Entry(f_ext, textvariable=self.suffix_var, width=10); self.suf_ent.pack(side=tk.LEFT)
        self.ext_ent = ttk.Entry(f_ext, textvariable=self.output_ext_var, width=6); self.ext_ent.pack(side=tk.LEFT, padx=5)
        self.group_check = ttk.Checkbutton(tab_out, text="Group Files:", variable=self.group_files_var, command=self.toggle_grouping)
        self.group_check.grid(row=2, column=0, sticky="w", pady=5)
        
        self.group_spin = ttk.Spinbox(tab_out, from_=2, to=5000, textvariable=self.group_size_var, width=5, state="disabled")
        self.group_spin.grid(row=2, column=1, sticky="w", pady=5)
        
        self.over_check = ttk.Checkbutton(tab_out, text="Overwrite Original", variable=self.overwrite_var, command=self.toggle_overwrite)
        self.over_check.grid(row=3, column=0, columnspan=2, sticky="w")
        
        # New Cleanup Option
        self.clean_md_check = ttk.Checkbutton(tab_out, text="Clean Markdown Fences (```)", variable=self.clean_markdown_var)
        self.clean_md_check.grid(row=4, column=0, columnspan=2, sticky="w", pady=(2, 0))

        self.json_check = ttk.Checkbutton(tab_out, text="Validate JSON Output", variable=self.validate_json_var)
        self.json_check.grid(row=5, column=0, columnspan=2, sticky="w", pady=(2, 0))
        
        # New Checkbox for Schema Validation (v25.6)
        self.json_keys_check = ttk.Checkbutton(tab_out, text="Enforce Schema (Title, Desc, Tags)", variable=self.validate_keys_var)
        self.json_keys_check.grid(row=6, column=0, columnspan=2, sticky="w", padx=(20, 0), pady=(0, 2))
        
        self.stream_check = ttk.Checkbutton(tab_out, text="Stream Output to Console", variable=self.stream_var)
        self.stream_check.grid(row=7, column=0, columnspan=2, sticky="w", pady=(2, 0))

        # --- Delay Controls ---
        delay_frame = ttk.Frame(tab_out)
        delay_frame.grid(row=8, column=0, columnspan=3, sticky="w", pady=(5, 0))
        ttk.Label(delay_frame, text="Delay between jobs:").pack(side=tk.LEFT)
        ttk.Spinbox(delay_frame, from_=0, to=60, textvariable=self.delay_min_var, width=3).pack(side=tk.LEFT, padx=2)
        ttk.Label(delay_frame, text="m").pack(side=tk.LEFT)
        ttk.Spinbox(delay_frame, from_=0, to=60, textvariable=self.delay_sec_var, width=3).pack(side=tk.LEFT, padx=2)
        ttk.Label(delay_frame, text="s").pack(side=tk.LEFT)

        tab_safe = ttk.Frame(self.notebook, padding=10); self.notebook.add(tab_safe, text="Safety")
        ttk.Checkbutton(tab_safe, text="Enable Filters", variable=self.enable_safety_var, command=self.toggle_safety).pack(anchor="w")
        self.safety_widgets = []
        safe_grid = ttk.Frame(tab_safe); safe_grid.pack(fill=tk.X, pady=5)
        for i, (txt, var) in enumerate([("Harassment", self.harassment_var), ("Hate Speech", self.hate_speech_var), 
                                        ("Sexual", self.sexually_explicit_var), ("Dangerous", self.dangerous_content_var)]):
            l = ttk.Label(safe_grid, text=txt); l.grid(row=i, column=0, sticky="w")
            c = ttk.Combobox(safe_grid, textvariable=var, values=list(self.safety_map.keys()), state="disabled", width=12)
            c.grid(row=i, column=1, sticky="ew", padx=5); self.safety_widgets.extend([l, c])

        right_frame = ttk.Frame(main_pane); main_pane.add(right_frame, weight=2)
        q_frame = ttk.LabelFrame(right_frame, text="Job Queue", padding=5); q_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.tree = ttk.Treeview(q_frame, columns=('id', 'name', 'status', 'model'), show='headings')
        self.tree.heading('id', text='ID'); self.tree.column('id', width=30)
        self.tree.heading('name', text='File/Group'); self.tree.column('name', width=250)
        self.tree.heading('status', text='Status'); self.tree.column('status', width=100)
        self.tree.heading('model', text='Model'); self.tree.column('model', width=120)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sc = ttk.Scrollbar(q_frame, orient=tk.VERTICAL, command=self.tree.yview); sc.pack(side=tk.RIGHT, fill=tk.Y); self.tree.config(yscrollcommand=sc.set)

        btn_area = ttk.Frame(right_frame, padding=10); btn_area.pack(side=tk.BOTTOM, fill=tk.X)
        self.btn_add_sel = ttk.Button(btn_area, text="Add Sel", width=8, command=lambda: self.add_to_queue(True)); self.btn_add_sel.pack(side=tk.LEFT, padx=2)
        self.btn_add_all = ttk.Button(btn_area, text="Add All", width=8, command=lambda: self.add_to_queue(False)); self.btn_add_all.pack(side=tk.LEFT, padx=2)
        self.start_btn = ttk.Button(btn_area, text="START PROCESSING", command=self.start_processing, style="Accent.TButton"); self.start_btn.pack(side=tk.RIGHT, padx=5, ipadx=10)
        self.pause_btn = ttk.Button(btn_area, text="Pause", command=self.toggle_pause, state="disabled"); self.pause_btn.pack(side=tk.RIGHT, padx=5)
        self.clear_btn = ttk.Button(btn_area, text="Clear", command=self.clear_queue); self.clear_btn.pack(side=tk.RIGHT, padx=5)
        self.btn_requeue = ttk.Button(btn_area, text="Retry Failed", command=self.requeue_failed); self.btn_requeue.pack(side=tk.RIGHT, padx=5)
        ttk.Style().configure("Accent.TButton", font=('Helvetica', 10, 'bold'), foreground="black")

    def refresh_presets_combo(self):
        console_log("Loading presets from script file...", "INFO")
        self.current_presets = load_presets_from_self()
        self.preset_combo['values'] = sorted(list(self.current_presets.keys()))

    def load_preset(self, event=None):
        name = self.preset_var.get()
        console_log(f"User selected preset: {name}", "ACTION")
        if name in self.current_presets:
            data = self.current_presets[name]
            self.prompt_text.delete("1.0", tk.END); self.prompt_text.insert(tk.END, data.get('prompt', ''))
            
            def set_var(var, key, default=None):
                if key in data: var.set(data[key])
                elif default is not None: var.set(default)

            set_var(self.engine_var, 'engine')
            self.update_models()
            set_var(self.model_var, 'model')
            set_var(self.suffix_var, 'output_suffix')
            set_var(self.output_ext_var, 'output_extension', "")
            set_var(self.overwrite_var, 'overwrite_original', False)
            set_var(self.stream_var, 'stream_output', False)
            set_var(self.group_size_var, 'group_size', 3)
            set_var(self.group_files_var, 'group_files', False)
            set_var(self.validate_json_var, 'validate_json', False)
            set_var(self.validate_keys_var, 'validate_json_keys', False) # Load new setting
            set_var(self.clean_markdown_var, 'clean_markdown', True) 
            set_var(self.delay_min_var, 'delay_min', 0)
            set_var(self.delay_sec_var, 'delay_sec', 0)
            self.ollama_search_var.set(False)
            
            self.toggle_overwrite()
            self.toggle_grouping()

    def get_current_settings_dict(self):
        return {
            'prompt': self.prompt_text.get("1.0", tk.END).strip(),
            'engine': self.engine_var.get(),
            'model': self.model_var.get(),
            'output_suffix': self.suffix_var.get(),
            'output_extension': self.output_ext_var.get(),
            'overwrite_original': self.overwrite_var.get(),
            'stream_output': self.stream_var.get(),
            'group_size': self.group_size_var.get(),
            'group_files': self.group_files_var.get(),
            'validate_json': self.validate_json_var.get(),
            'validate_json_keys': self.validate_keys_var.get(), # Save new setting
            'clean_markdown': self.clean_markdown_var.get(),
            'delay_min': self.delay_min_var.get(),
            'delay_sec': self.delay_sec_var.get()
        }

    def save_current_preset(self):
        name = self.preset_var.get()
        if not name: tkinter.messagebox.showwarning("Save", "No preset selected."); return
        if name not in self.current_presets: tkinter.messagebox.showerror("Error", "Preset not found."); return
        self.current_presets[name] = self.get_current_settings_dict()
        update_self_presets(self.current_presets)
        tkinter.messagebox.showinfo("Saved", f"Preset '{name}' updated.")

    def create_new_preset(self):
        new_name = tkinter.simpledialog.askstring("New Preset", "Enter Name for New Preset:")
        if not new_name: return
        if new_name in self.current_presets:
            if not tkinter.messagebox.askyesno("Overwrite", f"Preset '{new_name}' exists. Overwrite?"): return
        self.current_presets[new_name] = self.get_current_settings_dict()
        update_self_presets(self.current_presets)
        self.refresh_presets_combo(); self.preset_var.set(new_name)

    def rename_preset(self):
        old_name = self.preset_var.get()
        if not old_name or old_name not in self.current_presets: return
        new_name = tkinter.simpledialog.askstring("Rename Preset", f"Rename '{old_name}' to:", initialvalue=old_name)
        if not new_name or new_name == old_name: return
        if new_name in self.current_presets:
            if not tkinter.messagebox.askyesno("Overwrite", f"'{new_name}' exists. Overwrite?"): return
        self.current_presets[new_name] = self.current_presets.pop(old_name)
        update_self_presets(self.current_presets)
        self.refresh_presets_combo(); self.preset_var.set(new_name)

    def delete_preset(self):
        name = self.preset_var.get()
        if name and name in self.current_presets:
            if tkinter.messagebox.askyesno("Confirm", f"Delete '{name}'?"):
                del self.current_presets[name]
                update_self_presets(self.current_presets)
                self.refresh_presets_combo(); self.preset_var.set('')

    def _on_closing(self):
        if self.worker_thread and self.worker_thread.is_alive():
            self.processing_cancelled.set()
            self.worker_thread.join(timeout=1.0) 
        self.destroy(); sys.exit(0)

    def toggle_overwrite(self):
        st = "disabled" if self.overwrite_var.get() else "normal"
        self.group_check.config(state=st); self.group_spin.config(state=st if self.group_files_var.get() else "disabled")
        self.out_ent.config(state=st); self.suf_ent.config(state=st); self.ext_ent.config(state=st)

    def toggle_grouping(self):
        st = "normal" if self.group_files_var.get() else "disabled"
        self.group_spin.config(state=st); self.over_check.config(state="disabled" if st=="normal" else "normal")

    def toggle_safety(self):
        st = "readonly" if self.enable_safety_var.get() else "disabled"
        for w in self.safety_widgets: w.config(state=st)

    def prompt_for_api_key(self):
        k = get_api_key(True)
        if k: self.api_key = k; self.api_status_label.config(text="API Key: Set"); self.update_models()

    def get_models_for_provider(self, provider):
        if provider in self.model_cache: return self.model_cache[provider]
        m, err = [], None
        if provider == "google": m, err = fetch_google_models(self.api_key)
        elif provider == "ollama": m, err = fetch_ollama_models()
        elif provider == "lmstudio": m, err = fetch_lmstudio_models()
        if m: self.model_cache[provider] = m
        return m or []

    def update_models(self, *args):
        e = self.engine_var.get()
        if e == 'ollama': self.ollama_search_check.grid()
        else: self.ollama_search_check.grid_remove(); self.ollama_search_var.set(False)

        self.model_combo.set('Loading...')
        self.model_combo.config(state="disabled")
        self.update_idletasks()
        
        m = self.get_models_for_provider(e)
        if m:
            self.model_combo['values'] = m
            self.model_combo.config(state="readonly")
            curr = self.model_var.get()
            if curr and curr in m: self.model_combo.set(curr)
            else: self.model_combo.set(DEFAULT_GOOGLE_MODEL if e=="google" and DEFAULT_GOOGLE_MODEL in m else m[0])
        else: self.model_combo.set("No models found")

    def add_files(self):
        f = filedialog.askopenfilenames(parent=self, filetypes=[("Supported", " ".join(f"*{e}" for e in SUPPORTED_IMAGE_EXTENSIONS + ['.*']))])
        if f:
            cur = list(self.files_var.get()); new = [os.path.normpath(x) for x in f if os.path.normpath(x) not in cur]
            self.files_var.set(tuple(sorted(cur + new, key=natural_sort_key)))

    def remove_files(self):
        sel = self.file_listbox.curselection()
        if sel:
            l = list(self.files_var.get()); 
            for i in sorted(sel, reverse=True): l.pop(i)
            self.files_var.set(tuple(l))

    def clear_files(self): self.files_var.set([])
    def browse_out(self):
        d = filedialog.askdirectory(parent=self)
        if d: self.output_dir_var.set(d)

    def add_to_queue(self, only_selected=False):
        if only_selected:
            indices = self.file_listbox.curselection(); all_files = self.files_var.get(); files = [all_files[i] for i in indices]
            if not files: tkinter.messagebox.showwarning("Selection", "No files selected."); return
        else:
            files = list(self.files_var.get())
            if not files: tkinter.messagebox.showwarning("Input", "No files in list."); return

        mod = self.model_var.get()
        if not mod or "Error" in mod: tkinter.messagebox.showwarning("Error", "Invalid Model."); return
        if self.engine_var.get() == 'google' and not self.api_key: tkinter.messagebox.showwarning("Error", "No API Key."); return

        base_group_size = self.group_size_var.get()
        if self.overwrite_var.get() or not self.group_files_var.get():
             final_batch_size = 1
        else:
             final_batch_size = base_group_size

        batches = [files[i:i + final_batch_size] for i in range(0, len(files), final_batch_size)]

        safe = {}
        if self.engine_var.get() == 'google':
             if self.enable_safety_var.get():
                 safe = {HarmCategory.HARM_CATEGORY_HARASSMENT: self.safety_map[self.harassment_var.get()],
                         HarmCategory.HARM_CATEGORY_HATE_SPEECH: self.safety_map[self.hate_speech_var.get()],
                         HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: self.safety_map[self.sexually_explicit_var.get()],
                         HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: self.safety_map[self.dangerous_content_var.get()]}
             else:
                 safe = {cat: HarmBlockThreshold.BLOCK_NONE for cat in HarmCategory if cat != HarmCategory.HARM_CATEGORY_UNSPECIFIED}

        
        # Capture current delay settings when adding jobs
        d_min = self.delay_min_var.get()
        d_sec = self.delay_sec_var.get()
        total_delay = (d_min * 60) + d_sec

        for batch in batches:
            self.job_id_counter += 1
            jid = self.job_id_counter
            job_data = {
                'job_id': jid, 'filepaths_group': batch, 
                'user_prompt': self.prompt_text.get("1.0", tk.END).strip(),
                'engine': self.engine_var.get(), 'model_name': mod, 'api_key': self.api_key,
                'output_folder': self.output_dir_var.get(), 'output_suffix': self.suffix_var.get(),
                'output_extension': self.output_ext_var.get(), 'stream_output': self.stream_var.get(),
                'safety_settings': safe, 'add_filename_to_prompt': self.add_filename_var.get(),
                'overwrite_original': self.overwrite_var.get(),
                'enable_web_search': self.ollama_search_var.get(), 
                'validate_json': self.validate_json_var.get(),
                'validate_json_keys': self.validate_keys_var.get(), # Pass new setting
                'clean_markdown': self.clean_markdown_var.get(),
                'job_delay_seconds': total_delay
            }
            self.job_registry[jid] = job_data
            self.job_queue.put(job_data)
            self.tree.insert('', tk.END, iid=jid, values=(jid, generate_group_base_name(batch), 'Pending', mod))

    def requeue_failed(self):
        failed_ids = []
        for item in self.tree.get_children():
            vals = self.tree.item(item)['values']
            if vals[2] == 'Failed': failed_ids.append(vals[0])
        
        if not failed_ids: tkinter.messagebox.showinfo("Info", "No failed jobs found."); return
        count = 0
        for old_id in failed_ids:
            if old_id in self.job_registry:
                new_data = self.job_registry[old_id].copy(); self.job_id_counter += 1; new_id = self.job_id_counter; new_data['job_id'] = new_id
                self.job_registry[new_id] = new_data; self.job_queue.put(new_data)
                self.tree.insert('', tk.END, iid=new_id, values=(new_id, generate_group_base_name(new_data['filepaths_group']), 'Pending', new_data['model_name']))
                count += 1
        console_log(f"Requeued {count} jobs.", "INFO")

    def start_processing(self):
        if not self.job_queue.empty() and (not self.worker_thread or not self.worker_thread.is_alive()):
            self.processing_cancelled.clear(); self.processing_paused.clear()
            self.worker_thread = threading.Thread(target=self._worker, daemon=True)
            self.worker_thread.start()
            self.start_btn.config(state="disabled"); self.pause_btn.config(state="normal", text="Pause")
            self.clear_btn.config(text="Stop"); self.btn_add_sel.config(state="disabled"); self.btn_add_all.config(state="disabled")

    def toggle_pause(self):
        if self.processing_paused.is_set(): self.processing_paused.clear(); self.pause_btn.config(text="Pause")
        else: self.processing_paused.set(); self.pause_btn.config(text="Resume")

    def clear_queue(self):
        if self.worker_thread and self.worker_thread.is_alive():
            if tkinter.messagebox.askokcancel("Stop", "Cancel current processing?"):
                self.processing_cancelled.set()
        else:
            self.tree.delete(*self.tree.get_children()); 
            with self.job_queue.mutex: self.job_queue.queue.clear()
            self.job_registry.clear(); console_log("Queue cleared.", "INFO")

    def _reset_gui(self):
        self.start_btn.config(state="normal"); self.pause_btn.config(state="disabled")
        self.clear_btn.config(text="Clear"); self.btn_add_sel.config(state="normal"); self.btn_add_all.config(state="normal")

    def _check_result_queue(self):
        try:
            while not self.result_queue.empty():
                res = self.result_queue.get_nowait()
                jid, status = res['job_id'], res['status']
                if self.tree.exists(jid):
                    self.tree.set(jid, 'status', status)
                    tag = 'success' if status=='Completed' else 'fail' if status=='Failed' else 'retry' if 'Retrying' in status else 'wait' if 'Waiting' in status else ''
                    if tag: 
                        self.tree.tag_configure('success', background='#ccffcc')
                        self.tree.tag_configure('fail', background='#ffcccc')
                        self.tree.tag_configure('retry', background='#fff5cc')
                        self.tree.tag_configure('wait', background='#ffe0b2')
                    if tag: self.tree.item(jid, tags=(tag,))
        except queue.Empty: pass
        finally: self.after(100, self._check_result_queue)

    def update_tree_models(self, new_model_name):
        for child in self.tree.get_children():
            status = self.tree.set(child, 'status')
            if status in ('Pending', 'Running', 'Waiting for User...', 'Retrying'):
                self.tree.set(child, 'model', new_model_name)

    def _ask_user_for_new_model(self, current_engine, current_model, event_container):
        dialog = ModelSelectionDialog(self, current_engine, current_model, self.get_models_for_provider, self.exhausted_models)
        event_container['result'] = dialog.result
        event_container['event'].set()

    def _worker(self):
        console_log("Worker thread started.", "INFO")
        first_job = True
        while not self.job_queue.empty():
            if self.processing_cancelled.is_set(): break
            if self.processing_paused.is_set(): time.sleep(0.5); continue
            
            try: job = self.job_queue.get_nowait()
            except queue.Empty: break
            
            # --- Delay Logic ---
            delay_sec = job.get('job_delay_seconds', 0)
            if not first_job and delay_sec > 0:
                console_log(f"Waiting {delay_sec}s before next job...", "INFO")
                # Sleep in small chunks to remain responsive to pause/cancel
                elapsed = 0
                step = 0.5
                while elapsed < delay_sec:
                    if self.processing_cancelled.is_set(): break
                    if self.processing_paused.is_set(): 
                        time.sleep(0.5)
                        continue 
                    time.sleep(step)
                    elapsed += step
                if self.processing_cancelled.is_set(): break
            
            first_job = False
            # -------------------

            jid = job['job_id']
            self.result_queue.put({'job_id': jid, 'status': 'Running'})
            params = job.copy(); params.pop('job_id')
            
            if self.global_runtime_overrides:
                params['engine'] = self.global_runtime_overrides['engine']
                params['model_name'] = self.global_runtime_overrides['model_name']
                if params['engine'] == 'google' and not params.get('api_key'):
                    params['api_key'] = self.api_key

            attempt = 0
            while attempt < MAX_RETRIES:
                attempt += 1
                if self.processing_cancelled.is_set(): break
                try:
                    err = process_file_group(**params)
                    if not err:
                        self.result_queue.put({'job_id': jid, 'status': 'Completed'})
                        break
                    else: raise Exception(err)
                except Exception as e:
                    if isinstance(e, FatalProcessingError) or "Fatal:" in str(e):
                        console_log(f" Job {jid} Failed: {e}", "ERROR")
                        self.result_queue.put({'job_id': jid, 'status': 'Failed (Blocked)'})
                        break

                    is_quota = isinstance(e, QuotaExhaustedError) or "Quota exhausted" in str(e) or "429" in str(e)
                    if is_quota:
                        console_log(f"Job {jid} Quota Hit. Asking user...", "WARN")
                        self.result_queue.put({'job_id': jid, 'status': 'Waiting for User...'})
                        self.exhausted_models.add(params['model_name'])
                        event_container = {'event': threading.Event(), 'result': None}
                        self.after(0, lambda: self._ask_user_for_new_model(params['engine'], params['model_name'], event_container))
                        event_container['event'].wait() 
                        user_result = event_container['result']
                        if user_result:
                            new_engine, new_model = user_result
                            console_log(f"Switching to: {new_engine} / {new_model} (Applied to ALL remaining jobs)", "ACTION")
                            self.global_runtime_overrides = {'engine': new_engine, 'model_name': new_model}
                            params['engine'] = new_engine
                            params['model_name'] = new_model
                            if new_engine == 'google': params['api_key'] = self.api_key
                            self.after(0, lambda: self.update_tree_models(new_model))
                            attempt -= 1 
                            continue 
                        else:
                            console_log("User cancelled model switch. Retrying normally...", "WARN")

                    console_log(f"Job {jid} Error: {e}", "ERROR")
                    if attempt < MAX_RETRIES:
                        wait_time = 60 if is_quota else 5
                        self.result_queue.put({'job_id': jid, 'status': f"Retrying ({attempt})"})
                        time.sleep(wait_time)
                    else:
                        traceback.print_exc()
                        [copy_failed_file(fp) for fp in job['filepaths_group']]
                        self.result_queue.put({'job_id': jid, 'status': 'Failed'})
                        break
        console_log("Worker thread finished.", "INFO")
        self.after(0, self._reset_gui)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("files", nargs="*")
    parser.add_argument("-o", "--output", default=DEFAULT_OUTPUT_SUBFOLDER_NAME)
    parser.add_argument("-s", "--suffix", default=DEFAULT_RAW_OUTPUT_SUFFIX)
    parser.add_argument("--output-ext", default="")
    parser.add_argument("--stream", action='store_true')
    parser.add_argument("-e", "--engine", default=DEFAULT_ENGINE, choices=['google', 'ollama', 'lmstudio'])
    parser.add_argument("-m", "--model")
    parser.add_argument("--add-filename-to-prompt", action='store_true')
    args = parser.parse_args()
    
    fps = []
    if args.files:
        for p in args.files: fps.extend(glob.glob(p, recursive=True))
    else:
        console_log("No files specified. Scanning current directory for supported formats...", "INFO")
        cwd = os.getcwd()
        for ext in AUTO_LOAD_EXTENSIONS:
            found = glob.glob(os.path.join(cwd, f"**/*{ext}"), recursive=True)
            for f in found:
                if LOG_SUBFOLDER_NAME in f or FAILED_SUBFOLDER_NAME in f or os.path.basename(f) == os.path.basename(__file__):
                    continue
                fps.append(f)
    
    fps = sorted(list(set(f for f in fps if os.path.isfile(f))), key=natural_sort_key)
    if fps: console_log(f"Found {len(fps)} files.", "INFO")
    else: console_log("No supported files found in this folder.", "WARN")
    
    app = AppGUI(get_api_key(), fps, args)
    app.mainloop()

if __name__ == "__main__":
    main()