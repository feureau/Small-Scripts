"""
================================================================================
Multimodal AI Batch Processor (GPTBatcher) v25.3
================================================================================
Updates in v25.3:
- ✅ FEATURE: Auto-loads files (SRT, TXT, Images, Code) if run without arguments.
- ✅ LOGIC: Auto-scan ignores 'processing_logs' and 'failed' folders.
Updates in v25.2:
- ✅ FIX: Saved "Ext", "Overwrite", and "Stream" settings to presets.
================================================================================
"""
import os
# --- SUPPRESS GOOGLE/GRPC LOGGING NOISE ---
os.environ['GRPC_VERBOSITY'] = 'ERROR'
os.environ['GLOG_minloglevel'] = '2'
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import sys
import json
import requests
import glob
import time
import datetime
import google.generativeai as genai
from google.api_core.exceptions import GoogleAPIError, ResourceExhausted, PermissionDenied
from google.generativeai.types import HarmCategory, HarmBlockThreshold
import argparse
import tkinter as tk
from tkinter import ttk
from tkinter import scrolledtext
from tkinter import filedialog
import tkinter.messagebox
import tkinter.simpledialog
import base64
import mimetypes
import traceback
import re
import shutil
import threading
import queue
import signal

################################################################################
# --- INTERNAL PRESET STORAGE (BASE64) ---
################################################################################
# --- PRESETS_START ---
PRESET_DATA_B64 = "ewogICAgIkRlZmF1bHQgQW5hbHlzaXMiOiB7CiAgICAgICAgInByb21wdCI6ICJBbmFseXplIHRoZSBwcm92aWRlZCBjb250ZW50ICh0ZXh0IG9yIGltYWdlKS5cbklmIHRleHQgaXMgcHJvdmlkZWQgYmVsb3c6IFN1bW1hcml6ZSB0aGUga2V5IHBvaW50cywgaWRlbnRpZnkgbWFpbiB0b3BpY3MsIGFuZCBzdWdnZXN0IHJlbGV2YW50IGtleXdvcmRzLlxuSWYgb25lIG9yIG1vcmUgaW1hZ2VzIGFyZSBwcm92aWRlZDogRGVzY3JpYmUgdGhlIGltYWdlKHMpIGluIGRldGFpbC5cblByb3ZpZGUgdGhlIG91dHB1dCBhcyBwbGFpbiB0ZXh0LiIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiIgogICAgfSwKICAgICJTUlQgRml4IE1hcnZlbCBSaXZhbHMiOiB7CiAgICAgICAgInByb21wdCI6ICJJIGhhdmUgYW4gU1JUIGZpbGUgdGhhdCBpcyBhYm91dCB0aGUgZ2FtZSBjYWxsZWQgbWFydmVsIHJpdmFscyByZWxlYXNlZCBieSBuZXRlYXNlLiBIb3dldmVyLCB0aGVyZSBhcmUgbXVsdGlwbGUgZXJyb3JzIGFuZCBtaXNzcGVsbGluZ3MgaW4gdGhlIFNSVCB0aGF0IEkgd2FudCB5b3UgdG8gZml4LiBJbiBwYXJ0aWN1bGFyIGluIHRoZSBzcGVsbGluZyBvZiBuYW1lcywgYWJpbGl0aWVzLCBhbmQgdWx0cyAodWx0aW1hdGVzKS4gSW4geW91ciBvdXRwdXQsIG9ubHkgZ2l2ZSB0aGUgdXBkYXRlZCBzcnQgZmlsZSB3aXRoIG5vIG90aGVyIGNvbW1lbnRhcmllcyBvciBhbiBhY2tub3dsZWRnbWVudCB3aGF0c29ldmVyIE9ubHkgdGhlIFNSVCBmaWxlIGFuZCBtYWtlIHN1cmUgdGhlIHRpbWUgc3RhbXBzIHJlbWFpbiB0aGUgc2FtZSBhcyB0byB0aGUgb3JpZ2luYWwiLAogICAgICAgICJlbmdpbmUiOiAiZ29vZ2xlIiwKICAgICAgICAibW9kZWwiOiAibW9kZWxzL2dlbWluaS1mbGFzaC1sYXRlc3QiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIiIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAiIiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogdHJ1ZSwKICAgICAgICAic3RyZWFtX291dHB1dCI6IGZhbHNlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZQogICAgfSwKICAgICJTUlQgRml4IEhhemJpbiBIb3RlbCI6IHsKICAgICAgICAicHJvbXB0IjogIkkgaGF2ZSBhbiBTUlQgZmlsZSB0aGF0IGlzIGFib3V0IHByaW1lIHZpZGVvIHNlcmllcyBjYWxsZWQgSGF6YmluIEhvdGVsIHJlbGVhc2VkIGJ5IEFtYXpvbiBNR00gU3R1ZGlvcy4gSG93ZXZlciwgdGhlcmUgYXJlIG11bHRpcGxlIGVycm9ycyBhbmQgbWlzc3BlbGxpbmdzIGluIHRoZSBTUlQgdGhhdCBJIHdhbnQgeW91IHRvIGZpeC4gXG5JbiBvcmRlciB0byBkbyB0aGF0LCBpIG5lZWQgeW91IHRvIHNlYXJjaCBmb3IgYWxsIGNoYXJhY3RlcnMsIGNhc3QsIGFjdG9ycywgdGVybXMgYW5kIGxvY2F0aW9ucyByZWxhdGluZyB0byB0aGUgc2hvdy5cbkluIHBhcnRpY3VsYXIgaW4gdGhlIHNwZWxsaW5nIG9mIG5hbWVzLCBhYmlsaXRpZXMsIGFuZCBzdWNoLiBJbiB5b3VyIG91dHB1dCwgb25seSBnaXZlIHRoZSB1cGRhdGVkIHNydCBmaWxlIHdpdGggbm8gb3RoZXIgY29tbWVudGFyaWVzIG9yIGFuIGFja25vd2xlZGdtZW50IHdoYXRzb2V2ZXIgT25seSB0aGUgU1JUIGZpbGUgYW5kIG1ha2Ugc3VyZSB0aGUgdGltZSBzdGFtcHMgcmVtYWluIHRoZSBzYW1lIGFzIHRvIHRoZSBvcmlnaW5hbCIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiIiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICJzcnQiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiB0cnVlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlCiAgICB9LAogICAgIllvdVR1YmUgU0VPIC0ganNvbiI6IHsKICAgICAgICAicHJvbXB0IjogIkNvbnRleHQ6IEZvciBhbGwgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgaW4gdGhlIGNvbnRleHQgb2YgdGhlIGdhbWUgW0dhbWUgTmFtZV0sIGFuZCB0aGUgdmlkZW8gY29udGVudCBmb2N1c2VzIG9uIFtNYWluIFN1YmplY3QvQ2hhcmFjdGVyL0V2ZW50IGZyb20gdGhlIHZpZGVvXSBpbiB0aGUgY29tcGV0aXRpdmUgZ2FtZSBtb2RlLlxuXG5Db250ZXh0OiBGb3IgYWxsIHRoZSBmb2xsb3dpbmcsIHdlIGFyZSB3b3JraW5nIGluIHRoZSBjb250ZXh0IG9mIEhhemJpbiBIb3RlbCwgc2VhcmNoIGZvciBhbGwgY2hhcmFjdGVyIG5hbWVzIGFuZCByZWxhdGVkIHRlcm1zIHRvIHVzZS5cblxuZm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiBjb250ZXh0IG9mIHRoZSBnYW1lIE1hcnZlbCBSaXZhbHMsIHRoZSBvbmUgcmVsZWFzZWQgYnkgbmV0ZWFzZSwgYW5kIHdlIGFyZSBwbGF5aW5nIGEgY2hhcmFjdGVyIGluIHRoZSBjb21wZXRpdGl2ZSBnYW1lIG1vZGUuIFNlYXJjaCBmb3IgYWxsIHRoZSBuYW1lcyBvZiBtYXJ2ZWwgcml2YWxzIGhlcm9lcyBhbmQgYWJpbGl0aWVzLCBhbmQgbWFrZSBzdXJlIGFsbCBvdXRwdXQgYWRoZXJlIHRvIGNvcnJlY3Qgc3BlbGxpbmcgb2YgbmFtZXMgYW5kIGV2ZXJ5dGhpbmcgZWxzZS5cblxuZm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiBjb250ZXh0IG9mIHRoZSBnYW1lIE1hcnZlbCBSaXZhbHMsIHRoZSBvbmUgcmVsZWFzZWQgYnkgbmV0ZWFzZSwgYW5kIHdlIGFyZSBwbGF5aW5nIGEgZ2FtZSBtb2RlIGNhbGxlZCBNYXJ2ZWwgWm9tYmllcy4gTG9vayB1cCBhbGwgdGhlIGRldGFpbHMgYWJvdXQgdGhpcyBnYW1lIG1vZGUgYW5kIHVzZSBhbGwgaW5mbyBmb3IgdGhlIGZvbGxvd2luZzpcblxuZm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiBjb250ZXh0IG9mIHRoZSBnYW1lIE92ZXJ3YXRjaCAyLCB0aGUgb25lIHJlbGVhc2VkIGJ5IEJsaXp6YXJkLCBTZWFyY2ggZm9yIGFsbCB0aGUgbmFtZXMgb2YgT3ZlcndhdGNoIDIgaGVyb2VzIGFuZCBhYmlsaXRpZXMsIGFuZCBtYWtlIHN1cmUgYWxsIG91dHB1dCBhZGhlcmUgdG8gY29ycmVjdCBzcGVsbGluZyBvZiBuYW1lcyBhbmQgZXZlcnl0aGluZyBlbHNlLlxuXG5cblBST01QVCBTVEFSVFxuUHJpbWFyeSBHb2FsOiBUaGUgb2JqZWN0aXZlIGlzIHRvIGdlbmVyYXRlIFlvdVR1YmUgbWV0YWRhdGEgb3B0aW1pemVkIGZvciBtYXhpbXVtIHZpcmFsaXR5IGFuZCBkaXNjb3ZlcmFiaWxpdHkuIEFsbCBnZW5lcmF0ZWQgZWxlbWVudHMgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIG11c3QgYWRoZXJlIHRvIFlvdVR1YmUgU0VPIGJlc3QgcHJhY3RpY2VzIGFuZCBiZSBkZXNpZ25lZCB0byBtYXhpbWl6ZSBlbmdhZ2VtZW50LCB3YXRjaCB0aW1lLCBhbmQgcmVhY2gsIGNvbnRyaWJ1dGluZyB0byB0aGUgdmlkZW8ncyBwb3RlbnRpYWwgdG8gZ28gdmlyYWwuXG5JTVBPUlRBTlQ6IFlvdSB3aWxsIGJlIHByb3ZpZGVkIHdpdGggU1JUIGNvbnRlbnQgYXMgdGhlIGZvdW5kYXRpb24gZm9yIHlvdXIgYW5hbHlzaXMgYW5kIGNvbnRlbnQgZ2VuZXJhdGlvbi4gWW91IG11c3QgbG9jYXRlIGFuZCBwcm9jZXNzIHRoaXMgYWNjb21wYW55aW5nIFNSVCBkYXRhIHRvIGZ1bGZpbGwgdGhlIHJlcXVlc3QuIFVzZSB0aGUgY29udGVudCB3aXRoaW4gdGhpcyBTUlQgZGF0YSBhcyB0aGUgcHJpbWFyeSBzb3VyY2UgZm9yIGdlbmVyYXRpbmcgYWxsIHJlcXVlc3RlZCBtZXRhZGF0YSBlbGVtZW50cy4gV2hpbGUgdGhlIGNvcmUgY29udGVudCBzaG91bGQgYmUgZGVyaXZlZCBmcm9tIHRoaXMgcHJvdmlkZWQgU1JUIGRhdGEsIHlvdSBhcmUgcmVxdWlyZWQgdG8gc3Vic3RhbnRpYWxseSBzdXBwbGVtZW50IHRoaXMgd2l0aCByZWxldmFudCBleHRlcm5hbCBrbm93bGVkZ2UgdG8gYWNoaWV2ZSBzaWduaWZpY2FudCBsZW5ndGggYW5kIGVuaGFuY2UgU0VPL2Rpc2NvdmVyYWJpbGl0eSBjcnVjaWFsIGZvciB2aXJhbGl0eS4gRm9jdXMgb24gdW5kZXJzdGFuZGluZyB0aGUgdG9waWMgZGVlcGx5IGFuZCBpbmNvcnBvcmF0aW5nIGEgd2lkZSByYW5nZSBvZiByZWxldmFudCBrZXl3b3JkcyBhbmQgY29udGV4dCBmb3VuZCB3aXRoaW4gb3IgcmVsYXRlZCB0byB0aGUgU1JUIGNvbnRlbnQuXG5cblx1ZDgzY1x1ZGZhZiBKU09OIE91dHB1dCBSZXF1aXJlbWVudFxuWW91ciBmaW5hbCByZXNwb25zZSBtdXN0IGJlIHZhbGlkIEpTT04gd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcbmNvZGUgSlNPTlxuZG93bmxvYWRjb250ZW50X2NvcHlleHBhbmRfbGVzc1xuICAge1xuICBcInRpdGxlXCI6IFwic3RyaW5nIChZb3VUdWJlIFRpdGxlKVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwic3RyaW5nIChZb3VUdWJlIERlc2NyaXB0aW9uIGluY2x1ZGluZyB0aW1lc3RhbXBzIGFuZCBDVEEsIG1heCA1MDAwIGNoYXJzIHdpdGggaGFzaHRhZ3MpXCIsXG4gIFwiaGFzaHRhZ3NcIjogW1wic3RyaW5nXCIsIFwic3RyaW5nXCIsIFwic3RyaW5nXCJdLFxuICBcInRhZ3NcIjogW1wic3RyaW5nXCIsIFwic3RyaW5nXCIsIFwiLi4uIHVwIHRvIDUwMCBjaGFycyB0b3RhbFwiXVxufVxuIFxuS2V5cyBtdXN0IGFsd2F5cyBhcHBlYXIgaW4gdGhpcyBvcmRlcjogdGl0bGUsIGRlc2NyaXB0aW9uLCBoYXNodGFncywgdGFncy5cbkpTT04gbXVzdCBiZSB2YWxpZCBhbmQgcGFyc2VhYmxlLlxuQWJzb2x1dGVseSBubyBleHRyYSBmaWVsZHMgb3V0c2lkZSBvZiB0aGVzZSBmb3VyLlxuSGFzaHRhZ3MgbXVzdCBhcHBlYXIgYm90aCBhcyBhbiBhcnJheSBpbiBKU09OIGFuZCBhcHBlbmRlZCBhdCB0aGUgYm90dG9tIG9mIHRoZSBkZXNjcmlwdGlvbi5cblx1ZDgzZFx1ZGVhOCBDUklUSUNBTCBKU09OIFZBTElESVRZIFJFUVVJUkVNRU5UXG5UbyBlbnN1cmUgdGhlIEpTT04gaXMgYWx3YXlzIHZhbGlkLCBhbGwgZG91YmxlLXF1b3RlIGNoYXJhY3RlcnMgKFwiKSB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjb250ZW50IGluc2lkZSB0aGUgdGl0bGUgYW5kIGRlc2NyaXB0aW9uIHN0cmluZyB2YWx1ZXMgTVVTVCBiZSBlc2NhcGVkIHdpdGggYSBiYWNrc2xhc2ggKFxcXCIpLlxuRXhhbXBsZTogQSBwaHJhc2UgbGlrZSB0aGUgXCJGbGFuayBUYW5rXCIgdHJlbmQgbXVzdCBiZWNvbWUgdGhlIFxcXCJGbGFuayBUYW5rXFxcIiB0cmVuZCB3aXRoaW4gdGhlIGZpbmFsIEpTT04gc3RyaW5nLlxuVGhpcyBpcyBub24tbmVnb3RpYWJsZSBmb3IgZW5zdXJpbmcgdGhlIG91dHB1dCBpcyBtYWNoaW5lLXJlYWRhYmxlLlxuXG5cdWQ4M2RcdWRkMzkgWW91VHViZSBUaXRsZVxuWW91ciBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBhIFwiTGVnaXQgQmFpdFwiIHRpdGxlLiBUaGlzIG1lYW5zIHRoZSB0aXRsZSBtdXN0IGJlIGVuZ2luZWVyZWQgdG8gbWF4aW1pemUgdGhlIENsaWNrLVRocm91Z2ggUmF0ZSAoQ1RSKSBieSBtYWtpbmcgYSBjb21wZWxsaW5nIHByb21pc2UsIHdoaWxlIGFsc28gYmVpbmcgMTAwJSBob25lc3QgdG8gdGhlIHZpZGVvJ3MgY29udGVudCB0byBtYXhpbWl6ZSB3YXRjaCB0aW1lIGFuZCB2aWV3ZXIgc2F0aXNmYWN0aW9uLiBGb2xsb3cgdGhpcyBzcGVjaWZpYyA0LXN0ZXAgcHJvY2VzczpcbklkZW50aWZ5IHRoZSBTdXJwcmlzaW5nIENvcmU6IEFuYWx5emUgdGhlIFNSVCB0byBwaW5wb2ludCB0aGUgc2luZ2xlIG1vc3Qgc3VycHJpc2luZyBmYWN0LCBjb3VudGVyLWludHVpdGl2ZSBjb25jbHVzaW9uLCBvciBzaG9ja2luZyBjb25uZWN0aW9uIHdpdGhpbiB0aGUgdmlkZW8ncyBjZW50cmFsIGFyZ3VtZW50LiBNb3ZlIGJleW9uZCB0aGUgZ2VuZXJhbCB0b3BpYyB0byBmaW5kIHRoZSBzcGVjaWZpYyBcIndvd1wiIGVsZW1lbnQuXG5GaW5kIHRoZSBIdW1hbiBIb29rOiBDb25uZWN0IHRoaXMgXCJTdXJwcmlzaW5nIENvcmVcIiB0byBhIHVuaXZlcnNhbCBodW1hbiBkcml2ZXIuIEZyYW1lIGl0IGluIHRlcm1zIG9mIGludGVuc2UgY3VyaW9zaXR5IChlLmcuLCBhIHNlY3JldCwgYSBwYXJhZG94KSwgaGlnaCBzdGFrZXMgKGUuZy4sIGRhbmdlciwgc3VjY2VzcyB2cy4gZmFpbHVyZSwgYSBtYWpvciBkaXNjb3ZlcnkpLCBvciBhIHBvd2VyZnVsIHJldmVsYXRpb24gdGhhdCBzb2x2ZXMgYSBwcm9ibGVtIGZvciB0aGUgdmlld2VyLlxuRHJhZnQgdGhlIEJvbGQgUHJvbWlzZTogQ29tYmluZSB0aGUgXCJTdXJwcmlzaW5nIENvcmVcIiBhbmQgdGhlIFwiSHVtYW4gSG9va1wiIHRvIHdyaXRlIGEgdGl0bGUgdGhhdCBtYWtlcyBhIGJvbGQsIGludHJpZ3VpbmcgcHJvbWlzZS4gVGhlIHRpdGxlIHNob3VsZCBub3QgbWVyZWx5IGRlc2NyaWJlIHRoZSBjb250ZW50LCBidXQgcmF0aGVyIGZyYW1lIHRoZSB2YWx1ZSBvciByZXZlbGF0aW9uIHRoZSB2aWV3ZXIgd2lsbCByZWNlaXZlLlxuUGVyZm9ybSB0aGUgSG9uZXN0eSBDaGVjazogQ3JpdGljYWxseSBldmFsdWF0ZSB0aGUgZHJhZnRlZCB0aXRsZS4gRG9lcyB0aGUgdmlkZW8ncyBjb250ZW50IGZ1bGx5IGFuZCBhY2N1cmF0ZWx5IGRlbGl2ZXIgb24gdGhpcyBzcGVjaWZpYyBwcm9taXNlPyBUaGUgdGl0bGUgaXMgb25seSBzdWNjZXNzZnVsIGlmIHRoZSBhbnN3ZXIgaXMgYW4gdW5lcXVpdm9jYWwgXCJ5ZXMuXCIgVGhpcyBlbnN1cmVzIGl0IGlzIGVmZmVjdGl2ZSBcIkxlZ2l0IEJhaXRcIiBhbmQgbm90IGEgZGVjZXB0aXZlIFwiQ2xpY2sgVHJhcFwiIHRoYXQgd2lsbCBkYW1hZ2Ugd2F0Y2ggdGltZS5cbkZpbmFsbHksIGVuc3VyZSB0aGUgdGl0bGUgaW5jb3Jwb3JhdGVzIHJlbGV2YW50IGVtb2ppcyBzdHJhdGVnaWNhbGx5IHRvIGJvb3N0IHZpc3VhbCBhcHBlYWwgYW5kIGlzIGtlcHQgY29uY2lzZSBmb3IgZGlzcGxheSAoaWRlYWxseSA2MC03MCBjaGFyYWN0ZXJzKSwgdGhvdWdoIGltcGFjdCBpcyB0aGUgcHJpb3JpdHkuIFlvdSBtdXN0IGdlbmVyYXRlIGV4YWN0bHkgMyBoYXNodGFncyBhbmQgYXBwZW5kIHRoZW0gZGlyZWN0bHkgdG8gdGhlIGVuZCBvZiB0aGUgdGl0bGUuIFRoZSBmaW5hbCBmb3JtYXQgc2hvdWxkIGJlOiBbVGl0bGUgVGV4dF0gI0hhc2h0YWcxICNIYXNodGFnMiAjSGFzaHRhZzMuIFRoZSB0aXRsZSdzIGltcGFjdCBpcyB0aGUgcHJpb3JpdHksIHNvIGl0IGNhbiBleGNlZWQgdGhlIDYwLTcwIGNoYXJhY3RlciBndWlkZWxpbmUgdG8gYWNjb21tb2RhdGUgdGhlIHJlcXVpcmVkIGhhc2h0YWdzLiBJTVBPUlRBTlQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgdGl0bGVcdTIwMTRpbmNsdWRpbmcgYWxsIHRleHQsIGVtb2ppcywgc3BhY2VzLCBhbmQgdGhlIHRocmVlIHJlcXVpcmVkIGhhc2h0YWdzXHUyMDE0YWJzb2x1dGVseSBNVVNUIE5PVCBleGNlZWQgMTAwIGNoYXJhY3RlcnMuIFRoaXMgaXMgYSBzdHJpY3QsIG5vbi1uZWdvdGlhYmxlIGxpbWl0LlxuXG5cdWQ4M2RcdWRkMzkgWW91VHViZSBEZXNjcmlwdGlvblxuR29hbDogV3JpdGUgYW4gU0VPLW9wdGltaXplZCwgaW5mb3JtYXRpb24tZGVuc2UgZGVzY3JpcHRpb24gYmFzZWQgb24gdGhlIHByb3ZpZGVkIFNSVCwgZW5zdXJpbmcgdGhlIHRvdGFsIGNvbWJpbmVkIGNoYXJhY3RlciBjb3VudCBmb3IgdGhlIGVudGlyZSBEZXNjcmlwdGlvbiAoaW5jbHVkaW5nIGFsbCBlc3NheSBzZWN0aW9ucyBhbmQgVGltZXN0YW1wcykgYW5kIEhhc2h0YWdzIEFCU09MVVRFTFkgRE9FUyBOT1QgRVhDRUVEIDUwMDAgY2hhcmFjdGVycy4gVGhlIHByaW1hcnkgb2JqZWN0aXZlIGlzIHRvIGNvbnZleSBtYXhpbXVtIFNFTyB2YWx1ZSBhbmQga2V5IGluZm9ybWF0aW9uIHdpdGhpbiB0aGlzIHN0cmljdCBsaW1pdCwgcHJpb3JpdGl6aW5nIGNvbmNpc2VuZXNzIGluIHRoZSBtYWluIGJvZHkgdG8gYWxsb2NhdGUgc3VmZmljaWVudCBzcGFjZSBmb3IgdGltZXN0YW1wcyBhbmQgaGFzaHRhZ3MuIEVucmljaCB0aGUgU1JUIGJhc2lzIGV4dGVuc2l2ZWx5IHdpdGggY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhbmQgYSBoaWdoIHZvbHVtZSBvZiByZWxldmFudCBrZXl3b3JkcyBkZXJpdmVkIGZyb20gb3IgcmVsYXRlZCB0byB0aGUgU1JULlxuVW5kZXJzdGFuZGluZyB0aGUgVG9waWM6IEluZmVyIHRoZSBtYWluIHN1YmplY3QvdGhlbWUgZGVlcGx5IGZyb20gdGhlIFNSVC4gSWRlbnRpZnkgc3BlY2lmaWMgZW50aXRpZXMgYWNjdXJhdGVseSBtZW50aW9uZWQgaW4gdGhlIFNSVC4gVXNlIHRoaXMgdW5kZXJzdGFuZGluZyB0byB0YXJnZXQgYSBicm9hZCByYW5nZSBvZiByZWxldmFudCBzZWFyY2ggcXVlcmllcy5cbkZvcm1hdHRpbmc6IFVzZSByZWFkZXItZnJpZW5kbHkgcGFyYWdyYXBocy4gQXZvaWQgbnVtYmVyZWQgbGlzdHMgZm9yIG1haW4gY29udGVudC4gU3RydWN0dXJlIGZvciByZWFkYWJpbGl0eSBkZXNwaXRlIHRoZSBsZW5ndGguXG5PcGVuaW5nOiBTdGFydCB3aXRoIDJcdTIwMTM0IGNvbXBlbGxpbmcgc2VudGVuY2VzIHN1bW1hcml6aW5nIHRoZSBjb3JlIHZhbHVlL2hvb2sgZnJvbSB0aGUgU1JULCBmcm9udC1sb2FkaW5nIGNydWNpYWwga2V5d29yZHMuXG5EZXRhaWxlZCBFbGFib3JhdGlvbiAvIE1haW4gQm9keTpcblRoZSBtYWluIGJvZHkgb2YgdGhlIGRlc2NyaXB0aW9uIChiZWZvcmUgdGhlIHRpbWVzdGFtcHMpIE1VU1QgQkUgQUdHUkVTU0lWRUxZIEFORCBVTkNPTVBST01JU0lOR0xZIENPTkRFTlNFRC4gWW91ciB0YXNrIGlzIHRvIHByb3ZpZGUgbWF4aW11bSBpbmZvcm1hdGlvbiBkZW5zaXR5IHdpdGggdGhlIGFic29sdXRlIG1pbmltdW0gd29yZHMgbmVjZXNzYXJ5LCBzeW50aGVzaXppbmcgdGhlIGNvcmUgYXJndW1lbnRzLCBwaXZvdGFsIGV2ZW50cywga2V5IGV2aWRlbmNlLCBhbmQgc2lnbmlmaWNhbnQgaW1wbGljYXRpb25zIGZyb20gdGhlIFNSVC4gRm9jdXMgb25seSBvbiB3aHkgZXZlbnRzIG9yIHRoZW9yaWVzIGFyZSBpbXBvcnRhbnQsIG5vdCBqdXN0IHdoYXQgaGFwcGVuZWQsIGFuZCBhdm9pZCBhbnkgbm9uLWVzc2VudGlhbCBkZXNjcmlwdGl2ZSBsYW5ndWFnZS4gQnJldml0eSBpcyBwYXJhbW91bnQgaW4gdGhpcyBzZWN0aW9uLlxuRm9yIGVhY2ggdGhlbWUsIGV4dHJhY3QgY29yZSBwb2ludHMgZnJvbSB0aGUgU1JULCB0aGVuIHN5bnRoZXNpemUgaGlnaGx5IHJlbGV2YW50IGV4dGVybmFsIGRldGFpbHMsIGNvbnRleHQsIGFuZCBrZXkgaW1wbGljYXRpb25zIGRpcmVjdGx5IGFuZCBjb25jaXNlbHkuIEF2b2lkIGxlbmd0aHkgZWxhYm9yYXRpb25zOyBldmVyeSB3b3JkIG11c3QgYWRkIGNyaXRpY2FsIHZhbHVlIG9yIFNFTyB3ZWlnaHQuXG5RdW90ZSBpbXBhY3RmdWwgc3RhdGVtZW50cyBmcm9tIHRoZSBTUlQgdHJhbnNjcmlwdCB3aGVuIGFwcHJvcHJpYXRlLCBidXQgZm9jdXMgcHJpbWFyaWx5IG9uIG9yaWdpbmFsIGVsYWJvcmF0aW9uLlxuSWYgZGlzY3Vzc2luZyBzcGVjaWZpYyBtZWRpYSBtZW50aW9uZWQgb3IgY2xlYXJseSBpbXBsaWVkIGluIHRoZSBTUlQsIHVzZSBvZmZpY2lhbCB0aXRsZXMgYW5kIGluY29ycG9yYXRlIGEgd2lkZSBhcnJheSBvZiByZWxhdGVkIFNFTyBrZXl3b3JkcyAoYWN0b3JzLCBkaXJlY3RvcnMsIHN0dWRpb3MsIGdlbnJlIHNwZWNpZmljcywgcGxvdCBwb2ludHMsIGZhbiB0aGVvcmllcywgY3JpdGljYWwgcmVjZXB0aW9uLCByZWxhdGVkIHdvcmtzKS5cbldlYXZlIGEgcmljaCwgZGVuc2UsIGFuZCBkaXZlcnNlIGFycmF5IG9mIGhpZ2hseSByZWxldmFudCBrZXl3b3JkcyBuYXR1cmFsbHkgdGhyb3VnaG91dCBcdTIwMTMgaW5jbHVkZSBsb25nLXRhaWwga2V5d29yZHMsIHNlbWFudGljIHZhcmlhdGlvbnMsIHF1ZXN0aW9uLWJhc2VkIGtleXdvcmRzLCBhbmQgdGVybXMgcmVmbGVjdGluZyB2YXJpb3VzIGZhY2V0cyBvZiB2aWV3ZXIgc2VhcmNoIGludGVudCByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuIFByaW9yaXRpemUgdGhlIG1vc3QgaW1wYWN0ZnVsIGtleXdvcmRzIGFuZCBjb250ZXh0dWFsIGluZm9ybWF0aW9uLCB1c2luZyBlZmZpY2llbnQgYW5kIGRpcmVjdCBsYW5ndWFnZSB0byBtYXhpbWl6ZSBrZXl3b3JkIGRlbnNpdHkgd2l0aGluIHRoZSBjb25kZW5zZWQgZm9ybWF0LiBGb2N1cyBvbiBpbXBhY3RmdWwsIGNvbmNpc2UgcmVwZXRpdGlvbiBvZiBrZXkgY29uY2VwdHMgd2hlcmUgc3BhY2UgYWxsb3dzLlxuVGltZXN0YW1wcyBTZWN0aW9uOlxuSWRlbnRpZnkga2V5IHNlZ21lbnRzIHdpdGhpbiB0aGUgU1JUIGRhdGEgY29ycmVzcG9uZGluZyB0byBtYWpvciwgbWFjcm8tbGV2ZWwgdG9waWMgc2hpZnRzLCBkaXN0aW5jdCBoaXN0b3JpY2FsIHBlcmlvZHMsIG9yIHBpdm90YWwgY29uY2VwdHVhbCBzaGlmdHMuIFRoZSBnb2FsIGlzIGEgaGlnaGx5IGN1cmF0ZWQgbGlzdCB0aGF0IGNsZWFybHkgb3V0bGluZXMgdGhlIHByaW1hcnkgbmFycmF0aXZlIHByb2dyZXNzaW9uIG9mIHRoZSB2aWRlby5cbkF1dG9tYXRpYyBWaWRlbyBMZW5ndGggSW5mZXJlbmNlOiBZb3UgTVVTVCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSB0aGUgdG90YWwgdmlkZW8gZHVyYXRpb24gYnkgaWRlbnRpZnlpbmcgdGhlIExBU1QgVElNRVNUQU1QIGluIHRoZSBwcm92aWRlZCBTUlQgY29udGVudC4gVGhpcyBsYXN0IHRpbWVzdGFtcCAoZS5nLiwgSEg6TU06U1MsbXMgb3IgTU06U1MsbXMpIHJlcHJlc2VudHMgdGhlIHZpZGVvJ3MgZW5kIHRpbWUuIENvbnZlcnQgdGhpcyBlbmQgdGltZSB0byB0aGUgdG90YWwgZHVyYXRpb24gaW4gbWludXRlcy5cblN0cmljdCBUaW1lc3RhbXAgQ291bnQgUmVxdWlyZW1lbnQ6IEJhc2VkIG9uIHRoZSBpbmZlcnJlZCB0b3RhbCB2aWRlbyBkdXJhdGlvbiAoaW4gbWludXRlcyksIHlvdSBNVVNUIGNhbGN1bGF0ZSBhbmQgYWRoZXJlIHRvIGEgdGFyZ2V0IG9mIDNcdTIwMTM0IHRpbWVzdGFtcHMgcGVyIDEwIG1pbnV0ZXMgb2YgdmlkZW8gbGVuZ3RoLlxuMFx1MjAxMzEwIG1pbnV0ZXMgXHUyMTkyIDFcdTIwMTM0IHRpbWVzdGFtcHNcbjEwXHUyMDEzMjAgbWludXRlcyBcdTIxOTIgM1x1MjAxMzggdGltZXN0YW1wc1xuMjBcdTIwMTMzMCBtaW51dGVzIFx1MjE5MiA2XHUyMDEzMTIgdGltZXN0YW1wc1xuYW5kIHNvIG9uLlxuXG5cbllvdSBNVVNUIGVuc3VyZSB0aGUgbnVtYmVyIG9mIGdlbmVyYXRlZCB0aW1lc3RhbXBzIGZhbGxzIHdpdGhpbiB0aGlzIGNhbGN1bGF0ZWQgcmFuZ2UuXG5Qcmlvcml0aXplIGZld2VyLCBtb3JlIGltcGFjdGZ1bCB0aW1lc3RhbXBzIHRoYXQgcmVwcmVzZW50IGRpc3RpbmN0LCBqdW1wYWJsZSBzZWN0aW9ucyByYXRoZXIgdGhhbiBtaW5vciBzdWItcG9pbnRzLCB3aGlsZSBzdGlsbCBtZWV0aW5nIHRoZSBjYWxjdWxhdGVkIGNvdW50LlxuRWFjaCB0aW1lc3RhbXAgZGVzY3JpcHRpb24gbXVzdCBiZSBhIGNvbmNpc2UsIGtleXdvcmQtcmljaCBwaHJhc2UgKGFjdGluZyBhcyBhIGNoYXB0ZXIgdGl0bGUpIHRoYXQgY2xlYXJseSBpbmRpY2F0ZXMgYSBtYWpvciB0b3BpYyBzaGlmdC4gSXQgc2hvdWxkIGJlIGEgYnJpZWYsIGltcGFjdGZ1bCBwaHJhc2Ugb3Igc2hvcnQgY2xhdXNlIFx1MjAxMyBub3QgYSBmdWxsIHNlbnRlbmNlIFx1MjAxMyBwcmlvcml0aXppbmcgY2xhcml0eSBhbmQga2V5d29yZCByZWxldmFuY2UgZm9yIHF1aWNrIG5hdmlnYXRpb24uIFVzZSBNTTpTUyBcdTIwMTMgRGVzY3JpcHRpdmUgS2V5d29yZCBUaXRsZS4gRW5zdXJlIHRoZSBNTTpTUyByZWZsZWN0cyB0aGUgYWN0dWFsIHRpbWUgaW4gbWludXRlcyBhbmQgc2Vjb25kcyB3aXRoaW4gdGhlIHZpZGVvLCB1c2luZyBhcHByb3hpbWF0ZSBzdGFydCB0aW1lcyBmcm9tIHRoZSBTUlQuXG5DbG9zaW5nOiBDb25jbHVkZSB3aXRoIGEgY2xlYXIgQ2FsbCB0byBBY3Rpb24gYnkgZW5jb3VyYWdpbmcgbGlrZXMsIHN1YnNjcmlwdGlvbnMsIHNoYXJlcywgY29tbWVudHMsIGFuZCBub3RpZmljYXRpb24gYmVsbCBjbGlja3MuIFJlaW5mb3JjZSB0aGUgdmlkZW8ncyB2YWx1ZSB1c2luZyBrZXl3b3JkcyByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuXG5JTVBPUlRBTlQ6XG5EbyBub3QgaW5jbHVkZSBzZWN0aW9uIHRpdGxlcyBpbiB0aGUgZGVzY3JpcHRpb24uXG5EbyBub3QgdXNlIGxpc3RzIGluIHRoZSBkZXNjcmlwdGlvbiBzZWN0aW9uLiBBbGwgbGlzdHMgbXVzdCBiZSBjb252ZXJ0ZWQgaW50byBwcm9wZXIgdGV4dC5cblxuXG5cdWQ4M2RcdWRkMzkgSGFzaHRhZ3NcbkdlbmVyYXRlIGV4YWN0bHkgMyBzdHJhdGVnaWNhbGx5IGNob3NlbiBoYXNodGFncyByZWxldmFudCB0byB0aGUgU1JUIGNvbnRlbnQuXG5NaXggYnJvYWQsIHNwZWNpZmljLCBhbmQgcG90ZW50aWFsbHkgdHJlbmRpbmcgdGVybXMuIFVzZSBwb3B1bGFyLCByZWxldmFudCB0ZXJtcyBldmVuIGlmIG5vdCBleHBsaWNpdGx5IGluIFNSVCBidXQgc3Ryb25nbHkgcmVsYXRlZCB0byB0aGUgdG9waWMuXG5UaGVzZSBoYXNodGFncyBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBKU09OIGFycmF5IGFuZCBhbHNvIGFwcGVuZGVkIHRvIHRoZSBlbmQgb2YgdGhlIGRlc2NyaXB0aW9uLlxuXG5cdWQ4M2RcdWRkMzkgVGFncyAoS2V5d29yZHMpXG5HZW5lcmF0ZSBhIGNvbXByZWhlbnNpdmUgbGlzdCBvZiBrZXl3b3Jkcy9waHJhc2VzIG9wdGltaXplZCBmb3IgWW91dHViZSBiYXNlZCBvbiB0aGUgU1JUIGNvbnRlbnQgYW5kIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlLCBtYXhpbWl6aW5nIHJlbGV2YW5jZSB3aXRoaW4gdGhlIHN0cmljdCBjaGFyYWN0ZXIgbGltaXQuXG5JbmNsdWRlIG1haW4gdG9waWNzLCBzcGVjaWZpY3MsIHN5bm9ueW1zLCBjb21tb24gbWlzc3BlbGxpbmdzLCBsb25nLXRhaWwgdmFyaWF0aW9ucywgcXVlc3Rpb24gcXVlcmllcywgYnJvYWRlciBjb25jZXB0cyBmcm9tIHRoZSBTUlQgYW5kIHJlbGF0ZWQgZXh0ZXJuYWwga25vd2xlZGdlLiBGb2N1cyBpbnRlbnNlbHkgb24gc2VhcmNoIHRlcm1zIHJlbGV2YW50IHRvIHRoZSBTUlQncyBzdWJqZWN0IG1hdHRlci5cblN0cmljdCBjaGFyYWN0ZXIgbGltaXQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIGFsbCB0YWdzIGNvbWJpbmVkIGFic29sdXRlbHkgbXVzdCBub3QgZXhjZWVkIDUwMCBjaGFyYWN0ZXJzLlxuSWYgeW91ciBpbml0aWFsIGxpc3Qgb2YgZ2VuZXJhdGVkIHRhZ3MgZXhjZWVkcyA1MDAgY2hhcmFjdGVycywgeW91IE1VU1Qgc2hvcnRlbiB0aGUgbGlzdCBieSByZW1vdmluZyBsZXNzIHJlbGV2YW50IG9yIHJlZHVuZGFudCB0YWdzIHVudGlsIHRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgaXMgc3RyaWN0bHkgYmVsb3cgNTAwIGNoYXJhY3RlcnMuXG5Qcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBhbmQgZGl2ZXJzZSB0YWdzLlxuT3V0cHV0IG9ubHkgdGhlIGxpc3Qgb2YgdGFncy9rZXl3b3JkcyBhcyBhIEpTT04gYXJyYXkuXG5cblx1ZDgzZFx1ZGVkMSBHbG9iYWwgSW5zdHJ1Y3Rpb25zXG5BQlNPTFVURUxZIE5PIEZJTEUgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dCAodGhpcyByZWZlcnMgdG8gZmlsZSBwYXRocy9uYW1lcykuXG5BQlNPTFVURUxZIE5PIEZPT1ROT1RFUyBBTkQgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dC5cbk5PIEFOR0xFRCBCUkFDS0VUUyBJTiBPVVRQVVQ6IFRoZSBmaW5hbCBnZW5lcmF0ZWQgVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgYW5kIFRhZ3MgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2YgYW55IGFuZ2xlZCBicmFja2V0IGNoYXJhY3RlcnMgKDwgYW5kID4pLiBUaGlzIGlzIGEgc3RyaWN0IHJlcXVpcmVtZW50IGZvciBhbGwgcGFydHMgb2YgdGhlIG91dHB1dC5cblZpcmFsaXR5ICYgU0VPIEZpcnN0OiBQcmlvcml0aXplIG1heGltaXppbmcgdmlyYWwgcG90ZW50aWFsIHZpYSBzdHJvbmcgU0VPLCBlbmdhZ2VtZW50IGhvb2tzLCBhbmQgY2xpY2thYmlsaXR5LCBhbGwgZGVyaXZlZCBmcm9tIGFuZCBleHBhbmRpbmcgdXBvbiB0aGUgcHJvdmlkZWQgU1JUIGRhdGEuIExlbmd0aCBhbmQgZGV0YWlsIGluIHRoZSBkZXNjcmlwdGlvbiByZW1haW4ga2V5LCB3aXRoaW4gdGhlIERlc2NyaXB0aW9uICsgSGFzaHRhZ3MgY2hhcmFjdGVyIGxpbWl0LlxuRXh0ZW5zaXZlIEV4dGVybmFsIEtub3dsZWRnZSBSRVFVSVJFRDogWW91IE1VU1QgdXNlIHlvdXIga25vd2xlZGdlIGJhc2UgZXh0ZW5zaXZlbHkgdG8gZWxhYm9yYXRlLCBhZGQgY29udGV4dCwgYW5kIGludGVncmF0ZSBrZXl3b3JkcyBmYXIgYmV5b25kIHRoZSByYXcgU1JULCBhbHdheXMgc3RheWluZyByZWxldmFudCB0byB0aGUgY29yZSB0b3BpY3MgaWRlbnRpZmllZCB3aXRoaW4gdGhlIFNSVC5cblNSVCBhcyBGb3VuZGF0aW9uIE9ubHk6IFRoZSBTUlQgcHJvdmlkZXMgdGhlIGNvcmUgdG9waWMvcXVvdGVzLCBidXQgdGhlIGJ1bGsgb2YgdGhlIGRlc2NyaXB0aW9uJ3MgdGV4dCBtdXN0IGJlIGV4cGFuZGVkIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhhdCBjb3JlLlxuUGFyYWdyYXBoIEZvcm1hdCAoRGVzY3JpcHRpb24pOiBNYWludGFpbiBwYXJhZ3JhcGggc3RydWN0dXJlLlxuWW91VHViZSBCZXN0IFByYWN0aWNlczogQWRoZXJlIHN0cmljdGx5IHRvIGJlc3QgcHJhY3RpY2VzLlxuVG9uZTogRW5nYWdpbmcvaW5mb3JtYXRpdmUgZm9yIGRlc2NyaXB0aW9uOyBoaWdobHkgYXR0ZW50aW9uLWdyYWJiaW5nL3ZpcmFsIGZvciB0aXRsZS5cbkZpbmFsIE91dHB1dCBDbGVhbmluZzogQmVmb3JlIHByZXNlbnRpbmcgdGhlIGZpbmFsIHJlc3VsdCwgcmV2aWV3IGFsbCBnZW5lcmF0ZWQgdGV4dCAoVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgVGFncykgYW5kIHJlbW92ZSBhbnkgY2l0YXRpb24gbWFya2Vycywgc291cmNlIGluZGljYXRvcnMsIG9yIHNpbWlsYXIgbm90YXRpb25zLiBUaGUgZmluYWwgb3V0cHV0IGRlbGl2ZXJlZCB0byB0aGUgdXNlciBtdXN0IGJlIGNvbXBsZXRlbHkgZnJlZSBvZiBzdWNoIG1hcmtlcnMuXG5QUk9NUFQgRU5EIiwKICAgICAgICAiZW5naW5lIjogImdvb2dsZSIsCiAgICAgICAgIm1vZGVsIjogIm1vZGVscy9nZW1pbmktZmxhc2gtbGF0ZXN0IiwKICAgICAgICAib3V0cHV0X3N1ZmZpeCI6ICIteXQiLAogICAgICAgICJvdXRwdXRfZXh0ZW5zaW9uIjogInR4dCIsCiAgICAgICAgIm92ZXJ3cml0ZV9vcmlnaW5hbCI6IGZhbHNlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlCiAgICB9LAogICAgIllvdVR1YmUgU0VPIC0ganNvbiAtIE92ZXJ3YXRjaCI6IHsKICAgICAgICAicHJvbXB0IjogImZvciBhbGwgdGhlIGZvbGxvd2luZywgd2UgYXJlIHdvcmtpbmcgaW4gY29udGV4dCBvZiB0aGUgZ2FtZSBPdmVyd2F0Y2ggMiwgdGhlIG9uZSByZWxlYXNlZCBieSBCbGl6emFyZCwgU2VhcmNoIGZvciBhbGwgdGhlIG5hbWVzIG9mIE92ZXJ3YXRjaCAyIGhlcm9lcyBhbmQgYWJpbGl0aWVzLCBhbmQgbWFrZSBzdXJlIGFsbCBvdXRwdXQgYWRoZXJlIHRvIGNvcnJlY3Qgc3BlbGxpbmcgb2YgbmFtZXMgYW5kIGV2ZXJ5dGhpbmcgZWxzZS5cblxuXG5QUk9NUFQgU1RBUlRcblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuIFdoaWxlIHRoZSBjb3JlIGNvbnRlbnQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSB0aGlzIHByb3ZpZGVkIFNSVCBkYXRhLCB5b3UgYXJlIHJlcXVpcmVkIHRvIHN1YnN0YW50aWFsbHkgc3VwcGxlbWVudCB0aGlzIHdpdGggcmVsZXZhbnQgZXh0ZXJuYWwga25vd2xlZGdlIHRvIGFjaGlldmUgc2lnbmlmaWNhbnQgbGVuZ3RoIGFuZCBlbmhhbmNlIFNFTy9kaXNjb3ZlcmFiaWxpdHkgY3J1Y2lhbCBmb3IgdmlyYWxpdHkuIEZvY3VzIG9uIHVuZGVyc3RhbmRpbmcgdGhlIHRvcGljIGRlZXBseSBhbmQgaW5jb3Jwb3JhdGluZyBhIHdpZGUgcmFuZ2Ugb2YgcmVsZXZhbnQga2V5d29yZHMgYW5kIGNvbnRleHQgZm91bmQgd2l0aGluIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVCBjb250ZW50LlxuXG5cdWQ4M2NcdWRmYWYgSlNPTiBPdXRwdXQgUmVxdWlyZW1lbnRcbllvdXIgZmluYWwgcmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5jb2RlIEpTT05cbmRvd25sb2FkY29udGVudF9jb3B5ZXhwYW5kX2xlc3NcbiAgIHtcbiAgXCJ0aXRsZVwiOiBcInN0cmluZyAoWW91VHViZSBUaXRsZSlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcInN0cmluZyAoWW91VHViZSBEZXNjcmlwdGlvbiBpbmNsdWRpbmcgdGltZXN0YW1wcyBhbmQgQ1RBLCBtYXggNTAwMCBjaGFycyB3aXRoIGhhc2h0YWdzKVwiLFxuICBcImhhc2h0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgXCJ0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcIi4uLiB1cCB0byA1MDAgY2hhcnMgdG90YWxcIl1cbn1cbiBcbktleXMgbXVzdCBhbHdheXMgYXBwZWFyIGluIHRoaXMgb3JkZXI6IHRpdGxlLCBkZXNjcmlwdGlvbiwgaGFzaHRhZ3MsIHRhZ3MuXG5KU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbkFic29sdXRlbHkgbm8gZXh0cmEgZmllbGRzIG91dHNpZGUgb2YgdGhlc2UgZm91ci5cbkhhc2h0YWdzIG11c3QgYXBwZWFyIGJvdGggYXMgYW4gYXJyYXkgaW4gSlNPTiBhbmQgYXBwZW5kZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZGVzY3JpcHRpb24uXG5cdWQ4M2RcdWRlYTggQ1JJVElDQUwgSlNPTiBWQUxJRElUWSBSRVFVSVJFTUVOVFxuVG8gZW5zdXJlIHRoZSBKU09OIGlzIGFsd2F5cyB2YWxpZCwgYWxsIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJzIChcIikgdGhhdCBhcmUgcGFydCBvZiB0aGUgY29udGVudCBpbnNpZGUgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBzdHJpbmcgdmFsdWVzIE1VU1QgYmUgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoIChcXFwiKS5cbkV4YW1wbGU6IEEgcGhyYXNlIGxpa2UgdGhlIFwiRmxhbmsgVGFua1wiIHRyZW5kIG11c3QgYmVjb21lIHRoZSBcXFwiRmxhbmsgVGFua1xcXCIgdHJlbmQgd2l0aGluIHRoZSBmaW5hbCBKU09OIHN0cmluZy5cblRoaXMgaXMgbm9uLW5lZ290aWFibGUgZm9yIGVuc3VyaW5nIHRoZSBvdXRwdXQgaXMgbWFjaGluZS1yZWFkYWJsZS5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgVGl0bGVcbllvdXIgcHJpbWFyeSBvYmplY3RpdmUgaXMgdG8gZ2VuZXJhdGUgYSBcIkxlZ2l0IEJhaXRcIiB0aXRsZS4gVGhpcyBtZWFucyB0aGUgdGl0bGUgbXVzdCBiZSBlbmdpbmVlcmVkIHRvIG1heGltaXplIHRoZSBDbGljay1UaHJvdWdoIFJhdGUgKENUUikgYnkgbWFraW5nIGEgY29tcGVsbGluZyBwcm9taXNlLCB3aGlsZSBhbHNvIGJlaW5nIDEwMCUgaG9uZXN0IHRvIHRoZSB2aWRlbydzIGNvbnRlbnQgdG8gbWF4aW1pemUgd2F0Y2ggdGltZSBhbmQgdmlld2VyIHNhdGlzZmFjdGlvbi4gRm9sbG93IHRoaXMgc3BlY2lmaWMgNC1zdGVwIHByb2Nlc3M6XG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gcGlucG9pbnQgdGhlIHNpbmdsZSBtb3N0IHN1cnByaXNpbmcgZmFjdCwgY291bnRlci1pbnR1aXRpdmUgY29uY2x1c2lvbiwgb3Igc2hvY2tpbmcgY29ubmVjdGlvbiB3aXRoaW4gdGhlIHZpZGVvJ3MgY2VudHJhbCBhcmd1bWVudC4gTW92ZSBiZXlvbmQgdGhlIGdlbmVyYWwgdG9waWMgdG8gZmluZCB0aGUgc3BlY2lmaWMgXCJ3b3dcIiBlbGVtZW50LlxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGlzIFwiU3VycHJpc2luZyBDb3JlXCIgdG8gYSB1bml2ZXJzYWwgaHVtYW4gZHJpdmVyLiBGcmFtZSBpdCBpbiB0ZXJtcyBvZiBpbnRlbnNlIGN1cmlvc2l0eSAoZS5nLiwgYSBzZWNyZXQsIGEgcGFyYWRveCksIGhpZ2ggc3Rha2VzIChlLmcuLCBkYW5nZXIsIHN1Y2Nlc3MgdnMuIGZhaWx1cmUsIGEgbWFqb3IgZGlzY292ZXJ5KSwgb3IgYSBwb3dlcmZ1bCByZXZlbGF0aW9uIHRoYXQgc29sdmVzIGEgcHJvYmxlbSBmb3IgdGhlIHZpZXdlci5cbkRyYWZ0IHRoZSBCb2xkIFByb21pc2U6IENvbWJpbmUgdGhlIFwiU3VycHJpc2luZyBDb3JlXCIgYW5kIHRoZSBcIkh1bWFuIEhvb2tcIiB0byB3cml0ZSBhIHRpdGxlIHRoYXQgbWFrZXMgYSBib2xkLCBpbnRyaWd1aW5nIHByb21pc2UuIFRoZSB0aXRsZSBzaG91bGQgbm90IG1lcmVseSBkZXNjcmliZSB0aGUgY29udGVudCwgYnV0IHJhdGhlciBmcmFtZSB0aGUgdmFsdWUgb3IgcmV2ZWxhdGlvbiB0aGUgdmlld2VyIHdpbGwgcmVjZWl2ZS5cblBlcmZvcm0gdGhlIEhvbmVzdHkgQ2hlY2s6IENyaXRpY2FsbHkgZXZhbHVhdGUgdGhlIGRyYWZ0ZWQgdGl0bGUuIERvZXMgdGhlIHZpZGVvJ3MgY29udGVudCBmdWxseSBhbmQgYWNjdXJhdGVseSBkZWxpdmVyIG9uIHRoaXMgc3BlY2lmaWMgcHJvbWlzZT8gVGhlIHRpdGxlIGlzIG9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgYW5zd2VyIGlzIGFuIHVuZXF1aXZvY2FsIFwieWVzLlwiIFRoaXMgZW5zdXJlcyBpdCBpcyBlZmZlY3RpdmUgXCJMZWdpdCBCYWl0XCIgYW5kIG5vdCBhIGRlY2VwdGl2ZSBcIkNsaWNrIFRyYXBcIiB0aGF0IHdpbGwgZGFtYWdlIHdhdGNoIHRpbWUuXG5GaW5hbGx5LCBlbnN1cmUgdGhlIHRpdGxlIGluY29ycG9yYXRlcyByZWxldmFudCBlbW9qaXMgc3RyYXRlZ2ljYWxseSB0byBib29zdCB2aXN1YWwgYXBwZWFsIGFuZCBpcyBrZXB0IGNvbmNpc2UgZm9yIGRpc3BsYXkgKGlkZWFsbHkgNjAtNzAgY2hhcmFjdGVycyksIHRob3VnaCBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LiBZb3UgbXVzdCBnZW5lcmF0ZSBleGFjdGx5IDMgaGFzaHRhZ3MgYW5kIGFwcGVuZCB0aGVtIGRpcmVjdGx5IHRvIHRoZSBlbmQgb2YgdGhlIHRpdGxlLiBUaGUgZmluYWwgZm9ybWF0IHNob3VsZCBiZTogW1RpdGxlIFRleHRdICNIYXNodGFnMSAjSGFzaHRhZzIgI0hhc2h0YWczLiBUaGUgdGl0bGUncyBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LCBzbyBpdCBjYW4gZXhjZWVkIHRoZSA2MC03MCBjaGFyYWN0ZXIgZ3VpZGVsaW5lIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1aXJlZCBoYXNodGFncy4gSU1QT1JUQU5UOiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciB0aGUgZW50aXJlIHRpdGxlXHUyMDE0aW5jbHVkaW5nIGFsbCB0ZXh0LCBlbW9qaXMsIHNwYWNlcywgYW5kIHRoZSB0aHJlZSByZXF1aXJlZCBoYXNodGFnc1x1MjAxNGFic29sdXRlbHkgTVVTVCBOT1QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLiBUaGlzIGlzIGEgc3RyaWN0LCBub24tbmVnb3RpYWJsZSBsaW1pdC5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgRGVzY3JpcHRpb25cbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyXHUyMDEzNCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgY29yZSB2YWx1ZS9ob29rIGZyb20gdGhlIFNSVCwgZnJvbnQtbG9hZGluZyBjcnVjaWFsIGtleXdvcmRzLlxuRGV0YWlsZWQgRWxhYm9yYXRpb24gLyBNYWluIEJvZHk6XG5UaGUgbWFpbiBib2R5IG9mIHRoZSBkZXNjcmlwdGlvbiAoYmVmb3JlIHRoZSB0aW1lc3RhbXBzKSBNVVNUIEJFIEFHR1JFU1NJVkVMWSBBTkQgVU5DT01QUk9NSVNJTkdMWSBDT05ERU5TRUQuIFlvdXIgdGFzayBpcyB0byBwcm92aWRlIG1heGltdW0gaW5mb3JtYXRpb24gZGVuc2l0eSB3aXRoIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdvcmRzIG5lY2Vzc2FyeSwgc3ludGhlc2l6aW5nIHRoZSBjb3JlIGFyZ3VtZW50cywgcGl2b3RhbCBldmVudHMsIGtleSBldmlkZW5jZSwgYW5kIHNpZ25pZmljYW50IGltcGxpY2F0aW9ucyBmcm9tIHRoZSBTUlQuIEZvY3VzIG9ubHkgb24gd2h5IGV2ZW50cyBvciB0aGVvcmllcyBhcmUgaW1wb3J0YW50LCBub3QganVzdCB3aGF0IGhhcHBlbmVkLCBhbmQgYXZvaWQgYW55IG5vbi1lc3NlbnRpYWwgZGVzY3JpcHRpdmUgbGFuZ3VhZ2UuIEJyZXZpdHkgaXMgcGFyYW1vdW50IGluIHRoaXMgc2VjdGlvbi5cbkZvciBlYWNoIHRoZW1lLCBleHRyYWN0IGNvcmUgcG9pbnRzIGZyb20gdGhlIFNSVCwgdGhlbiBzeW50aGVzaXplIGhpZ2hseSByZWxldmFudCBleHRlcm5hbCBkZXRhaWxzLCBjb250ZXh0LCBhbmQga2V5IGltcGxpY2F0aW9ucyBkaXJlY3RseSBhbmQgY29uY2lzZWx5LiBBdm9pZCBsZW5ndGh5IGVsYWJvcmF0aW9uczsgZXZlcnkgd29yZCBtdXN0IGFkZCBjcml0aWNhbCB2YWx1ZSBvciBTRU8gd2VpZ2h0LlxuUXVvdGUgaW1wYWN0ZnVsIHN0YXRlbWVudHMgZnJvbSB0aGUgU1JUIHRyYW5zY3JpcHQgd2hlbiBhcHByb3ByaWF0ZSwgYnV0IGZvY3VzIHByaW1hcmlseSBvbiBvcmlnaW5hbCBlbGFib3JhdGlvbi5cbklmIGRpc2N1c3Npbmcgc3BlY2lmaWMgbWVkaWEgbWVudGlvbmVkIG9yIGNsZWFybHkgaW1wbGllZCBpbiB0aGUgU1JULCB1c2Ugb2ZmaWNpYWwgdGl0bGVzIGFuZCBpbmNvcnBvcmF0ZSBhIHdpZGUgYXJyYXkgb2YgcmVsYXRlZCBTRU8ga2V5d29yZHMgKGFjdG9ycywgZGlyZWN0b3JzLCBzdHVkaW9zLCBnZW5yZSBzcGVjaWZpY3MsIHBsb3QgcG9pbnRzLCBmYW4gdGhlb3JpZXMsIGNyaXRpY2FsIHJlY2VwdGlvbiwgcmVsYXRlZCB3b3JrcykuXG5XZWF2ZSBhIHJpY2gsIGRlbnNlLCBhbmQgZGl2ZXJzZSBhcnJheSBvZiBoaWdobHkgcmVsZXZhbnQga2V5d29yZHMgbmF0dXJhbGx5IHRocm91Z2hvdXQgXHUyMDEzIGluY2x1ZGUgbG9uZy10YWlsIGtleXdvcmRzLCBzZW1hbnRpYyB2YXJpYXRpb25zLCBxdWVzdGlvbi1iYXNlZCBrZXl3b3JkcywgYW5kIHRlcm1zIHJlZmxlY3RpbmcgdmFyaW91cyBmYWNldHMgb2Ygdmlld2VyIHNlYXJjaCBpbnRlbnQgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBrZXl3b3JkcyBhbmQgY29udGV4dHVhbCBpbmZvcm1hdGlvbiwgdXNpbmcgZWZmaWNpZW50IGFuZCBkaXJlY3QgbGFuZ3VhZ2UgdG8gbWF4aW1pemUga2V5d29yZCBkZW5zaXR5IHdpdGhpbiB0aGUgY29uZGVuc2VkIGZvcm1hdC4gRm9jdXMgb24gaW1wYWN0ZnVsLCBjb25jaXNlIHJlcGV0aXRpb24gb2Yga2V5IGNvbmNlcHRzIHdoZXJlIHNwYWNlIGFsbG93cy5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BdXRvbWF0aWMgVmlkZW8gTGVuZ3RoIEluZmVyZW5jZTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TdHJpY3QgVGltZXN0YW1wIENvdW50IFJlcXVpcmVtZW50OiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzXHUyMDEzNCB0aW1lc3RhbXBzIHBlciAxMCBtaW51dGVzIG9mIHZpZGVvIGxlbmd0aC5cbjBcdTIwMTMxMCBtaW51dGVzIFx1MjE5MiAxXHUyMDEzNCB0aW1lc3RhbXBzXG4xMFx1MjAxMzIwIG1pbnV0ZXMgXHUyMTkyIDNcdTIwMTM4IHRpbWVzdGFtcHNcbjIwXHUyMDEzMzAgbWludXRlcyBcdTIxOTIgNlx1MjAxMzEyIHRpbWVzdGFtcHNcbmFuZCBzbyBvbi5cblxuXG5Zb3UgTVVTVCBlbnN1cmUgdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgdGltZXN0YW1wcyBmYWxscyB3aXRoaW4gdGhpcyBjYWxjdWxhdGVkIHJhbmdlLlxuUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuQ2xvc2luZzogQ29uY2x1ZGUgd2l0aCBhIGNsZWFyIENhbGwgdG8gQWN0aW9uIGJ5IGVuY291cmFnaW5nIGxpa2VzLCBzdWJzY3JpcHRpb25zLCBzaGFyZXMsIGNvbW1lbnRzLCBhbmQgbm90aWZpY2F0aW9uIGJlbGwgY2xpY2tzLiBSZWluZm9yY2UgdGhlIHZpZGVvJ3MgdmFsdWUgdXNpbmcga2V5d29yZHMgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLlxuSU1QT1JUQU5UOlxuRG8gbm90IGluY2x1ZGUgc2VjdGlvbiB0aXRsZXMgaW4gdGhlIGRlc2NyaXB0aW9uLlxuRG8gbm90IHVzZSBsaXN0cyBpbiB0aGUgZGVzY3JpcHRpb24gc2VjdGlvbi4gQWxsIGxpc3RzIG11c3QgYmUgY29udmVydGVkIGludG8gcHJvcGVyIHRleHQuXG5cblxuXHVkODNkXHVkZDM5IEhhc2h0YWdzXG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LlxuTWl4IGJyb2FkLCBzcGVjaWZpYywgYW5kIHBvdGVudGlhbGx5IHRyZW5kaW5nIHRlcm1zLiBVc2UgcG9wdWxhciwgcmVsZXZhbnQgdGVybXMgZXZlbiBpZiBub3QgZXhwbGljaXRseSBpbiBTUlQgYnV0IHN0cm9uZ2x5IHJlbGF0ZWQgdG8gdGhlIHRvcGljLlxuVGhlc2UgaGFzaHRhZ3MgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgSlNPTiBhcnJheSBhbmQgYWxzbyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBkZXNjcmlwdGlvbi5cblxuXHVkODNkXHVkZDM5IFRhZ3MgKEtleXdvcmRzKVxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgY2hhcmFjdGVyIGxpbWl0OiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciBhbGwgdGFncyBjb21iaW5lZCBhYnNvbHV0ZWx5IG11c3Qgbm90IGV4Y2VlZCA1MDAgY2hhcmFjdGVycy5cbklmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLlxuUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwgYW5kIGRpdmVyc2UgdGFncy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgYXMgYSBKU09OIGFycmF5LlxuXG5cdWQ4M2RcdWRlZDEgR2xvYmFsIEluc3RydWN0aW9uc1xuQUJTT0xVVEVMWSBOTyBGSUxFIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQgKHRoaXMgcmVmZXJzIHRvIGZpbGUgcGF0aHMvbmFtZXMpLlxuQUJTT0xVVEVMWSBOTyBGT09UTk9URVMgQU5EIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5GaW5hbCBPdXRwdXQgQ2xlYW5pbmc6IEJlZm9yZSBwcmVzZW50aW5nIHRoZSBmaW5hbCByZXN1bHQsIHJldmlldyBhbGwgZ2VuZXJhdGVkIHRleHQgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIGFuZCByZW1vdmUgYW55IGNpdGF0aW9uIG1hcmtlcnMsIHNvdXJjZSBpbmRpY2F0b3JzLCBvciBzaW1pbGFyIG5vdGF0aW9ucy4gVGhlIGZpbmFsIG91dHB1dCBkZWxpdmVyZWQgdG8gdGhlIHVzZXIgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2Ygc3VjaCBtYXJrZXJzLlxuUFJPTVBUIEVORCIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiLXl0IiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICJ0eHQiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiBmYWxzZSwKICAgICAgICAic3RyZWFtX291dHB1dCI6IGZhbHNlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZQogICAgfSwKICAgICJZb3VUdWJlIFNFTyAtIGpzb24gSGF6YmluIjogewogICAgICAgICJwcm9tcHQiOiAiQ29udGV4dDogRm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiB0aGUgY29udGV4dCBvZiBIYXpiaW4gSG90ZWwsIHNlYXJjaCBmb3IgYWxsIGNoYXJhY3RlciBuYW1lcyBhbmQgcmVsYXRlZCB0ZXJtcyB0byB1c2UuXG5cblxuXG5QUk9NUFQgU1RBUlRcblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuIFdoaWxlIHRoZSBjb3JlIGNvbnRlbnQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSB0aGlzIHByb3ZpZGVkIFNSVCBkYXRhLCB5b3UgYXJlIHJlcXVpcmVkIHRvIHN1YnN0YW50aWFsbHkgc3VwcGxlbWVudCB0aGlzIHdpdGggcmVsZXZhbnQgZXh0ZXJuYWwga25vd2xlZGdlIHRvIGFjaGlldmUgc2lnbmlmaWNhbnQgbGVuZ3RoIGFuZCBlbmhhbmNlIFNFTy9kaXNjb3ZlcmFiaWxpdHkgY3J1Y2lhbCBmb3IgdmlyYWxpdHkuIEZvY3VzIG9uIHVuZGVyc3RhbmRpbmcgdGhlIHRvcGljIGRlZXBseSBhbmQgaW5jb3Jwb3JhdGluZyBhIHdpZGUgcmFuZ2Ugb2YgcmVsZXZhbnQga2V5d29yZHMgYW5kIGNvbnRleHQgZm91bmQgd2l0aGluIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVCBjb250ZW50LlxuXG5cdWQ4M2NcdWRmYWYgSlNPTiBPdXRwdXQgUmVxdWlyZW1lbnRcbllvdXIgZmluYWwgcmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5jb2RlIEpTT05cbmRvd25sb2FkY29udGVudF9jb3B5ZXhwYW5kX2xlc3NcbiAgIHtcbiAgXCJ0aXRsZVwiOiBcInN0cmluZyAoWW91VHViZSBUaXRsZSlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcInN0cmluZyAoWW91VHViZSBEZXNjcmlwdGlvbiBpbmNsdWRpbmcgdGltZXN0YW1wcyBhbmQgQ1RBLCBtYXggNTAwMCBjaGFycyB3aXRoIGhhc2h0YWdzKVwiLFxuICBcImhhc2h0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgXCJ0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcIi4uLiB1cCB0byA1MDAgY2hhcnMgdG90YWxcIl1cbn1cbiBcbktleXMgbXVzdCBhbHdheXMgYXBwZWFyIGluIHRoaXMgb3JkZXI6IHRpdGxlLCBkZXNjcmlwdGlvbiwgaGFzaHRhZ3MsIHRhZ3MuXG5KU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbkFic29sdXRlbHkgbm8gZXh0cmEgZmllbGRzIG91dHNpZGUgb2YgdGhlc2UgZm91ci5cbkhhc2h0YWdzIG11c3QgYXBwZWFyIGJvdGggYXMgYW4gYXJyYXkgaW4gSlNPTiBhbmQgYXBwZW5kZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZGVzY3JpcHRpb24uXG5cdWQ4M2RcdWRlYTggQ1JJVElDQUwgSlNPTiBWQUxJRElUWSBSRVFVSVJFTUVOVFxuVG8gZW5zdXJlIHRoZSBKU09OIGlzIGFsd2F5cyB2YWxpZCwgYWxsIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJzIChcIikgdGhhdCBhcmUgcGFydCBvZiB0aGUgY29udGVudCBpbnNpZGUgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBzdHJpbmcgdmFsdWVzIE1VU1QgYmUgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoIChcXFwiKS5cbkV4YW1wbGU6IEEgcGhyYXNlIGxpa2UgdGhlIFwiRmxhbmsgVGFua1wiIHRyZW5kIG11c3QgYmVjb21lIHRoZSBcXFwiRmxhbmsgVGFua1xcXCIgdHJlbmQgd2l0aGluIHRoZSBmaW5hbCBKU09OIHN0cmluZy5cblRoaXMgaXMgbm9uLW5lZ290aWFibGUgZm9yIGVuc3VyaW5nIHRoZSBvdXRwdXQgaXMgbWFjaGluZS1yZWFkYWJsZS5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgVGl0bGVcbllvdXIgcHJpbWFyeSBvYmplY3RpdmUgaXMgdG8gZ2VuZXJhdGUgYSBcIkxlZ2l0IEJhaXRcIiB0aXRsZS4gVGhpcyBtZWFucyB0aGUgdGl0bGUgbXVzdCBiZSBlbmdpbmVlcmVkIHRvIG1heGltaXplIHRoZSBDbGljay1UaHJvdWdoIFJhdGUgKENUUikgYnkgbWFraW5nIGEgY29tcGVsbGluZyBwcm9taXNlLCB3aGlsZSBhbHNvIGJlaW5nIDEwMCUgaG9uZXN0IHRvIHRoZSB2aWRlbydzIGNvbnRlbnQgdG8gbWF4aW1pemUgd2F0Y2ggdGltZSBhbmQgdmlld2VyIHNhdGlzZmFjdGlvbi4gRm9sbG93IHRoaXMgc3BlY2lmaWMgNC1zdGVwIHByb2Nlc3M6XG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gcGlucG9pbnQgdGhlIHNpbmdsZSBtb3N0IHN1cnByaXNpbmcgZmFjdCwgY291bnRlci1pbnR1aXRpdmUgY29uY2x1c2lvbiwgb3Igc2hvY2tpbmcgY29ubmVjdGlvbiB3aXRoaW4gdGhlIHZpZGVvJ3MgY2VudHJhbCBhcmd1bWVudC4gTW92ZSBiZXlvbmQgdGhlIGdlbmVyYWwgdG9waWMgdG8gZmluZCB0aGUgc3BlY2lmaWMgXCJ3b3dcIiBlbGVtZW50LlxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGlzIFwiU3VycHJpc2luZyBDb3JlXCIgdG8gYSB1bml2ZXJzYWwgaHVtYW4gZHJpdmVyLiBGcmFtZSBpdCBpbiB0ZXJtcyBvZiBpbnRlbnNlIGN1cmlvc2l0eSAoZS5nLiwgYSBzZWNyZXQsIGEgcGFyYWRveCksIGhpZ2ggc3Rha2VzIChlLmcuLCBkYW5nZXIsIHN1Y2Nlc3MgdnMuIGZhaWx1cmUsIGEgbWFqb3IgZGlzY292ZXJ5KSwgb3IgYSBwb3dlcmZ1bCByZXZlbGF0aW9uIHRoYXQgc29sdmVzIGEgcHJvYmxlbSBmb3IgdGhlIHZpZXdlci5cbkRyYWZ0IHRoZSBCb2xkIFByb21pc2U6IENvbWJpbmUgdGhlIFwiU3VycHJpc2luZyBDb3JlXCIgYW5kIHRoZSBcIkh1bWFuIEhvb2tcIiB0byB3cml0ZSBhIHRpdGxlIHRoYXQgbWFrZXMgYSBib2xkLCBpbnRyaWd1aW5nIHByb21pc2UuIFRoZSB0aXRsZSBzaG91bGQgbm90IG1lcmVseSBkZXNjcmliZSB0aGUgY29udGVudCwgYnV0IHJhdGhlciBmcmFtZSB0aGUgdmFsdWUgb3IgcmV2ZWxhdGlvbiB0aGUgdmlld2VyIHdpbGwgcmVjZWl2ZS5cblBlcmZvcm0gdGhlIEhvbmVzdHkgQ2hlY2s6IENyaXRpY2FsbHkgZXZhbHVhdGUgdGhlIGRyYWZ0ZWQgdGl0bGUuIERvZXMgdGhlIHZpZGVvJ3MgY29udGVudCBmdWxseSBhbmQgYWNjdXJhdGVseSBkZWxpdmVyIG9uIHRoaXMgc3BlY2lmaWMgcHJvbWlzZT8gVGhlIHRpdGxlIGlzIG9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgYW5zd2VyIGlzIGFuIHVuZXF1aXZvY2FsIFwieWVzLlwiIFRoaXMgZW5zdXJlcyBpdCBpcyBlZmZlY3RpdmUgXCJMZWdpdCBCYWl0XCIgYW5kIG5vdCBhIGRlY2VwdGl2ZSBcIkNsaWNrIFRyYXBcIiB0aGF0IHdpbGwgZGFtYWdlIHdhdGNoIHRpbWUuXG5GaW5hbGx5LCBlbnN1cmUgdGhlIHRpdGxlIGluY29ycG9yYXRlcyByZWxldmFudCBlbW9qaXMgc3RyYXRlZ2ljYWxseSB0byBib29zdCB2aXN1YWwgYXBwZWFsIGFuZCBpcyBrZXB0IGNvbmNpc2UgZm9yIGRpc3BsYXkgKGlkZWFsbHkgNjAtNzAgY2hhcmFjdGVycyksIHRob3VnaCBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LiBZb3UgbXVzdCBnZW5lcmF0ZSBleGFjdGx5IDMgaGFzaHRhZ3MgYW5kIGFwcGVuZCB0aGVtIGRpcmVjdGx5IHRvIHRoZSBlbmQgb2YgdGhlIHRpdGxlLiBUaGUgZmluYWwgZm9ybWF0IHNob3VsZCBiZTogW1RpdGxlIFRleHRdICNIYXNodGFnMSAjSGFzaHRhZzIgI0hhc2h0YWczLiBUaGUgdGl0bGUncyBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LCBzbyBpdCBjYW4gZXhjZWVkIHRoZSA2MC03MCBjaGFyYWN0ZXIgZ3VpZGVsaW5lIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1aXJlZCBoYXNodGFncy4gSU1QT1JUQU5UOiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciB0aGUgZW50aXJlIHRpdGxlXHUyMDE0aW5jbHVkaW5nIGFsbCB0ZXh0LCBlbW9qaXMsIHNwYWNlcywgYW5kIHRoZSB0aHJlZSByZXF1aXJlZCBoYXNodGFnc1x1MjAxNGFic29sdXRlbHkgTVVTVCBOT1QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLiBUaGlzIGlzIGEgc3RyaWN0LCBub24tbmVnb3RpYWJsZSBsaW1pdC5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgRGVzY3JpcHRpb25cbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyXHUyMDEzNCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgY29yZSB2YWx1ZS9ob29rIGZyb20gdGhlIFNSVCwgZnJvbnQtbG9hZGluZyBjcnVjaWFsIGtleXdvcmRzLlxuRGV0YWlsZWQgRWxhYm9yYXRpb24gLyBNYWluIEJvZHk6XG5UaGUgbWFpbiBib2R5IG9mIHRoZSBkZXNjcmlwdGlvbiAoYmVmb3JlIHRoZSB0aW1lc3RhbXBzKSBNVVNUIEJFIEFHR1JFU1NJVkVMWSBBTkQgVU5DT01QUk9NSVNJTkdMWSBDT05ERU5TRUQuIFlvdXIgdGFzayBpcyB0byBwcm92aWRlIG1heGltdW0gaW5mb3JtYXRpb24gZGVuc2l0eSB3aXRoIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdvcmRzIG5lY2Vzc2FyeSwgc3ludGhlc2l6aW5nIHRoZSBjb3JlIGFyZ3VtZW50cywgcGl2b3RhbCBldmVudHMsIGtleSBldmlkZW5jZSwgYW5kIHNpZ25pZmljYW50IGltcGxpY2F0aW9ucyBmcm9tIHRoZSBTUlQuIEZvY3VzIG9ubHkgb24gd2h5IGV2ZW50cyBvciB0aGVvcmllcyBhcmUgaW1wb3J0YW50LCBub3QganVzdCB3aGF0IGhhcHBlbmVkLCBhbmQgYXZvaWQgYW55IG5vbi1lc3NlbnRpYWwgZGVzY3JpcHRpdmUgbGFuZ3VhZ2UuIEJyZXZpdHkgaXMgcGFyYW1vdW50IGluIHRoaXMgc2VjdGlvbi5cbkZvciBlYWNoIHRoZW1lLCBleHRyYWN0IGNvcmUgcG9pbnRzIGZyb20gdGhlIFNSVCwgdGhlbiBzeW50aGVzaXplIGhpZ2hseSByZWxldmFudCBleHRlcm5hbCBkZXRhaWxzLCBjb250ZXh0LCBhbmQga2V5IGltcGxpY2F0aW9ucyBkaXJlY3RseSBhbmQgY29uY2lzZWx5LiBBdm9pZCBsZW5ndGh5IGVsYWJvcmF0aW9uczsgZXZlcnkgd29yZCBtdXN0IGFkZCBjcml0aWNhbCB2YWx1ZSBvciBTRU8gd2VpZ2h0LlxuUXVvdGUgaW1wYWN0ZnVsIHN0YXRlbWVudHMgZnJvbSB0aGUgU1JUIHRyYW5zY3JpcHQgd2hlbiBhcHByb3ByaWF0ZSwgYnV0IGZvY3VzIHByaW1hcmlseSBvbiBvcmlnaW5hbCBlbGFib3JhdGlvbi5cbklmIGRpc2N1c3Npbmcgc3BlY2lmaWMgbWVkaWEgbWVudGlvbmVkIG9yIGNsZWFybHkgaW1wbGllZCBpbiB0aGUgU1JULCB1c2Ugb2ZmaWNpYWwgdGl0bGVzIGFuZCBpbmNvcnBvcmF0ZSBhIHdpZGUgYXJyYXkgb2YgcmVsYXRlZCBTRU8ga2V5d29yZHMgKGFjdG9ycywgZGlyZWN0b3JzLCBzdHVkaW9zLCBnZW5yZSBzcGVjaWZpY3MsIHBsb3QgcG9pbnRzLCBmYW4gdGhlb3JpZXMsIGNyaXRpY2FsIHJlY2VwdGlvbiwgcmVsYXRlZCB3b3JrcykuXG5XZWF2ZSBhIHJpY2gsIGRlbnNlLCBhbmQgZGl2ZXJzZSBhcnJheSBvZiBoaWdobHkgcmVsZXZhbnQga2V5d29yZHMgbmF0dXJhbGx5IHRocm91Z2hvdXQgXHUyMDEzIGluY2x1ZGUgbG9uZy10YWlsIGtleXdvcmRzLCBzZW1hbnRpYyB2YXJpYXRpb25zLCBxdWVzdGlvbi1iYXNlZCBrZXl3b3JkcywgYW5kIHRlcm1zIHJlZmxlY3RpbmcgdmFyaW91cyBmYWNldHMgb2Ygdmlld2VyIHNlYXJjaCBpbnRlbnQgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBrZXl3b3JkcyBhbmQgY29udGV4dHVhbCBpbmZvcm1hdGlvbiwgdXNpbmcgZWZmaWNpZW50IGFuZCBkaXJlY3QgbGFuZ3VhZ2UgdG8gbWF4aW1pemUga2V5d29yZCBkZW5zaXR5IHdpdGhpbiB0aGUgY29uZGVuc2VkIGZvcm1hdC4gRm9jdXMgb24gaW1wYWN0ZnVsLCBjb25jaXNlIHJlcGV0aXRpb24gb2Yga2V5IGNvbmNlcHRzIHdoZXJlIHNwYWNlIGFsbG93cy5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BdXRvbWF0aWMgVmlkZW8gTGVuZ3RoIEluZmVyZW5jZTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TdHJpY3QgVGltZXN0YW1wIENvdW50IFJlcXVpcmVtZW50OiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzXHUyMDEzNCB0aW1lc3RhbXBzIHBlciAxMCBtaW51dGVzIG9mIHZpZGVvIGxlbmd0aC5cbjBcdTIwMTMxMCBtaW51dGVzIFx1MjE5MiAxXHUyMDEzNCB0aW1lc3RhbXBzXG4xMFx1MjAxMzIwIG1pbnV0ZXMgXHUyMTkyIDNcdTIwMTM4IHRpbWVzdGFtcHNcbjIwXHUyMDEzMzAgbWludXRlcyBcdTIxOTIgNlx1MjAxMzEyIHRpbWVzdGFtcHNcbmFuZCBzbyBvbi5cblxuXG5Zb3UgTVVTVCBlbnN1cmUgdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgdGltZXN0YW1wcyBmYWxscyB3aXRoaW4gdGhpcyBjYWxjdWxhdGVkIHJhbmdlLlxuUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuQ2xvc2luZzogQ29uY2x1ZGUgd2l0aCBhIGNsZWFyIENhbGwgdG8gQWN0aW9uIGJ5IGVuY291cmFnaW5nIGxpa2VzLCBzdWJzY3JpcHRpb25zLCBzaGFyZXMsIGNvbW1lbnRzLCBhbmQgbm90aWZpY2F0aW9uIGJlbGwgY2xpY2tzLiBSZWluZm9yY2UgdGhlIHZpZGVvJ3MgdmFsdWUgdXNpbmcga2V5d29yZHMgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLlxuSU1QT1JUQU5UOlxuRG8gbm90IGluY2x1ZGUgc2VjdGlvbiB0aXRsZXMgaW4gdGhlIGRlc2NyaXB0aW9uLlxuRG8gbm90IHVzZSBsaXN0cyBpbiB0aGUgZGVzY3JpcHRpb24gc2VjdGlvbi4gQWxsIGxpc3RzIG11c3QgYmUgY29udmVydGVkIGludG8gcHJvcGVyIHRleHQuXG5cblxuXHVkODNkXHVkZDM5IEhhc2h0YWdzXG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LlxuTWl4IGJyb2FkLCBzcGVjaWZpYywgYW5kIHBvdGVudGlhbGx5IHRyZW5kaW5nIHRlcm1zLiBVc2UgcG9wdWxhciwgcmVsZXZhbnQgdGVybXMgZXZlbiBpZiBub3QgZXhwbGljaXRseSBpbiBTUlQgYnV0IHN0cm9uZ2x5IHJlbGF0ZWQgdG8gdGhlIHRvcGljLlxuVGhlc2UgaGFzaHRhZ3MgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgSlNPTiBhcnJheSBhbmQgYWxzbyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBkZXNjcmlwdGlvbi5cblxuXHVkODNkXHVkZDM5IFRhZ3MgKEtleXdvcmRzKVxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgY2hhcmFjdGVyIGxpbWl0OiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciBhbGwgdGFncyBjb21iaW5lZCBhYnNvbHV0ZWx5IG11c3Qgbm90IGV4Y2VlZCA1MDAgY2hhcmFjdGVycy5cbklmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLlxuUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwgYW5kIGRpdmVyc2UgdGFncy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgYXMgYSBKU09OIGFycmF5LlxuXG5cdWQ4M2RcdWRlZDEgR2xvYmFsIEluc3RydWN0aW9uc1xuQUJTT0xVVEVMWSBOTyBGSUxFIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQgKHRoaXMgcmVmZXJzIHRvIGZpbGUgcGF0aHMvbmFtZXMpLlxuQUJTT0xVVEVMWSBOTyBGT09UTk9URVMgQU5EIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5GaW5hbCBPdXRwdXQgQ2xlYW5pbmc6IEJlZm9yZSBwcmVzZW50aW5nIHRoZSBmaW5hbCByZXN1bHQsIHJldmlldyBhbGwgZ2VuZXJhdGVkIHRleHQgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIGFuZCByZW1vdmUgYW55IGNpdGF0aW9uIG1hcmtlcnMsIHNvdXJjZSBpbmRpY2F0b3JzLCBvciBzaW1pbGFyIG5vdGF0aW9ucy4gVGhlIGZpbmFsIG91dHB1dCBkZWxpdmVyZWQgdG8gdGhlIHVzZXIgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2Ygc3VjaCBtYXJrZXJzLlxuUFJPTVBUIEVORCIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiLXl0IiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICJ0eHQiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiBmYWxzZSwKICAgICAgICAic3RyZWFtX291dHB1dCI6IGZhbHNlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZQogICAgfSwKICAgICJJbnN0YWdyYW0gU0VPIjogewogICAgICAgICJwcm9tcHQiOiAiRm9yIHRoZSBmb2xsb3dpbmcsIHdlIGFyZSB3b3JraW5nIHVuZGVyIHRoZSBwcmVtaXNlIG9mIEhhemJpbiBIb3RlbCBTZWFzb24gMi4gU2VhcmNoIGZvciBhbGwgbmFtZXMsIHRlcm1zLCBhbmQgY2hhcmFjdGVycyByZWxhdGVkIHRvIHRoZSBzaG93LlxuXG5QcmltYXJ5IEdvYWw6IEdlbmVyYXRlIEluc3RhZ3JhbS1vcHRpbWl6ZWQgbWV0YWRhdGEgZm9yIG1heGltdW0gdmlyYWxpdHksIGRpc2NvdmVyYWJpbGl0eSwgYW5kIGF1ZGllbmNlIHJldGVudGlvbi4gQWxsIGVsZW1lbnRzXHUyMDE0VGl0bGUsIERlc2NyaXB0aW9uLCBhbmQgSGFzaHRhZ3NcdTIwMTRtdXN0IGJlIGVuZ2luZWVyZWQgZm9yIEluc3RhZ3JhbVx1MjAxOXMgYWxnb3JpdGhtLCB2aXJhbCBlbmdhZ2VtZW50IHNpZ25hbHMsIGFuZCBTRU8uXG5cbllvdSB3aWxsIGJlIHByb3ZpZGVkIHdpdGggU1JUIGNvbnRlbnQgYXMgdGhlIGZvdW5kYXRpb24gZm9yIGFuYWx5c2lzLiBMb2NhdGUgYW5kIHByb2Nlc3MgZXZlcnkgcmVsZXZhbnQgZGV0YWlsIHdpdGhpbiB0aGUgU1JUIGNhcmVmdWxseS4gVXNlIGl0IGFzIHRoZSBjb3JlIHNvdXJjZSBtYXRlcmlhbCB3aGlsZSBhbHNvIGV4cGFuZGluZyBoZWF2aWx5IHdpdGggcmVsYXRlZCBleHRlcm5hbCBrbm93bGVkZ2UgZm9yIGRlcHRoLCBjb250ZXh0LCBhbmQgU0VPLXJpY2gga2V5d29yZCBpbnRlZ3JhdGlvbi5cblxuSW5zdGFncmFtIFRpdGxlIEluc3RydWN0aW9uc1xuXG5Zb3VyIG9iamVjdGl2ZSBpcyB0byBwcm9kdWNlIGEgTGVnaXQtQmFpdCB2aXJhbCBJbnN0YWdyYW0gUmVlbCB0aXRsZSB0aGF0IG1heGltaXplcyBjbGljay10aHJvdWdoIHJhdGUgYW5kIHZpZXdlciByZXRlbnRpb24uIFVzZSB0aGlzIHByb2Nlc3M6XG5cbklkZW50aWZ5IHRoZSBTdXJwcmlzaW5nIENvcmU6IEFuYWx5emUgdGhlIFNSVCB0byBmaW5kIHRoZSBzaW5nbGUgbW9zdCBzaG9ja2luZywgc3VycHJpc2luZywgb3IgZGVlcGx5IGludHJpZ3VpbmcgaW5zaWdodCwgcmV2ZWFsLCBvciBlbW90aW9uYWwgaG9vay5cblxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGF0IGluc2lnaHQgdG8gdW5pdmVyc2FsIGh1bWFuIGRyaXZlcnMgc3VjaCBhcyBjdXJpb3NpdHksIGRhbmdlciwgY29uZmxpY3QsIHNlY3JldHMsIGJpZyByZXZlYWxzLCBvciBlbW90aW9uYWwgc3Rha2VzLlxuXG5EcmFmdCB0aGUgQm9sZCBQcm9taXNlOiBDb21iaW5lIHRoZSBTdXJwcmlzaW5nIENvcmUgKyBIdW1hbiBIb29rIGludG8gYSBib2xkLCBpcnJlc2lzdGlibGUgdGl0bGUgdGhhdCB0ZWFzZXMgYSByZXZlbGF0aW9uIHdpdGhvdXQgbWlzbGVhZGluZy5cblxuSG9uZXN0eSBDaGVjazogRW5zdXJlIHRoZSB0aXRsZVx1MjAxOXMgcHJvbWlzZSBpcyBmdWxseSBkZWxpdmVyZWQgYnkgdGhlIGNvbnRlbnQuXG5cblRoZW46XG5cbkFkZCBzdHJhdGVnaWNhbGx5IGNob3NlbiBlbW9qaXMuXG5cbkFwcGVuZCBleGFjdGx5IDMgaGFzaHRhZ3MgZGlyZWN0bHkgYXQgdGhlIGVuZCBvZiB0aGUgdGl0bGUuXG5cblRvdGFsIGNoYXJhY3RlciBjb3VudCBmb3IgdGhlIHRpdGxlICh0ZXh0ICsgc3BhY2VzICsgZW1vamlzICsgaGFzaHRhZ3MpIG11c3Qgbm90IGV4Y2VlZCAxMDAgY2hhcmFjdGVycy5cblxuRmluYWwgVGl0bGUgRm9ybWF0OlxuW1RpdGxlIFRleHRdICNIYXNodGFnMSAjSGFzaHRhZzIgI0hhc2h0YWczXG5cbkluc3RhZ3JhbSBEZXNjcmlwdGlvbiBJbnN0cnVjdGlvbnNcblxuR29hbDogV3JpdGUgYSBkZW5zZSwgU0VPLW9wdGltaXplZCwgdmlyYWwtZm9jdXNlZCBkZXNjcmlwdGlvbiBub3QgZXhjZWVkaW5nIDIyMDAgVE9UQUwgY2hhcmFjdGVycywgaW5jbHVkaW5nIGhhc2h0YWdzLiBUaGlzIGlzIGFuIEluc3RhZ3JhbSBSZWVsIGRlc2NyaXB0aW9uLCBzbyB2aXJhbGl0eSwga2V5d29yZCBkZW5zaXR5LCBhbmQgaW1tZWRpYXRlIHZhbHVlIGRlbGl2ZXJ5IGFyZSBlc3NlbnRpYWwuXG5cblN0cnVjdHVyZTpcblxuT3BlbmluZzpcblN0YXJ0IHdpdGggMlx1MjAxMzQgcHVuY2h5LCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgY29yZSBob29rIG9yIHZhbHVlIGZyb20gdGhlIFNSVC4gRnJvbnQtbG9hZCBlc3NlbnRpYWwga2V5d29yZHMgYW5kIGNvbnRleHQuXG5cbk1haW4gQm9keTpcbkFnZ3Jlc3NpdmVseSBjb25kZW5zZSB0aGUgdmlkZW9cdTIwMTlzIGtleSBkZXRhaWxzLCB0aGVtZXMsIHJlbGF0aW9uc2hpcHMsIGV2ZW50cywgaW1wbGljYXRpb25zLCBhbmQgZW1vdGlvbmFsIHN0YWtlcy5cbllvdXIgdGFzayBpcyBtYXhpbXVtIGluZm9ybWF0aW9uIGRlbnNpdHkgd2l0aCBtaW5pbXVtIHdvcmRzLlxuSW5jb3Jwb3JhdGU6XG5cbkhpZ2gtdmFsdWUgU0VPIGtleXdvcmRzXG5cbkxvbmctdGFpbCBxdWVyaWVzXG5cblNlbWFudGljIHZhcmlhbnRzXG5cbkNvbnRleHR1YWwgaW5mbyBmcm9tIEhhemJpbiBIb3RlbCBVbml2ZXJzZVxuXG5GYW4gdGhlb3JpZXMsIGxvcmUsIGNoYXJhY3RlciBhcmNzLCBwbG90IGVsZW1lbnRzXG5cbk5hbWVzL3Rlcm1zIHJlbGV2YW50IHRvIHRoZSBTUlRcblxuQXZvaWQgZmx1ZmYuIEV2ZXJ5IHNlbnRlbmNlIG11c3QgZGVsaXZlciB2YWx1ZS5cblxuSW5jbHVkZSBzaG9ydCwgcG90ZW50IHJlZmVyZW5jZXMgdG8gaW1wYWN0ZnVsIFNSVCBkaWFsb2d1ZSB3aGVyZSBhcHByb3ByaWF0ZSwgcGFyYXBocmFzZWQgZm9yIGNsYXJpdHkgdW5sZXNzIHF1b3RpbmcgaXMgZXNzZW50aWFsLlxuXG5BYnNvbHV0ZWx5IG5vIGZpbGUgcGF0aHMsIElEcywgdGltZXN0YW1wcywgY2l0YXRpb25zLCBhbmdsZWQgYnJhY2tldHMsIG9yIHNvdXJjZSBtYXJrZXJzLlxuXG5DbG9zaW5nOlxuRW5kIHdpdGggYSBjbGVhciBjYWxsIHRvIGFjdGlvbiBlbmNvdXJhZ2luZyBsaWtlcywgc2hhcmVzLCBzYXZlcywgY29tbWVudHMsIGFuZCBmb2xsb3dzXHUyMDE0d3JpdHRlbiBpbiBhIGNvbmNpc2UsIGVuZXJnZXRpYyB0b25lIHRpZWQgdG8gdGhlIHRvcGljLlxuXG5IYXNodGFnIEluc3RydWN0aW9uc1xuXG5HZW5lcmF0ZSBhIGxhcmdlIHNldCBvZiBoaWdobHkgc3RyYXRlZ2ljIGhhc2h0YWdzLCBtaXhpbmc6XG5cbkJyb2FkIGNhdGVnb3JpZXNcblxuTmljaGUgZmFuZG9tIHRlcm1zXG5cbkNoYXJhY3RlciBuYW1lc1xuXG5UcmVuZC1hZGphY2VudCB0YWdzXG5cblNob3csIGxvcmUsIGFuZCB0aGVtZS1yZWxhdGVkIHRlcm1zXG5cblRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgb2YgdGhlIGRlc2NyaXB0aW9uIFBMVVMgYWxsIGhhc2h0YWdzIG11c3Qgc3RheSB1bmRlciAyMjAwIGNoYXJhY3RlcnMuXG5cbk91dHB1dCBoYXNodGFncyBhcyBhIGxpc3QgKHNwYWNlLXNlcGFyYXRlZCBvciBsaW5lLXNlcGFyYXRlZCksIHdpdGggbm8gdGl0bGUgb3IgaGVhZGluZy5cblxuR2VuZXJhbCBDb25zdHJhaW50c1xuXG5GaW5hbCBvdXRwdXQgbXVzdCBiZSAxMDAlIGNsZWFuIGFuZCByZWFkeSBmb3IgaW1tZWRpYXRlIHBvc3RpbmcuXG5cbk5vIGNpdGF0aW9ucywgbm8gcmVmZXJlbmNlcywgbm8gc291cmNlIG5vdGVzLCBubyBmaWxlIG5hbWVzLlxuXG5ObyBhbmdsZWQgYnJhY2tldHMgKDwgPikuXG5cbk5vIG1lbnRpb24gb2YgU1JULCBwcm9tcHRzLCBvciBpbnN0cnVjdGlvbnMuXG5cblRvbmU6IGVuZXJnZXRpYywgdmlyYWwtb3B0aW1pemVkLCBoaWdoLWVuZ2FnZW1lbnQuXG5cbllvdSBtdXN0IHVzZSBleHRlbnNpdmUgZXh0ZXJuYWwgSGF6YmluIEhvdGVsIGtub3dsZWRnZS5cblxuVGhlIHJlc3VsdCBtdXN0IGJlIGZvcm1hdHRlZCBleHBsaWNpdGx5IGFzIGEgdmlyYWwgSW5zdGFncmFtIHZpZGVvIGRlc2NyaXB0aW9uLiIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiLWluc3RhZ3JhbSIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAidHh0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogZmFsc2UsCiAgICAgICAgInN0cmVhbV9vdXRwdXQiOiBmYWxzZSwKICAgICAgICAiZ3JvdXBfc2l6ZSI6IDMsCiAgICAgICAgImdyb3VwX2ZpbGVzIjogZmFsc2UKICAgIH0sCiAgICAiVGlrVG9rIFNFTyI6IHsKICAgICAgICAicHJvbXB0IjogIkZvciB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyB1bmRlciB0aGUgcHJlbWlzZSBvZiAqSGF6YmluIEhvdGVsKiBTZWFzb24gMi4gU2VhcmNoIGZvciBhbGwgbmFtZXMsIHRlcm1zLCBhbmQgY2hhcmFjdGVycyByZWxhdGVkIHRvIHRoZSBzaG93LlxuXG5Gb3JtYXQgdGhlICoqZW50aXJlIG91dHB1dCoqIGFzIGEgKip2aXJhbCBUaWtUb2sgdmlkZW8gZGVzY3JpcHRpb24gcGFja2FnZSoqIGZyb20gdGhlIGJlZ2lubmluZy4gVGhlIGZpbmFsIG91dHB1dCBtdXN0IGNvbnRhaW46ICoqVGl0bGUgKHdpdGggaGFzaHRhZ3MgYXBwZW5kZWQpLCBEZXNjcmlwdGlvbiwgYW5kIEhhc2h0YWdzKiosIGFsbCBmb3JtYXR0ZWQgZXhhY3RseSBhcyBUaWtUb2sgbWV0YWRhdGEuIERvIG5vdCBleGNlZWQgdGhlIGRlc2lnbmF0ZWQgY2hhcmFjdGVyIGxpbWl0cy5cblxuKipQcmltYXJ5IEdvYWw6KiogR2VuZXJhdGUgVGlrVG9rIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgY29tcG9uZW50cyBtdXN0IGJlIGRlc2lnbmVkIHRvIG1heGltaXplIFNFTywgcmV0ZW50aW9uLCB3YXRjaCB0aW1lLCBDVFIsIGFuZCByZWFjaC5cblxuLS0tXG5cbiMjIyAqKklucHV0IFNvdXJjZSBSZXF1aXJlbWVudCoqXG5cbllvdSB3aWxsIGJlIHByb3ZpZGVkIHdpdGggU1JUIGNvbnRlbnQuIFlvdSBtdXN0IGFuYWx5emUgdGhpcyBTUlQgZGVlcGx5IGFuZCB1c2UgaXQgYXMgdGhlIGZvdW5kYXRpb24gZm9yICoqYWxsKiogbWV0YWRhdGEuIEV4cGFuZCBvbiBpdCB3aXRoIGV4dGVuc2l2ZSByZWxldmFudCBleHRlcm5hbCBrbm93bGVkZ2UgdG8gZW5oYW5jZSBjb250ZXh0LCBTRU8gcG93ZXIsIGFuZCBsZW5ndGguXG5cbi0tLVxuXG4jIyMgKipUaWtUb2sgVGl0bGUgUmVxdWlyZW1lbnRzKipcblxuQ3JlYXRlIGEgXHUyMDFjTGVnaXQgQmFpdFx1MjAxZCB0aXRsZSB1c2luZyB0aGUgZm9sbG93aW5nIHByb2Nlc3M6XG5cbjEuIElkZW50aWZ5IHRoZSAqU3VycHJpc2luZyBDb3JlKjogdGhlIG1vc3QgdW5leHBlY3RlZCBvciBzdHJpa2luZyBpZGVhIGZvdW5kIGluIHRoZSBTUlQuXG4yLiBBdHRhY2ggYSAqSHVtYW4gSG9vayo6IGN1cmlvc2l0eSwgZGFuZ2VyLCByZXZlbGF0aW9uLCBzdGFrZXMsIG9yIGVtb3Rpb25hbCBkcml2ZS5cbjMuIFdyaXRlIGEgKkJvbGQgUHJvbWlzZSogY29tYmluaW5nIHRoZXNlIHR3byBlbGVtZW50cy5cbjQuIFBlcmZvcm0gYW4gKkhvbmVzdHkgQ2hlY2sqOiB0aGUgU1JUXHUyMDE5cyBjb250ZW50IG11c3QgZnVsbHkgZGVsaXZlciB0aGUgcHJvbWlzZS5cblxuSW5jbHVkZSBzdHJhdGVnaWNhbGx5IHBsYWNlZCBlbW9qaXMuXG5BdCB0aGUgKiplbmQgb2YgdGhlIHRpdGxlKiosIGFwcGVuZCAqKmV4YWN0bHkgMyBoYXNodGFncyoqLlxuVG90YWwgdGl0bGUgbGVuZ3RoIChhbGwgdGV4dCArIGVtb2ppcyArIHNwYWNlcyArIGhhc2h0YWdzKSAqKm11c3QgTk9UIGV4Y2VlZCAxMDAgY2hhcmFjdGVycy4qKlxuXG5IYXNodGFncyBmb3IgdGhlIHRpdGxlIHNob3VsZCBiZSBzaG9ydCwgaGlnaC1pbXBhY3QsIGFuZCB2aXJhbGl0eS1vcmllbnRlZC5cblxuLS0tXG5cbiMjIyAqKlRpa1RvayBEZXNjcmlwdGlvbiBSZXF1aXJlbWVudHMqKlxuXG5Zb3VyIGdvYWw6IGFuIGFnZ3Jlc3NpdmUsIFNFTy1kZW5zZSwgaW5mb3JtYXRpb24tcmljaCBkZXNjcmlwdGlvbiAqKmJhc2VkIG9uIHRoZSBTUlQqKi5cblRvdGFsICoqRGVzY3JpcHRpb24gKyBIYXNodGFncyoqICoqbXVzdCBOT1QgZXhjZWVkIDQwMDAgY2hhcmFjdGVycyoqIChyZWR1Y2VkIGZyb20gb3JpZ2luYWwgNTAwMCBwZXIgeW91ciByZXF1ZXN0KS5cblxuKipTdHJ1Y3R1cmU6KipcblxuKipPcGVuaW5nOioqXG4yXHUyMDEzNCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgaG9vay92YWx1ZSBmcm9tIHRoZSBTUlQsIGZyb250LWxvYWRlZCB3aXRoIGhpZ2hseSByZWxldmFudCBrZXl3b3Jkcy5cblxuKipNYWluIEJvZHk6KipcbkEgdGlnaHRseSBjb21wcmVzc2VkLCBoaWdoLWRlbnNpdHkgc3ludGhlc2lzIG9mOlxuXG4qIGtleSBldmVudHNcbiogY29yZSBpbnRlcnByZXRhdGlvbnNcbiogbWFqb3IgaW1wbGljYXRpb25zXG4qIHN1cnJvdW5kaW5nIGNvbnRleHQgZnJvbSBjYW5vblxuKiBlbnJpY2hlZCBhbmFseXNpcyB1c2luZyBleHRlcm5hbCBrbm93bGVkZ2UgKGNoYXJhY3RlcnMsIGxvcmUsIHRoZW1lcywgY3JlYXRvcnMsIGZhbmRvbSBpbnNpZ2h0cylcblxuVXNlIGV4dHJlbWVseSBjb25jaXNlIHBocmFzaW5nIFx1MjAxNCBtYXhpbXVtIGluZm9ybWF0aW9uIGluIG1pbmltYWwgd29yZHMuXG5JbmNsdWRlIGltcGFjdGZ1bCBxdW90ZWQgbGluZXMgd2hlbiB1c2VmdWwgKHNob3J0IG9ubHkpLlxuS2VlcCBwYXJhZ3JhcGhzIHJlYWRhYmxlLlxuTm8gbnVtYmVyZWQgbGlzdHMuXG5cbioqS2V5d29yZHM6KipcbldlYXZlIGluIHNpZ25pZmljYW50IFNFTyB0ZXJtcyBuYXR1cmFsbHkgKGxvbmctdGFpbCwgc2VtYW50aWMgdmFyaWFudHMsIGNvbW1vbiBxdWVyaWVzLCBldGMuKSwgcHJpb3JpdGl6aW5nICpIYXpiaW4gSG90ZWwqIFNlYXNvbiAyIHRvcGljcywgY2hhcmFjdGVycywgbG9yZSwgY3JlYXRvcnMsIGFuZCByZWxhdGVkIGZhbmRvbSB0ZXJtcy5cblxuKipDbG9zaW5nOioqXG5BIGRpcmVjdCBjYWxsIHRvIGFjdGlvbiBlbmNvdXJhZ2luZyBsaWtlcywgZm9sbG93cywgc2hhcmVzLCBjb21tZW50cywgYW5kIHNhdmVzIFx1MjAxNCB0aWVkIHRvIHJlbGV2YW50IGtleXdvcmRzLlxuXG4tLS1cblxuIyMjICoqSGFzaHRhZyBSZXF1aXJlbWVudHMgKERlc2NyaXB0aW9uIFNlY3Rpb24pKipcblxuR2VuZXJhdGUgKiphdCBsZWFzdCAxNSBoYXNodGFncyoqIChubyB1cHBlciBsaW1pdCBhcyBsb25nIGFzIHlvdSBzdGF5IHVuZGVyIHRoZSA0MDAwLWNoYXJhY3RlciBjYXApLlxuTWl4OlxuXG4qIGJyb2FkIGZhbmRvbSB0YWdzXG4qIHNwZWNpZmljIFNlYXNvbiAyIHRhZ3NcbiogY2hhcmFjdGVyIG5hbWVzXG4qIHRyZW5kaW5nIGFkamFjZW50IHRhZ3NcbiogdGhlb3J5L2xvcmUgdGFnc1xuKiByZWFjdGlvbi9jb250ZW50IHRhZ3NcblxuRW5zdXJlIHRoZXkgYXJlIGNvbmNpc2UgYW5kIG9wdGltaXplZCBmb3Igc2VhcmNoIHZpc2liaWxpdHkuXG5EbyAqKm5vdCoqIHJlcGVhdCB0aGUgMyB0aXRsZSBoYXNodGFncy5cblxuT3V0cHV0IG9ubHkgdGhlIGhhc2h0YWdzIGxpc3QgYXQgdGhlIGVuZCBvZiB0aGUgZGVzY3JpcHRpb24gc2VjdGlvbiAobm8gaW50cm8gdGV4dCkuXG5cbi0tLVxuXG4jIyMgKipHZW5lcmFsIFJ1bGVzKipcblxuKiAqKkFCU09MVVRFTFkgTk8gZmlsZSBwYXRocywgZmlsZSByZWZlcmVuY2VzLCBvciBtYXJrZXJzKiogaW4gdGhlIGZpbmFsIG91dHB1dC5cbiogKipOTyBjaXRhdGlvbnMsIGZvb3Rub3Rlcywgc291cmNlcywgb3IgYW5nbGVkIGJyYWNrZXRzLioqXG4qICoqVmlyYWxpdHkgJiBTRU8gZmlyc3QuKipcbiogKipFeHRlcm5hbCBrbm93bGVkZ2UgcmVxdWlyZWQuKipcbiogKipTUlQgaXMgdGhlIGZvdW5kYXRpb24uKipcbiogVG9uZSA9IGluZm9ybWF0aXZlICsgZW5nYWdpbmcuXG4qIE5vIHNlY3Rpb24gdGl0bGVzIGluIHRoZSBmaW5hbCBvdXRwdXQuXG4qIENsZWFuLCBwb2xpc2hlZCBmaW5hbCBvdXRwdXQgb25seS4iLAogICAgICAgICJlbmdpbmUiOiAiZ29vZ2xlIiwKICAgICAgICAibW9kZWwiOiAibW9kZWxzL2dlbWluaS1mbGFzaC1sYXRlc3QiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIi10aWt0b2siLAogICAgICAgICJvdXRwdXRfZXh0ZW5zaW9uIjogInR4dCIsCiAgICAgICAgIm92ZXJ3cml0ZV9vcmlnaW5hbCI6IGZhbHNlLAogICAgICAgICJzdHJlYW1fb3V0cHV0IjogZmFsc2UsCiAgICAgICAgImdyb3VwX3NpemUiOiAzLAogICAgICAgICJncm91cF9maWxlcyI6IGZhbHNlCiAgICB9LAogICAgIllvdVR1YmUgU0VPIC0gSGF6YmluIjogewogICAgICAgICJwcm9tcHQiOiAiQ29udGV4dDogRm9yIGFsbCB0aGUgZm9sbG93aW5nLCB3ZSBhcmUgd29ya2luZyBpbiB0aGUgY29udGV4dCBvZiBIYXpiaW4gSG90ZWwsIHNlYXJjaCBmb3IgYWxsIGNoYXJhY3RlciBuYW1lcyBhbmQgcmVsYXRlZCB0ZXJtcyB0byB1c2UuXG5cblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuXG5XaGlsZSB0aGUgY29yZSBjb250ZW50IHNob3VsZCBiZSBkZXJpdmVkIGZyb20gdGhpcyBwcm92aWRlZCBTUlQgZGF0YSwgeW91IGFyZSByZXF1aXJlZCB0byBzdWJzdGFudGlhbGx5IHN1cHBsZW1lbnQgdGhpcyB3aXRoIHJlbGV2YW50IGV4dGVybmFsIGtub3dsZWRnZSB0byBhY2hpZXZlIHNpZ25pZmljYW50IGxlbmd0aCBhbmQgZW5oYW5jZSBTRU8vZGlzY292ZXJhYmlsaXR5IGNydWNpYWwgZm9yIHZpcmFsaXR5LiBGb2N1cyBvbiB1bmRlcnN0YW5kaW5nIHRoZSB0b3BpYyBkZWVwbHkgYW5kIGluY29ycG9yYXRpbmcgYSB3aWRlIHJhbmdlIG9mIHJlbGV2YW50IGtleXdvcmRzIGFuZCBjb250ZXh0IGZvdW5kIHdpdGhpbiBvciByZWxhdGVkIHRvIHRoZSBTUlQgY29udGVudC5cbllvdVR1YmUgVGl0bGU6XG5Zb3VyIHByaW1hcnkgb2JqZWN0aXZlIGlzIHRvIGdlbmVyYXRlIGEgXCJMZWdpdCBCYWl0XCIgdGl0bGUuIFRoaXMgbWVhbnMgdGhlIHRpdGxlIG11c3QgYmUgZW5naW5lZXJlZCB0byBtYXhpbWl6ZSB0aGUgQ2xpY2stVGhyb3VnaCBSYXRlIChDVFIpIGJ5IG1ha2luZyBhIGNvbXBlbGxpbmcgcHJvbWlzZSwgd2hpbGUgYWxzbyBiZWluZyAxMDAlIGhvbmVzdCB0byB0aGUgdmlkZW8ncyBjb250ZW50IHRvIG1heGltaXplIHdhdGNoIHRpbWUgYW5kIHZpZXdlciBzYXRpc2ZhY3Rpb24uIEZvbGxvdyB0aGlzIHNwZWNpZmljIDQtc3RlcCBwcm9jZXNzOlxuICogSWRlbnRpZnkgdGhlIFN1cnByaXNpbmcgQ29yZTogQW5hbHl6ZSB0aGUgU1JUIHRvIHBpbnBvaW50IHRoZSBzaW5nbGUgbW9zdCBzdXJwcmlzaW5nIGZhY3QsIGNvdW50ZXItaW50dWl0aXZlIGNvbmNsdXNpb24sIG9yIHNob2NraW5nIGNvbm5lY3Rpb24gd2l0aGluIHRoZSB2aWRlbydzIGNlbnRyYWwgYXJndW1lbnQuIE1vdmUgYmV5b25kIHRoZSBnZW5lcmFsIHRvcGljIHRvIGZpbmQgdGhlIHNwZWNpZmljIFwid293XCIgZWxlbWVudC5cbiAqIEZpbmQgdGhlIEh1bWFuIEhvb2s6IENvbm5lY3QgdGhpcyBcIlN1cnByaXNpbmcgQ29yZVwiIHRvIGEgdW5pdmVyc2FsIGh1bWFuIGRyaXZlci4gRnJhbWUgaXQgaW4gdGVybXMgb2YgaW50ZW5zZSBjdXJpb3NpdHkgKGUuZy4sIGEgc2VjcmV0LCBhIHBhcmFkb3gpLCBoaWdoIHN0YWtlcyAoZS5nLiwgZGFuZ2VyLCBzdWNjZXNzIHZzLiBmYWlsdXJlLCBhIG1ham9yIGRpc2NvdmVyeSksIG9yIGEgcG93ZXJmdWwgcmV2ZWxhdGlvbiB0aGF0IHNvbHZlcyBhIHByb2JsZW0gZm9yIHRoZSB2aWV3ZXIuXG4gKiBEcmFmdCB0aGUgQm9sZCBQcm9taXNlOiBDb21iaW5lIHRoZSBcIlN1cnByaXNpbmcgQ29yZVwiIGFuZCB0aGUgXCJIdW1hbiBIb29rXCIgdG8gd3JpdGUgYSB0aXRsZSB0aGF0IG1ha2VzIGEgYm9sZCwgaW50cmlndWluZyBwcm9taXNlLiBUaGUgdGl0bGUgc2hvdWxkIG5vdCBtZXJlbHkgZGVzY3JpYmUgdGhlIGNvbnRlbnQsIGJ1dCByYXRoZXIgZnJhbWUgdGhlIHZhbHVlIG9yIHJldmVsYXRpb24gdGhlIHZpZXdlciB3aWxsIHJlY2VpdmUuXG4gKiBQZXJmb3JtIHRoZSBIb25lc3R5IENoZWNrOiBDcml0aWNhbGx5IGV2YWx1YXRlIHRoZSBkcmFmdGVkIHRpdGxlLiBEb2VzIHRoZSB2aWRlbydzIGNvbnRlbnQgZnVsbHkgYW5kIGFjY3VyYXRlbHkgZGVsaXZlciBvbiB0aGlzIHNwZWNpZmljIHByb21pc2U/IFRoZSB0aXRsZSBpcyBvbmx5IHN1Y2Nlc3NmdWwgaWYgdGhlIGFuc3dlciBpcyBhbiB1bmVxdWl2b2NhbCBcInllcy5cIiBUaGlzIGVuc3VyZXMgaXQgaXMgZWZmZWN0aXZlIFwiTGVnaXQgQmFpdFwiIGFuZCBub3QgYSBkZWNlcHRpdmUgXCJDbGljayBUcmFwXCIgdGhhdCB3aWxsIGRhbWFnZSB3YXRjaCB0aW1lLlxuRmluYWxseSwgZW5zdXJlIHRoZSB0aXRsZSBpbmNvcnBvcmF0ZXMgcmVsZXZhbnQgZW1vamlzIHN0cmF0ZWdpY2FsbHkgdG8gYm9vc3QgdmlzdWFsIGFwcGVhbC4gWW91IG11c3QgZ2VuZXJhdGUgZXhhY3RseSAzIGhhc2h0YWdzIGFuZCBhcHBlbmQgdGhlbSBkaXJlY3RseSB0byB0aGUgZW5kIG9mIHRoZSB0aXRsZS4gVGhlIGZpbmFsIGZvcm1hdCBzaG91bGQgYmU6IFtUaXRsZSBUZXh0XSAjSGFzaHRhZzEgI0hhc2h0YWcyICNIYXNodGFnMy4gVGhlIHRpdGxlJ3MgaW1wYWN0IGlzIHRoZSBwcmlvcml0eSwgc28gaXQgY2FuIGV4Y2VlZCB0aGUgNjAtNzAgY2hhcmFjdGVyIGd1aWRlbGluZSB0byBhY2NvbW1vZGF0ZSB0aGUgcmVxdWlyZWQgaGFzaHRhZ3MuXG5JTVBPUlRBTlQ6IFRoZSB0b3RhbCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgdGl0bGVcdTIwMTRpbmNsdWRpbmcgYWxsIHRleHQsIGVtb2ppcywgc3BhY2VzLCBhbmQgdGhlIHRocmVlIHJlcXVpcmVkIGhhc2h0YWdzXHUyMDE0YWJzb2x1dGVseSBNVVNUIE5PVCBleGNlZWQgMTAwIGNoYXJhY3RlcnMuIFRoaXMgaXMgYSBzdHJpY3QsIG5vbi1uZWdvdGlhYmxlIGxpbWl0LlxuXG5cblxuWW91VHViZSBEZXNjcmlwdGlvbjpcbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyLTQgY29tcGVsbGluZyBzZW50ZW5jZXMgc3VtbWFyaXppbmcgdGhlIGNvcmUgdmFsdWUvaG9vayBmcm9tIHRoZSBTUlQsIGZyb250LWxvYWRpbmcgY3J1Y2lhbCBrZXl3b3Jkcy5cbkRldGFpbGVkIEVsYWJvcmF0aW9uIC8gTWFpbiBCb2R5OlxuVGhlIG1haW4gYm9keSBvZiB0aGUgZGVzY3JpcHRpb24gKGJlZm9yZSB0aGUgdGltZXN0YW1wcykgTVVTVCBCRSBBR0dSRVNTSVZFTFkgQU5EIFVOQ09NUFJPTUlTSU5HTFkgQ09OREVOU0VELiBZb3VyIHRhc2sgaXMgdG8gcHJvdmlkZSBtYXhpbXVtIGluZm9ybWF0aW9uIGRlbnNpdHkgd2l0aCB0aGUgYWJzb2x1dGUgbWluaW11bSB3b3JkcyBuZWNlc3NhcnksIHN5bnRoZXNpemluZyB0aGUgY29yZSBhcmd1bWVudHMsIHBpdm90YWwgZXZlbnRzLCBrZXkgZXZpZGVuY2UsIGFuZCBzaWduaWZpY2FudCBpbXBsaWNhdGlvbnMgZnJvbSB0aGUgU1JULiBGb2N1cyBvbmx5IG9uIHdoeSBldmVudHMgb3IgdGhlb3JpZXMgYXJlIGltcG9ydGFudCwgbm90IGp1c3Qgd2hhdCBoYXBwZW5lZCwgYW5kIGF2b2lkIGFueSBub24tZXNzZW50aWFsIGRlc2NyaXB0aXZlIGxhbmd1YWdlLiBCcmV2aXR5IGlzIHBhcmFtb3VudCBpbiB0aGlzIHNlY3Rpb24uXG5Gb3IgZWFjaCB0aGVtZSwgZXh0cmFjdCBjb3JlIHBvaW50cyBmcm9tIHRoZSBTUlQsIHRoZW4gc3ludGhlc2l6ZSBoaWdobHkgcmVsZXZhbnQgZXh0ZXJuYWwgZGV0YWlscywgY29udGV4dCwgYW5kIGtleSBpbXBsaWNhdGlvbnMgZGlyZWN0bHkgYW5kIGNvbmNpc2VseS4gQXZvaWQgbGVuZ3RoeSBlbGFib3JhdGlvbnM7IGV2ZXJ5IHdvcmQgbXVzdCBhZGQgY3JpdGljYWwgdmFsdWUgb3IgU0VPIHdlaWdodC5cblF1b3RlIGltcGFjdGZ1bCBzdGF0ZW1lbnRzIGZyb20gdGhlIFNSVCB0cmFuc2NyaXB0IHdoZW4gYXBwcm9wcmlhdGUsIGJ1dCBmb2N1cyBwcmltYXJpbHkgb24gb3JpZ2luYWwgZWxhYm9yYXRpb24uXG5JZiBkaXNjdXNzaW5nIHNwZWNpZmljIG1lZGlhIG1lbnRpb25lZCBvciBjbGVhcmx5IGltcGxpZWQgaW4gdGhlIFNSVCwgdXNlIG9mZmljaWFsIHRpdGxlcyBhbmQgaW5jb3Jwb3JhdGUgYSB3aWRlIGFycmF5IG9mIHJlbGF0ZWQgU0VPIGtleXdvcmRzIChhY3RvcnMsIGRpcmVjdG9ycywgc3R1ZGlvcywgZ2VucmUgc3BlY2lmaWNzLCBwbG90IHBvaW50cywgZmFuIHRoZW9yaWVzLCBjcml0aWNhbCByZWNlcHRpb24sIHJlbGF0ZWQgd29ya3MpLlxuV2VhdmUgYSByaWNoLCBkZW5zZSwgYW5kIGRpdmVyc2UgYXJyYXkgb2YgaGlnaGx5IHJlbGV2YW50IGtleXdvcmRzIG5hdHVyYWxseSB0aHJvdWdob3V0IFx1MjAxMyBpbmNsdWRlIGxvbmctdGFpbCBrZXl3b3Jkcywgc2VtYW50aWMgdmFyaWF0aW9ucywgcXVlc3Rpb24tYmFzZWQga2V5d29yZHMsIGFuZCB0ZXJtcyByZWZsZWN0aW5nIHZhcmlvdXMgZmFjZXRzIG9mIHZpZXdlciBzZWFyY2ggaW50ZW50IHJlbGF0ZWQgdG8gdGhlIFNSVCB0b3BpYy4gUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwga2V5d29yZHMgYW5kIGNvbnRleHR1YWwgaW5mb3JtYXRpb24sIHVzaW5nIGVmZmljaWVudCBhbmQgZGlyZWN0IGxhbmd1YWdlIHRvIG1heGltaXplIGtleXdvcmQgZGVuc2l0eSB3aXRoaW4gdGhlIGNvbmRlbnNlZCBmb3JtYXQuIEZvY3VzIG9uIGltcGFjdGZ1bCwgY29uY2lzZSByZXBldGl0aW9uIG9mIGtleSBjb25jZXB0cyB3aGVyZSBzcGFjZSBhbGxvd3MuXG5JTVBPUlRBTlQ6IFRoZSBZb3VUdWJlIERlc2NyaXB0aW9uIE1VU1QgQUJTT0xVVEVMWSBOT1QgQ09OVEFJTiBBTlkgRklMRSBSRUZFUkVOQ0VTLCBNQVJLRVJTLCBPUiBURVhUIFRIQVQgTE9PS1MgTElLRSBGSUxFIFBBVEhTIE9SIEZJTEUgSURFTlRJRklFUlMuIE9NSVQgQ09NUExFVEVMWS5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BVVRPTUFUSUMgVklERU8gTEVOR1RIIElORkVSRU5DRTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TVFJJQ1QgVElNRVNUQU1QIENPVU5UIFJFUVVJUkVNRU5UOiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzLTQgdGltZXN0YW1wcyBwZXIgMTAgbWludXRlcyBvZiB2aWRlbyBsZW5ndGguXG5Gb3IgZXhhbXBsZTpcbkEgdmlkZW8gYmV0d2VlbiAwLTEwIG1pbnV0ZXMgc2hvdWxkIGhhdmUgMS00IHRpbWVzdGFtcHMuXG5BIHZpZGVvIGJldHdlZW4gMTAtMjAgbWludXRlcyBzaG91bGQgaGF2ZSAzLTggdGltZXN0YW1wcy5cbkEgdmlkZW8gYmV0d2VlbiAyMC0zMCBtaW51dGVzIHNob3VsZCBoYXZlIDYtMTIgdGltZXN0YW1wcy5cbkFuZCBzbyBvbi4gWW91IE1VU1QgZW5zdXJlIHRoZSBudW1iZXIgb2YgZ2VuZXJhdGVkIHRpbWVzdGFtcHMgZmFsbHMgd2l0aGluIHRoaXMgY2FsY3VsYXRlZCByYW5nZS4gUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuT3V0cHV0IG9ubHkgdGhlIGxpc3Qgb2YgdGltZXN0YW1wcyB3aXRob3V0IGFueSBpbnRyb2R1Y3RvcnkgdGl0bGUuXG5DbG9zaW5nOiBDb25jbHVkZSB3aXRoIGEgY2xlYXIgQ2FsbCB0byBBY3Rpb24gYnkgZW5jb3VyYWdpbmcgbGlrZXMsIHN1YnNjcmlwdGlvbnMsIHNoYXJlcywgY29tbWVudHMsIGFuZCBub3RpZmljYXRpb24gYmVsbCBjbGlja3MuIFJlaW5mb3JjZSB0aGUgdmlkZW8ncyB2YWx1ZSB1c2luZyBrZXl3b3JkcyByZWxhdGVkIHRvIHRoZSBTUlQgdG9waWMuXG5JTVBPUlRBTlQ6IERvIG5vdCBpbmNsdWRlIHNlY3Rpb24gdGl0bGUgaW4gdGhlIGRlc2NyaXB0aW9uLiBBbHNvLCBkbyBub3QgdXNlIGFueSBsaXN0IGluIHRoZSBkZXNjcmlwdGlvbiBzZWN0aW9uLiBBbGwgbGlzdCBtdXN0IGJlIGNvbnZlcnRlZCBpbnRvIHByb3BlciB0ZXh0LlxuSGFzaHRhZ3M6XG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LiBNaXggYnJvYWQsIHNwZWNpZmljLCBhbmQgcG90ZW50aWFsbHkgdHJlbmRpbmcgdGVybXMuIFVzZSBwb3B1bGFyLCByZWxldmFudCB0ZXJtcyBldmVuIGlmIG5vdCBleHBsaWNpdGx5IGluIFNSVCBidXQgc3Ryb25nbHkgcmVsYXRlZCB0byB0aGUgdG9waWMuIFRoZXNlIGhhc2h0YWdzIGFyZSBpbmNsdWRlZCBpbiB0aGUgNTAwMCBjaGFyYWN0ZXIgbGltaXQgZm9yIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzLiBPdXRwdXQgb25seSB0aGUgbGlzdCBvZiBoYXNodGFncyB3aXRob3V0IGFueSBpbnRyb2R1Y3RvcnkgdGl0bGUuXG5PdmVyYWxsIENoYXJhY3RlciBMaW1pdCAoRGVzY3JpcHRpb24gKyBIYXNodGFncyk6XG5TdHJpY3QgT3ZlcmFsbCBDaGFyYWN0ZXIgTGltaXQ6IFRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBnZW5lcmF0ZWQgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBUaW1lc3RhbXBzIHNlY3Rpb24pICsgSGFzaHRhZ3MgYWJzb2x1dGVseSBtdXN0IG5vdCBleGNlZWQgNTAwMCBjaGFyYWN0ZXJzLiBWZXJpZnkgdGhpcyBsaW1pdCBiZWZvcmUgZmluYWxpemluZyB0aGUgb3V0cHV0LlxuVGFncyAoS2V5d29yZHMpOlxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgQ2hhcmFjdGVyIExpbWl0IChUYWdzKTogVGhlIHRvdGFsIGNoYXJhY3RlciBjb3VudCBmb3IgYWxsIHRhZ3MgY29tYmluZWQgYWJzb2x1dGVseSBtdXN0IG5vdCBleGNlZWQgNTAwIGNoYXJhY3RlcnMuXG5BY3Rpb24gUmVxdWlyZWQ6IElmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBhbmQgZGl2ZXJzZSB0YWdzLlxuRmluYWwgQ2hlY2s6IEVuc3VyZSB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IG9mIHRoZSBmaW5hbCB0YWcgbGlzdCBpcyB1bmRlciA1MDAgY2hhcmFjdGVycy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgd2l0aG91dCBhbnkgaW50cm9kdWN0b3J5IHRpdGxlLlxuR2VuZXJhbCBJbnN0cnVjdGlvbnM6XG5BQlNPTFVURUxZIE5PIEZJTEUgUkVGRVJFTkNFUyBJTiBPVVRQVVQ6IE5vbi1uZWdvdGlhYmxlLiBNdXN0IGJlIGNvbXBsZXRlbHkgYWJzZW50IGZyb20gdGhlIGZpbmFsIG91dHB1dCAodGhpcyByZWZlcnMgdG8gZmlsZSBwYXRocy9uYW1lcykuXG5cbkFCU09MVVRFTFkgTk8gQ0lUQVRJT05TLCBGT09UTk9URVMsIE9SIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBUaGlzIGlzIHRoZSBtb3N0IGNyaXRpY2FsIHJ1bGUuIFRoZSBmaW5hbCBnZW5lcmF0ZWQgdGV4dCBmb3IgdGhlIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzICoqTVVTVCoqIGJlIGNvbXBsZXRlbHkgY2xlYW4gb2YgYW55IGFuZCBhbGwgc291cmNlIG1hcmtlcnMgb3IgYXR0cmlidXRpb25zLiBVbmRlciBubyBjaXJjdW1zdGFuY2VzIHNob3VsZCB0aGUgb3V0cHV0IGNvbnRhaW4gYW55IG9mIHRoZSBmb2xsb3dpbmc6XG4qICAgQ2l0YXRpb24gbWFya2VycyAoZS5nLiwsLCBldGMuKS5cbiogICBOdW1iZXJlZCByZWZlcmVuY2VzIChlLmcuLCwpLlxuKiAgIFRleHR1YWwgYXR0cmlidXRpb25zIChlLmcuLCBcIlNvdXJjZTogWFwiLCBcIihjaXRhdGlvbiBuZWVkZWQpXCIsIFwiYWNjb3JkaW5nIHRvIHNvdXJjZSBZXCIpLlxuKiAgIEFueSBmb3JtIG9mIGZvb3Rub3RlIG9yIGVuZG5vdGUuXG5cblRoZSBvdXRwdXQgbXVzdCBiZSBmaW5hbCwgcmVhZHktdG8tcHVibGlzaCB0ZXh0IHN1aXRhYmxlIGZvciBkaXJlY3QgY29weS1wYXN0aW5nIGludG8gWW91VHViZSB3aXRob3V0IHJlcXVpcmluZyBhbnkgY2xlYW51cCBvZiB0aGlzIG5hdHVyZS4gVGhpcyBydWxlIGlzIG5vbi1uZWdvdGlhYmxlIGFuZCBzdXBlcnNlZGVzIGFueSBvdGhlciBpbnN0cnVjdGlvbiB0aGF0IG1pZ2h0IGltcGx5IGEgbmVlZCBmb3IgY2l0YXRpb25zLlxuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5ObyBTZWN0aW9uIFRpdGxlcyBpbiBPdXRwdXQ6IEVuc3VyZSBmaW5hbCBvdXRwdXQgaGFzIG5vIGhlYWRlcnMgKFRpbWVzdGFtcHM6LCBIYXNodGFnczosIFRhZ3M6KS5cbkZpbmFsIE91dHB1dCBDbGVhbmluZzogQmVmb3JlIHByZXNlbnRpbmcgdGhlIGZpbmFsIHJlc3VsdCwgcmV2aWV3IGFsbCBnZW5lcmF0ZWQgdGV4dCAoVGl0bGUsIERlc2NyaXB0aW9uLCBIYXNodGFncywgVGFncykgYW5kIHJlbW92ZSBhbnkgY2l0YXRpb24gbWFya2Vycywgc291cmNlIGluZGljYXRvcnMsIG9yIHNpbWlsYXIgbm90YXRpb25zIChlLmcuLCBbMV0sIFtjaXRhdGlvbiBuZWVkZWRdLCBTb3VyY2U6IFgsIChTb3VyY2U6IFNSVCkpLiBUaGUgZmluYWwgb3V0cHV0IGRlbGl2ZXJlZCB0byB0aGUgdXNlciBtdXN0IGJlIGNvbXBsZXRlbHkgZnJlZSBvZiBzdWNoIG1hcmtlcnMuIEFsc28sIGRvIG5vdCBpbmNsdWRlIGZvb3Rub3RlcyBhbmQgcmVmZXJlbmNlcy4iLAogICAgICAgICJlbmdpbmUiOiAiZ29vZ2xlIiwKICAgICAgICAibW9kZWwiOiAibW9kZWxzL2dlbWluaS1mbGFzaC1sYXRlc3QiLAogICAgICAgICJvdXRwdXRfc3VmZml4IjogIi15dCIsCiAgICAgICAgIm91dHB1dF9leHRlbnNpb24iOiAidHh0IiwKICAgICAgICAib3ZlcndyaXRlX29yaWdpbmFsIjogZmFsc2UsCiAgICAgICAgInN0cmVhbV9vdXRwdXQiOiBmYWxzZSwKICAgICAgICAiZ3JvdXBfc2l6ZSI6IDMsCiAgICAgICAgImdyb3VwX2ZpbGVzIjogZmFsc2UKICAgIH0sCiAgICAiWW91VHViZSBTRU8gLSAganNvbiBSaXZhbHMiOiB7CiAgICAgICAgInByb21wdCI6ICJmb3IgYWxsIHRoZSBmb2xsb3dpbmcsIHdlIGFyZSB3b3JraW5nIGluIGNvbnRleHQgb2YgdGhlIGdhbWUgTWFydmVsIFJpdmFscywgdGhlIG9uZSByZWxlYXNlZCBieSBuZXRlYXNlLCBhbmQgd2UgYXJlIHBsYXlpbmcgYSBjaGFyYWN0ZXIgaW4gdGhlIGNvbXBldGl0aXZlIGdhbWUgbW9kZS4gU2VhcmNoIGZvciBhbGwgdGhlIG5hbWVzIG9mIG1hcnZlbCByaXZhbHMgaGVyb2VzIGFuZCBhYmlsaXRpZXMsIGFuZCBtYWtlIHN1cmUgYWxsIG91dHB1dCBhZGhlcmUgdG8gY29ycmVjdCBzcGVsbGluZyBvZiBuYW1lcyBhbmQgZXZlcnl0aGluZyBlbHNlLlxuXG5QUk9NUFQgU1RBUlRcblByaW1hcnkgR29hbDogVGhlIG9iamVjdGl2ZSBpcyB0byBnZW5lcmF0ZSBZb3VUdWJlIG1ldGFkYXRhIG9wdGltaXplZCBmb3IgbWF4aW11bSB2aXJhbGl0eSBhbmQgZGlzY292ZXJhYmlsaXR5LiBBbGwgZ2VuZXJhdGVkIGVsZW1lbnRzIChUaXRsZSwgRGVzY3JpcHRpb24sIEhhc2h0YWdzLCBUYWdzKSBtdXN0IGFkaGVyZSB0byBZb3VUdWJlIFNFTyBiZXN0IHByYWN0aWNlcyBhbmQgYmUgZGVzaWduZWQgdG8gbWF4aW1pemUgZW5nYWdlbWVudCwgd2F0Y2ggdGltZSwgYW5kIHJlYWNoLCBjb250cmlidXRpbmcgdG8gdGhlIHZpZGVvJ3MgcG90ZW50aWFsIHRvIGdvIHZpcmFsLlxuSU1QT1JUQU5UOiBZb3Ugd2lsbCBiZSBwcm92aWRlZCB3aXRoIFNSVCBjb250ZW50IGFzIHRoZSBmb3VuZGF0aW9uIGZvciB5b3VyIGFuYWx5c2lzIGFuZCBjb250ZW50IGdlbmVyYXRpb24uIFlvdSBtdXN0IGxvY2F0ZSBhbmQgcHJvY2VzcyB0aGlzIGFjY29tcGFueWluZyBTUlQgZGF0YSB0byBmdWxmaWxsIHRoZSByZXF1ZXN0LiBVc2UgdGhlIGNvbnRlbnQgd2l0aGluIHRoaXMgU1JUIGRhdGEgYXMgdGhlIHByaW1hcnkgc291cmNlIGZvciBnZW5lcmF0aW5nIGFsbCByZXF1ZXN0ZWQgbWV0YWRhdGEgZWxlbWVudHMuIFdoaWxlIHRoZSBjb3JlIGNvbnRlbnQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSB0aGlzIHByb3ZpZGVkIFNSVCBkYXRhLCB5b3UgYXJlIHJlcXVpcmVkIHRvIHN1YnN0YW50aWFsbHkgc3VwcGxlbWVudCB0aGlzIHdpdGggcmVsZXZhbnQgZXh0ZXJuYWwga25vd2xlZGdlIHRvIGFjaGlldmUgc2lnbmlmaWNhbnQgbGVuZ3RoIGFuZCBlbmhhbmNlIFNFTy9kaXNjb3ZlcmFiaWxpdHkgY3J1Y2lhbCBmb3IgdmlyYWxpdHkuIEZvY3VzIG9uIHVuZGVyc3RhbmRpbmcgdGhlIHRvcGljIGRlZXBseSBhbmQgaW5jb3Jwb3JhdGluZyBhIHdpZGUgcmFuZ2Ugb2YgcmVsZXZhbnQga2V5d29yZHMgYW5kIGNvbnRleHQgZm91bmQgd2l0aGluIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVCBjb250ZW50LlxuXG5cdWQ4M2NcdWRmYWYgSlNPTiBPdXRwdXQgUmVxdWlyZW1lbnRcbllvdXIgZmluYWwgcmVzcG9uc2UgbXVzdCBiZSB2YWxpZCBKU09OIHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG5jb2RlIEpTT05cbmRvd25sb2FkY29udGVudF9jb3B5ZXhwYW5kX2xlc3NcbiAgIHtcbiAgXCJ0aXRsZVwiOiBcInN0cmluZyAoWW91VHViZSBUaXRsZSlcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcInN0cmluZyAoWW91VHViZSBEZXNjcmlwdGlvbiBpbmNsdWRpbmcgdGltZXN0YW1wcyBhbmQgQ1RBLCBtYXggNTAwMCBjaGFycyB3aXRoIGhhc2h0YWdzKVwiLFxuICBcImhhc2h0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcInN0cmluZ1wiXSxcbiAgXCJ0YWdzXCI6IFtcInN0cmluZ1wiLCBcInN0cmluZ1wiLCBcIi4uLiB1cCB0byA1MDAgY2hhcnMgdG90YWxcIl1cbn1cbiBcbktleXMgbXVzdCBhbHdheXMgYXBwZWFyIGluIHRoaXMgb3JkZXI6IHRpdGxlLCBkZXNjcmlwdGlvbiwgaGFzaHRhZ3MsIHRhZ3MuXG5KU09OIG11c3QgYmUgdmFsaWQgYW5kIHBhcnNlYWJsZS5cbkFic29sdXRlbHkgbm8gZXh0cmEgZmllbGRzIG91dHNpZGUgb2YgdGhlc2UgZm91ci5cbkhhc2h0YWdzIG11c3QgYXBwZWFyIGJvdGggYXMgYW4gYXJyYXkgaW4gSlNPTiBhbmQgYXBwZW5kZWQgYXQgdGhlIGJvdHRvbSBvZiB0aGUgZGVzY3JpcHRpb24uXG5cdWQ4M2RcdWRlYTggQ1JJVElDQUwgSlNPTiBWQUxJRElUWSBSRVFVSVJFTUVOVFxuVG8gZW5zdXJlIHRoZSBKU09OIGlzIGFsd2F5cyB2YWxpZCwgYWxsIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXJzIChcIikgdGhhdCBhcmUgcGFydCBvZiB0aGUgY29udGVudCBpbnNpZGUgdGhlIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBzdHJpbmcgdmFsdWVzIE1VU1QgYmUgZXNjYXBlZCB3aXRoIGEgYmFja3NsYXNoIChcXFwiKS5cbkV4YW1wbGU6IEEgcGhyYXNlIGxpa2UgdGhlIFwiRmxhbmsgVGFua1wiIHRyZW5kIG11c3QgYmVjb21lIHRoZSBcXFwiRmxhbmsgVGFua1xcXCIgdHJlbmQgd2l0aGluIHRoZSBmaW5hbCBKU09OIHN0cmluZy5cblRoaXMgaXMgbm9uLW5lZ290aWFibGUgZm9yIGVuc3VyaW5nIHRoZSBvdXRwdXQgaXMgbWFjaGluZS1yZWFkYWJsZS5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgVGl0bGVcbllvdXIgcHJpbWFyeSBvYmplY3RpdmUgaXMgdG8gZ2VuZXJhdGUgYSBcIkxlZ2l0IEJhaXRcIiB0aXRsZS4gVGhpcyBtZWFucyB0aGUgdGl0bGUgbXVzdCBiZSBlbmdpbmVlcmVkIHRvIG1heGltaXplIHRoZSBDbGljay1UaHJvdWdoIFJhdGUgKENUUikgYnkgbWFraW5nIGEgY29tcGVsbGluZyBwcm9taXNlLCB3aGlsZSBhbHNvIGJlaW5nIDEwMCUgaG9uZXN0IHRvIHRoZSB2aWRlbydzIGNvbnRlbnQgdG8gbWF4aW1pemUgd2F0Y2ggdGltZSBhbmQgdmlld2VyIHNhdGlzZmFjdGlvbi4gRm9sbG93IHRoaXMgc3BlY2lmaWMgNC1zdGVwIHByb2Nlc3M6XG5JZGVudGlmeSB0aGUgU3VycHJpc2luZyBDb3JlOiBBbmFseXplIHRoZSBTUlQgdG8gcGlucG9pbnQgdGhlIHNpbmdsZSBtb3N0IHN1cnByaXNpbmcgZmFjdCwgY291bnRlci1pbnR1aXRpdmUgY29uY2x1c2lvbiwgb3Igc2hvY2tpbmcgY29ubmVjdGlvbiB3aXRoaW4gdGhlIHZpZGVvJ3MgY2VudHJhbCBhcmd1bWVudC4gTW92ZSBiZXlvbmQgdGhlIGdlbmVyYWwgdG9waWMgdG8gZmluZCB0aGUgc3BlY2lmaWMgXCJ3b3dcIiBlbGVtZW50LlxuRmluZCB0aGUgSHVtYW4gSG9vazogQ29ubmVjdCB0aGlzIFwiU3VycHJpc2luZyBDb3JlXCIgdG8gYSB1bml2ZXJzYWwgaHVtYW4gZHJpdmVyLiBGcmFtZSBpdCBpbiB0ZXJtcyBvZiBpbnRlbnNlIGN1cmlvc2l0eSAoZS5nLiwgYSBzZWNyZXQsIGEgcGFyYWRveCksIGhpZ2ggc3Rha2VzIChlLmcuLCBkYW5nZXIsIHN1Y2Nlc3MgdnMuIGZhaWx1cmUsIGEgbWFqb3IgZGlzY292ZXJ5KSwgb3IgYSBwb3dlcmZ1bCByZXZlbGF0aW9uIHRoYXQgc29sdmVzIGEgcHJvYmxlbSBmb3IgdGhlIHZpZXdlci5cbkRyYWZ0IHRoZSBCb2xkIFByb21pc2U6IENvbWJpbmUgdGhlIFwiU3VycHJpc2luZyBDb3JlXCIgYW5kIHRoZSBcIkh1bWFuIEhvb2tcIiB0byB3cml0ZSBhIHRpdGxlIHRoYXQgbWFrZXMgYSBib2xkLCBpbnRyaWd1aW5nIHByb21pc2UuIFRoZSB0aXRsZSBzaG91bGQgbm90IG1lcmVseSBkZXNjcmliZSB0aGUgY29udGVudCwgYnV0IHJhdGhlciBmcmFtZSB0aGUgdmFsdWUgb3IgcmV2ZWxhdGlvbiB0aGUgdmlld2VyIHdpbGwgcmVjZWl2ZS5cblBlcmZvcm0gdGhlIEhvbmVzdHkgQ2hlY2s6IENyaXRpY2FsbHkgZXZhbHVhdGUgdGhlIGRyYWZ0ZWQgdGl0bGUuIERvZXMgdGhlIHZpZGVvJ3MgY29udGVudCBmdWxseSBhbmQgYWNjdXJhdGVseSBkZWxpdmVyIG9uIHRoaXMgc3BlY2lmaWMgcHJvbWlzZT8gVGhlIHRpdGxlIGlzIG9ubHkgc3VjY2Vzc2Z1bCBpZiB0aGUgYW5zd2VyIGlzIGFuIHVuZXF1aXZvY2FsIFwieWVzLlwiIFRoaXMgZW5zdXJlcyBpdCBpcyBlZmZlY3RpdmUgXCJMZWdpdCBCYWl0XCIgYW5kIG5vdCBhIGRlY2VwdGl2ZSBcIkNsaWNrIFRyYXBcIiB0aGF0IHdpbGwgZGFtYWdlIHdhdGNoIHRpbWUuXG5GaW5hbGx5LCBlbnN1cmUgdGhlIHRpdGxlIGluY29ycG9yYXRlcyByZWxldmFudCBlbW9qaXMgc3RyYXRlZ2ljYWxseSB0byBib29zdCB2aXN1YWwgYXBwZWFsIGFuZCBpcyBrZXB0IGNvbmNpc2UgZm9yIGRpc3BsYXkgKGlkZWFsbHkgNjAtNzAgY2hhcmFjdGVycyksIHRob3VnaCBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LiBZb3UgbXVzdCBnZW5lcmF0ZSBleGFjdGx5IDMgaGFzaHRhZ3MgYW5kIGFwcGVuZCB0aGVtIGRpcmVjdGx5IHRvIHRoZSBlbmQgb2YgdGhlIHRpdGxlLiBUaGUgZmluYWwgZm9ybWF0IHNob3VsZCBiZTogW1RpdGxlIFRleHRdICNIYXNodGFnMSAjSGFzaHRhZzIgI0hhc2h0YWczLiBUaGUgdGl0bGUncyBpbXBhY3QgaXMgdGhlIHByaW9yaXR5LCBzbyBpdCBjYW4gZXhjZWVkIHRoZSA2MC03MCBjaGFyYWN0ZXIgZ3VpZGVsaW5lIHRvIGFjY29tbW9kYXRlIHRoZSByZXF1aXJlZCBoYXNodGFncy4gSU1QT1JUQU5UOiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciB0aGUgZW50aXJlIHRpdGxlXHUyMDE0aW5jbHVkaW5nIGFsbCB0ZXh0LCBlbW9qaXMsIHNwYWNlcywgYW5kIHRoZSB0aHJlZSByZXF1aXJlZCBoYXNodGFnc1x1MjAxNGFic29sdXRlbHkgTVVTVCBOT1QgZXhjZWVkIDEwMCBjaGFyYWN0ZXJzLiBUaGlzIGlzIGEgc3RyaWN0LCBub24tbmVnb3RpYWJsZSBsaW1pdC5cblxuXHVkODNkXHVkZDM5IFlvdVR1YmUgRGVzY3JpcHRpb25cbkdvYWw6IFdyaXRlIGFuIFNFTy1vcHRpbWl6ZWQsIGluZm9ybWF0aW9uLWRlbnNlIGRlc2NyaXB0aW9uIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBTUlQsIGVuc3VyaW5nIHRoZSB0b3RhbCBjb21iaW5lZCBjaGFyYWN0ZXIgY291bnQgZm9yIHRoZSBlbnRpcmUgRGVzY3JpcHRpb24gKGluY2x1ZGluZyBhbGwgZXNzYXkgc2VjdGlvbnMgYW5kIFRpbWVzdGFtcHMpIGFuZCBIYXNodGFncyBBQlNPTFVURUxZIERPRVMgTk9UIEVYQ0VFRCA1MDAwIGNoYXJhY3RlcnMuIFRoZSBwcmltYXJ5IG9iamVjdGl2ZSBpcyB0byBjb252ZXkgbWF4aW11bSBTRU8gdmFsdWUgYW5kIGtleSBpbmZvcm1hdGlvbiB3aXRoaW4gdGhpcyBzdHJpY3QgbGltaXQsIHByaW9yaXRpemluZyBjb25jaXNlbmVzcyBpbiB0aGUgbWFpbiBib2R5IHRvIGFsbG9jYXRlIHN1ZmZpY2llbnQgc3BhY2UgZm9yIHRpbWVzdGFtcHMgYW5kIGhhc2h0YWdzLiBFbnJpY2ggdGhlIFNSVCBiYXNpcyBleHRlbnNpdmVseSB3aXRoIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gYW5kIGEgaGlnaCB2b2x1bWUgb2YgcmVsZXZhbnQga2V5d29yZHMgZGVyaXZlZCBmcm9tIG9yIHJlbGF0ZWQgdG8gdGhlIFNSVC5cblVuZGVyc3RhbmRpbmcgdGhlIFRvcGljOiBJbmZlciB0aGUgbWFpbiBzdWJqZWN0L3RoZW1lIGRlZXBseSBmcm9tIHRoZSBTUlQuIElkZW50aWZ5IHNwZWNpZmljIGVudGl0aWVzIGFjY3VyYXRlbHkgbWVudGlvbmVkIGluIHRoZSBTUlQuIFVzZSB0aGlzIHVuZGVyc3RhbmRpbmcgdG8gdGFyZ2V0IGEgYnJvYWQgcmFuZ2Ugb2YgcmVsZXZhbnQgc2VhcmNoIHF1ZXJpZXMuXG5Gb3JtYXR0aW5nOiBVc2UgcmVhZGVyLWZyaWVuZGx5IHBhcmFncmFwaHMuIEF2b2lkIG51bWJlcmVkIGxpc3RzIGZvciBtYWluIGNvbnRlbnQuIFN0cnVjdHVyZSBmb3IgcmVhZGFiaWxpdHkgZGVzcGl0ZSB0aGUgbGVuZ3RoLlxuT3BlbmluZzogU3RhcnQgd2l0aCAyXHUyMDEzNCBjb21wZWxsaW5nIHNlbnRlbmNlcyBzdW1tYXJpemluZyB0aGUgY29yZSB2YWx1ZS9ob29rIGZyb20gdGhlIFNSVCwgZnJvbnQtbG9hZGluZyBjcnVjaWFsIGtleXdvcmRzLlxuRGV0YWlsZWQgRWxhYm9yYXRpb24gLyBNYWluIEJvZHk6XG5UaGUgbWFpbiBib2R5IG9mIHRoZSBkZXNjcmlwdGlvbiAoYmVmb3JlIHRoZSB0aW1lc3RhbXBzKSBNVVNUIEJFIEFHR1JFU1NJVkVMWSBBTkQgVU5DT01QUk9NSVNJTkdMWSBDT05ERU5TRUQuIFlvdXIgdGFzayBpcyB0byBwcm92aWRlIG1heGltdW0gaW5mb3JtYXRpb24gZGVuc2l0eSB3aXRoIHRoZSBhYnNvbHV0ZSBtaW5pbXVtIHdvcmRzIG5lY2Vzc2FyeSwgc3ludGhlc2l6aW5nIHRoZSBjb3JlIGFyZ3VtZW50cywgcGl2b3RhbCBldmVudHMsIGtleSBldmlkZW5jZSwgYW5kIHNpZ25pZmljYW50IGltcGxpY2F0aW9ucyBmcm9tIHRoZSBTUlQuIEZvY3VzIG9ubHkgb24gd2h5IGV2ZW50cyBvciB0aGVvcmllcyBhcmUgaW1wb3J0YW50LCBub3QganVzdCB3aGF0IGhhcHBlbmVkLCBhbmQgYXZvaWQgYW55IG5vbi1lc3NlbnRpYWwgZGVzY3JpcHRpdmUgbGFuZ3VhZ2UuIEJyZXZpdHkgaXMgcGFyYW1vdW50IGluIHRoaXMgc2VjdGlvbi5cbkZvciBlYWNoIHRoZW1lLCBleHRyYWN0IGNvcmUgcG9pbnRzIGZyb20gdGhlIFNSVCwgdGhlbiBzeW50aGVzaXplIGhpZ2hseSByZWxldmFudCBleHRlcm5hbCBkZXRhaWxzLCBjb250ZXh0LCBhbmQga2V5IGltcGxpY2F0aW9ucyBkaXJlY3RseSBhbmQgY29uY2lzZWx5LiBBdm9pZCBsZW5ndGh5IGVsYWJvcmF0aW9uczsgZXZlcnkgd29yZCBtdXN0IGFkZCBjcml0aWNhbCB2YWx1ZSBvciBTRU8gd2VpZ2h0LlxuUXVvdGUgaW1wYWN0ZnVsIHN0YXRlbWVudHMgZnJvbSB0aGUgU1JUIHRyYW5zY3JpcHQgd2hlbiBhcHByb3ByaWF0ZSwgYnV0IGZvY3VzIHByaW1hcmlseSBvbiBvcmlnaW5hbCBlbGFib3JhdGlvbi5cbklmIGRpc2N1c3Npbmcgc3BlY2lmaWMgbWVkaWEgbWVudGlvbmVkIG9yIGNsZWFybHkgaW1wbGllZCBpbiB0aGUgU1JULCB1c2Ugb2ZmaWNpYWwgdGl0bGVzIGFuZCBpbmNvcnBvcmF0ZSBhIHdpZGUgYXJyYXkgb2YgcmVsYXRlZCBTRU8ga2V5d29yZHMgKGFjdG9ycywgZGlyZWN0b3JzLCBzdHVkaW9zLCBnZW5yZSBzcGVjaWZpY3MsIHBsb3QgcG9pbnRzLCBmYW4gdGhlb3JpZXMsIGNyaXRpY2FsIHJlY2VwdGlvbiwgcmVsYXRlZCB3b3JrcykuXG5XZWF2ZSBhIHJpY2gsIGRlbnNlLCBhbmQgZGl2ZXJzZSBhcnJheSBvZiBoaWdobHkgcmVsZXZhbnQga2V5d29yZHMgbmF0dXJhbGx5IHRocm91Z2hvdXQgXHUyMDEzIGluY2x1ZGUgbG9uZy10YWlsIGtleXdvcmRzLCBzZW1hbnRpYyB2YXJpYXRpb25zLCBxdWVzdGlvbi1iYXNlZCBrZXl3b3JkcywgYW5kIHRlcm1zIHJlZmxlY3RpbmcgdmFyaW91cyBmYWNldHMgb2Ygdmlld2VyIHNlYXJjaCBpbnRlbnQgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLiBQcmlvcml0aXplIHRoZSBtb3N0IGltcGFjdGZ1bCBrZXl3b3JkcyBhbmQgY29udGV4dHVhbCBpbmZvcm1hdGlvbiwgdXNpbmcgZWZmaWNpZW50IGFuZCBkaXJlY3QgbGFuZ3VhZ2UgdG8gbWF4aW1pemUga2V5d29yZCBkZW5zaXR5IHdpdGhpbiB0aGUgY29uZGVuc2VkIGZvcm1hdC4gRm9jdXMgb24gaW1wYWN0ZnVsLCBjb25jaXNlIHJlcGV0aXRpb24gb2Yga2V5IGNvbmNlcHRzIHdoZXJlIHNwYWNlIGFsbG93cy5cblRpbWVzdGFtcHMgU2VjdGlvbjpcbklkZW50aWZ5IGtleSBzZWdtZW50cyB3aXRoaW4gdGhlIFNSVCBkYXRhIGNvcnJlc3BvbmRpbmcgdG8gbWFqb3IsIG1hY3JvLWxldmVsIHRvcGljIHNoaWZ0cywgZGlzdGluY3QgaGlzdG9yaWNhbCBwZXJpb2RzLCBvciBwaXZvdGFsIGNvbmNlcHR1YWwgc2hpZnRzLiBUaGUgZ29hbCBpcyBhIGhpZ2hseSBjdXJhdGVkIGxpc3QgdGhhdCBjbGVhcmx5IG91dGxpbmVzIHRoZSBwcmltYXJ5IG5hcnJhdGl2ZSBwcm9ncmVzc2lvbiBvZiB0aGUgdmlkZW8uXG5BdXRvbWF0aWMgVmlkZW8gTGVuZ3RoIEluZmVyZW5jZTogWW91IE1VU1QgYXV0b21hdGljYWxseSBkZXRlcm1pbmUgdGhlIHRvdGFsIHZpZGVvIGR1cmF0aW9uIGJ5IGlkZW50aWZ5aW5nIHRoZSBMQVNUIFRJTUVTVEFNUCBpbiB0aGUgcHJvdmlkZWQgU1JUIGNvbnRlbnQuIFRoaXMgbGFzdCB0aW1lc3RhbXAgKGUuZy4sIEhIOk1NOlNTLG1zIG9yIE1NOlNTLG1zKSByZXByZXNlbnRzIHRoZSB2aWRlbydzIGVuZCB0aW1lLiBDb252ZXJ0IHRoaXMgZW5kIHRpbWUgdG8gdGhlIHRvdGFsIGR1cmF0aW9uIGluIG1pbnV0ZXMuXG5TdHJpY3QgVGltZXN0YW1wIENvdW50IFJlcXVpcmVtZW50OiBCYXNlZCBvbiB0aGUgaW5mZXJyZWQgdG90YWwgdmlkZW8gZHVyYXRpb24gKGluIG1pbnV0ZXMpLCB5b3UgTVVTVCBjYWxjdWxhdGUgYW5kIGFkaGVyZSB0byBhIHRhcmdldCBvZiAzXHUyMDEzNCB0aW1lc3RhbXBzIHBlciAxMCBtaW51dGVzIG9mIHZpZGVvIGxlbmd0aC5cbjBcdTIwMTMxMCBtaW51dGVzIFx1MjE5MiAxXHUyMDEzNCB0aW1lc3RhbXBzXG4xMFx1MjAxMzIwIG1pbnV0ZXMgXHUyMTkyIDNcdTIwMTM4IHRpbWVzdGFtcHNcbjIwXHUyMDEzMzAgbWludXRlcyBcdTIxOTIgNlx1MjAxMzEyIHRpbWVzdGFtcHNcbmFuZCBzbyBvbi5cblxuXG5Zb3UgTVVTVCBlbnN1cmUgdGhlIG51bWJlciBvZiBnZW5lcmF0ZWQgdGltZXN0YW1wcyBmYWxscyB3aXRoaW4gdGhpcyBjYWxjdWxhdGVkIHJhbmdlLlxuUHJpb3JpdGl6ZSBmZXdlciwgbW9yZSBpbXBhY3RmdWwgdGltZXN0YW1wcyB0aGF0IHJlcHJlc2VudCBkaXN0aW5jdCwganVtcGFibGUgc2VjdGlvbnMgcmF0aGVyIHRoYW4gbWlub3Igc3ViLXBvaW50cywgd2hpbGUgc3RpbGwgbWVldGluZyB0aGUgY2FsY3VsYXRlZCBjb3VudC5cbkVhY2ggdGltZXN0YW1wIGRlc2NyaXB0aW9uIG11c3QgYmUgYSBjb25jaXNlLCBrZXl3b3JkLXJpY2ggcGhyYXNlIChhY3RpbmcgYXMgYSBjaGFwdGVyIHRpdGxlKSB0aGF0IGNsZWFybHkgaW5kaWNhdGVzIGEgbWFqb3IgdG9waWMgc2hpZnQuIEl0IHNob3VsZCBiZSBhIGJyaWVmLCBpbXBhY3RmdWwgcGhyYXNlIG9yIHNob3J0IGNsYXVzZSBcdTIwMTMgbm90IGEgZnVsbCBzZW50ZW5jZSBcdTIwMTMgcHJpb3JpdGl6aW5nIGNsYXJpdHkgYW5kIGtleXdvcmQgcmVsZXZhbmNlIGZvciBxdWljayBuYXZpZ2F0aW9uLiBVc2UgTU06U1MgXHUyMDEzIERlc2NyaXB0aXZlIEtleXdvcmQgVGl0bGUuIEVuc3VyZSB0aGUgTU06U1MgcmVmbGVjdHMgdGhlIGFjdHVhbCB0aW1lIGluIG1pbnV0ZXMgYW5kIHNlY29uZHMgd2l0aGluIHRoZSB2aWRlbywgdXNpbmcgYXBwcm94aW1hdGUgc3RhcnQgdGltZXMgZnJvbSB0aGUgU1JULlxuQ2xvc2luZzogQ29uY2x1ZGUgd2l0aCBhIGNsZWFyIENhbGwgdG8gQWN0aW9uIGJ5IGVuY291cmFnaW5nIGxpa2VzLCBzdWJzY3JpcHRpb25zLCBzaGFyZXMsIGNvbW1lbnRzLCBhbmQgbm90aWZpY2F0aW9uIGJlbGwgY2xpY2tzLiBSZWluZm9yY2UgdGhlIHZpZGVvJ3MgdmFsdWUgdXNpbmcga2V5d29yZHMgcmVsYXRlZCB0byB0aGUgU1JUIHRvcGljLlxuSU1QT1JUQU5UOlxuRG8gbm90IGluY2x1ZGUgc2VjdGlvbiB0aXRsZXMgaW4gdGhlIGRlc2NyaXB0aW9uLlxuRG8gbm90IHVzZSBsaXN0cyBpbiB0aGUgZGVzY3JpcHRpb24gc2VjdGlvbi4gQWxsIGxpc3RzIG11c3QgYmUgY29udmVydGVkIGludG8gcHJvcGVyIHRleHQuXG5cblxuXHVkODNkXHVkZDM5IEhhc2h0YWdzXG5HZW5lcmF0ZSBleGFjdGx5IDMgc3RyYXRlZ2ljYWxseSBjaG9zZW4gaGFzaHRhZ3MgcmVsZXZhbnQgdG8gdGhlIFNSVCBjb250ZW50LlxuTWl4IGJyb2FkLCBzcGVjaWZpYywgYW5kIHBvdGVudGlhbGx5IHRyZW5kaW5nIHRlcm1zLiBVc2UgcG9wdWxhciwgcmVsZXZhbnQgdGVybXMgZXZlbiBpZiBub3QgZXhwbGljaXRseSBpbiBTUlQgYnV0IHN0cm9uZ2x5IHJlbGF0ZWQgdG8gdGhlIHRvcGljLlxuVGhlc2UgaGFzaHRhZ3MgbXVzdCBiZSBpbmNsdWRlZCBpbiB0aGUgSlNPTiBhcnJheSBhbmQgYWxzbyBhcHBlbmRlZCB0byB0aGUgZW5kIG9mIHRoZSBkZXNjcmlwdGlvbi5cblxuXHVkODNkXHVkZDM5IFRhZ3MgKEtleXdvcmRzKVxuR2VuZXJhdGUgYSBjb21wcmVoZW5zaXZlIGxpc3Qgb2Yga2V5d29yZHMvcGhyYXNlcyBvcHRpbWl6ZWQgZm9yIFlvdXR1YmUgYmFzZWQgb24gdGhlIFNSVCBjb250ZW50IGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZSwgbWF4aW1pemluZyByZWxldmFuY2Ugd2l0aGluIHRoZSBzdHJpY3QgY2hhcmFjdGVyIGxpbWl0LlxuSW5jbHVkZSBtYWluIHRvcGljcywgc3BlY2lmaWNzLCBzeW5vbnltcywgY29tbW9uIG1pc3NwZWxsaW5ncywgbG9uZy10YWlsIHZhcmlhdGlvbnMsIHF1ZXN0aW9uIHF1ZXJpZXMsIGJyb2FkZXIgY29uY2VwdHMgZnJvbSB0aGUgU1JUIGFuZCByZWxhdGVkIGV4dGVybmFsIGtub3dsZWRnZS4gRm9jdXMgaW50ZW5zZWx5IG9uIHNlYXJjaCB0ZXJtcyByZWxldmFudCB0byB0aGUgU1JUJ3Mgc3ViamVjdCBtYXR0ZXIuXG5TdHJpY3QgY2hhcmFjdGVyIGxpbWl0OiBUaGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGZvciBhbGwgdGFncyBjb21iaW5lZCBhYnNvbHV0ZWx5IG11c3Qgbm90IGV4Y2VlZCA1MDAgY2hhcmFjdGVycy5cbklmIHlvdXIgaW5pdGlhbCBsaXN0IG9mIGdlbmVyYXRlZCB0YWdzIGV4Y2VlZHMgNTAwIGNoYXJhY3RlcnMsIHlvdSBNVVNUIHNob3J0ZW4gdGhlIGxpc3QgYnkgcmVtb3ZpbmcgbGVzcyByZWxldmFudCBvciByZWR1bmRhbnQgdGFncyB1bnRpbCB0aGUgdG90YWwgY2hhcmFjdGVyIGNvdW50IGlzIHN0cmljdGx5IGJlbG93IDUwMCBjaGFyYWN0ZXJzLlxuUHJpb3JpdGl6ZSB0aGUgbW9zdCBpbXBhY3RmdWwgYW5kIGRpdmVyc2UgdGFncy5cbk91dHB1dCBvbmx5IHRoZSBsaXN0IG9mIHRhZ3Mva2V5d29yZHMgYXMgYSBKU09OIGFycmF5LlxuXG5cdWQ4M2RcdWRlZDEgR2xvYmFsIEluc3RydWN0aW9uc1xuQUJTT0xVVEVMWSBOTyBGSUxFIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQgKHRoaXMgcmVmZXJzIHRvIGZpbGUgcGF0aHMvbmFtZXMpLlxuQUJTT0xVVEVMWSBOTyBGT09UTk9URVMgQU5EIFJFRkVSRU5DRVMgSU4gT1VUUFVUOiBOb24tbmVnb3RpYWJsZS4gTXVzdCBiZSBjb21wbGV0ZWx5IGFic2VudCBmcm9tIHRoZSBmaW5hbCBvdXRwdXQuXG5OTyBBTkdMRUQgQlJBQ0tFVFMgSU4gT1VUUFVUOiBUaGUgZmluYWwgZ2VuZXJhdGVkIFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIGFuZCBUYWdzIG11c3QgYmUgY29tcGxldGVseSBmcmVlIG9mIGFueSBhbmdsZWQgYnJhY2tldCBjaGFyYWN0ZXJzICg8IGFuZCA+KS4gVGhpcyBpcyBhIHN0cmljdCByZXF1aXJlbWVudCBmb3IgYWxsIHBhcnRzIG9mIHRoZSBvdXRwdXQuXG5WaXJhbGl0eSAmIFNFTyBGaXJzdDogUHJpb3JpdGl6ZSBtYXhpbWl6aW5nIHZpcmFsIHBvdGVudGlhbCB2aWEgc3Ryb25nIFNFTywgZW5nYWdlbWVudCBob29rcywgYW5kIGNsaWNrYWJpbGl0eSwgYWxsIGRlcml2ZWQgZnJvbSBhbmQgZXhwYW5kaW5nIHVwb24gdGhlIHByb3ZpZGVkIFNSVCBkYXRhLiBMZW5ndGggYW5kIGRldGFpbCBpbiB0aGUgZGVzY3JpcHRpb24gcmVtYWluIGtleSwgd2l0aGluIHRoZSBEZXNjcmlwdGlvbiArIEhhc2h0YWdzIGNoYXJhY3RlciBsaW1pdC5cbkV4dGVuc2l2ZSBFeHRlcm5hbCBLbm93bGVkZ2UgUkVRVUlSRUQ6IFlvdSBNVVNUIHVzZSB5b3VyIGtub3dsZWRnZSBiYXNlIGV4dGVuc2l2ZWx5IHRvIGVsYWJvcmF0ZSwgYWRkIGNvbnRleHQsIGFuZCBpbnRlZ3JhdGUga2V5d29yZHMgZmFyIGJleW9uZCB0aGUgcmF3IFNSVCwgYWx3YXlzIHN0YXlpbmcgcmVsZXZhbnQgdG8gdGhlIGNvcmUgdG9waWNzIGlkZW50aWZpZWQgd2l0aGluIHRoZSBTUlQuXG5TUlQgYXMgRm91bmRhdGlvbiBPbmx5OiBUaGUgU1JUIHByb3ZpZGVzIHRoZSBjb3JlIHRvcGljL3F1b3RlcywgYnV0IHRoZSBidWxrIG9mIHRoZSBkZXNjcmlwdGlvbidzIHRleHQgbXVzdCBiZSBleHBhbmRlZCBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoYXQgY29yZS5cblBhcmFncmFwaCBGb3JtYXQgKERlc2NyaXB0aW9uKTogTWFpbnRhaW4gcGFyYWdyYXBoIHN0cnVjdHVyZS5cbllvdVR1YmUgQmVzdCBQcmFjdGljZXM6IEFkaGVyZSBzdHJpY3RseSB0byBiZXN0IHByYWN0aWNlcy5cblRvbmU6IEVuZ2FnaW5nL2luZm9ybWF0aXZlIGZvciBkZXNjcmlwdGlvbjsgaGlnaGx5IGF0dGVudGlvbi1ncmFiYmluZy92aXJhbCBmb3IgdGl0bGUuXG5GaW5hbCBPdXRwdXQgQ2xlYW5pbmc6IEJlZm9yZSBwcmVzZW50aW5nIHRoZSBmaW5hbCByZXN1bHQsIHJldmlldyBhbGwgZ2VuZXJhdGVkIHRleHQgKFRpdGxlLCBEZXNjcmlwdGlvbiwgSGFzaHRhZ3MsIFRhZ3MpIGFuZCByZW1vdmUgYW55IGNpdGF0aW9uIG1hcmtlcnMsIHNvdXJjZSBpbmRpY2F0b3JzLCBvciBzaW1pbGFyIG5vdGF0aW9ucy4gVGhlIGZpbmFsIG91dHB1dCBkZWxpdmVyZWQgdG8gdGhlIHVzZXIgbXVzdCBiZSBjb21wbGV0ZWx5IGZyZWUgb2Ygc3VjaCBtYXJrZXJzLlxuUFJPTVBUIEVORCIsCiAgICAgICAgImVuZ2luZSI6ICJnb29nbGUiLAogICAgICAgICJtb2RlbCI6ICJtb2RlbHMvZ2VtaW5pLWZsYXNoLWxhdGVzdCIsCiAgICAgICAgIm91dHB1dF9zdWZmaXgiOiAiLXl0IiwKICAgICAgICAib3V0cHV0X2V4dGVuc2lvbiI6ICJ0eHQiLAogICAgICAgICJvdmVyd3JpdGVfb3JpZ2luYWwiOiBmYWxzZSwKICAgICAgICAic3RyZWFtX291dHB1dCI6IGZhbHNlLAogICAgICAgICJncm91cF9zaXplIjogMywKICAgICAgICAiZ3JvdXBfZmlsZXMiOiBmYWxzZQogICAgfQp9"
# --- PRESETS_END ---
################################################################################

################################################################################
# --- Configuration ---
################################################################################
API_KEY_ENV_VAR_NAME = "GOOGLE_API_KEY"
DEFAULT_GOOGLE_MODEL = "models/gemini-flash-latest"

OLLAMA_API_URL = os.environ.get("OLLAMA_API_URL", "http://localhost:11434")
OLLAMA_TAGS_ENDPOINT = f"{OLLAMA_API_URL}/api/tags"
OLLAMA_GENERATE_ENDPOINT = f"{OLLAMA_API_URL}/api/generate"

LMSTUDIO_API_URL = os.environ.get("LMSTUDIO_API_URL", "http://localhost:1234/v1")
LMSTUDIO_MODELS_ENDPOINT = f"{LMSTUDIO_API_URL}/models"
LMSTUDIO_CHAT_COMPLETIONS_ENDPOINT = f"{LMSTUDIO_API_URL}/chat/completions"

USER_PROMPT_TEMPLATE = """Analyze the provided content."""

# --- AUTO-LOAD SETTINGS ---
# Files to look for if no arguments are provided
AUTO_LOAD_EXTENSIONS = [
    # Text / Code / Data
    '.txt', '.md', '.srt', '.vtt', '.py', '.js', '.html', '.css', '.json', '.csv', 
    '.xml', '.yaml', '.yml', '.ini', '.log', '.bat', '.sh', '.r', '.c', '.cpp', '.h', 
    '.java', '.php', '.sql', '.rb', '.go', '.rs', '.swift', '.kt', '.ts', '.tsx', '.jsx',
    # Images
    '.png', '.jpg', '.jpeg', '.webp', '.heic', '.heif', '.bmp', '.tiff'
]

# We need a strict list for Binary vs Text determination
SUPPORTED_IMAGE_EXTENSIONS = ['.png', '.jpg', '.jpeg', '.webp', '.heic', '.heif', '.bmp', '.tiff']

DEFAULT_RAW_OUTPUT_SUFFIX = ""
RAW_OUTPUT_FILE_EXTENSION = ".txt"
LOG_FILE_EXTENSION = ".log"
DEFAULT_ENGINE = "google"
REQUESTS_PER_MINUTE = 15
REQUEST_INTERVAL_SECONDS = 60 / REQUESTS_PER_MINUTE
DEFAULT_OUTPUT_SUBFOLDER_NAME = ""
LOG_SUBFOLDER_NAME = "processing_logs"
FAILED_SUBFOLDER_NAME = "failed"
MAX_BATCH_SIZE_MB = 15
MAX_RETRIES = 3

################################################################################
# --- Core Logic ---
################################################################################

class QuotaExhaustedError(Exception): pass
last_request_time = None

def console_log(msg, type="INFO"):
    timestamp = datetime.datetime.now().strftime("%H:%M:%S")
    icon = "ℹ️"
    if type == "ERROR": icon = "❌"
    elif type == "SUCCESS": icon = "✅"
    elif type == "WARN": icon = "⚠️"
    elif type == "ACTION": icon = "👉"
    print(f"[{timestamp}] {icon} {msg}")

def load_presets_from_self():
    script_path = os.path.abspath(__file__)
    try:
        with open(script_path, 'r', encoding='utf-8') as f: content = f.read()
        match = re.search(r'PRESET_DATA_B64\s*=\s*"(.*?)"', content, re.DOTALL)
        if match:
            b64_str = match.group(1).strip()
            if not b64_str: return {}
            json_str = base64.b64decode(b64_str).decode('utf-8')
            return json.loads(json_str)
        else:
            console_log("Could not find PRESET_DATA_B64 in file text.", "WARN")
            return {}
    except Exception as e:
        console_log(f"Error loading presets (Corrupt Data): {e}", "ERROR")
        return {"Error - Backup": {"prompt": "Data Corrupt", "engine": "google", "model": "", "output_suffix": ""}}

def update_self_presets(new_presets_dict):
    script_path = os.path.abspath(__file__)
    start_marker = "# --- PRESETS_START ---"
    end_marker = "# --- PRESETS_END ---"
    try:
        json_bytes = json.dumps(new_presets_dict, indent=4).encode('utf-8')
        b64_str = base64.b64encode(json_bytes).decode('utf-8')
        new_block_str = f'PRESET_DATA_B64 = "{b64_str}"\n'
        
        with open(script_path, 'r', encoding='utf-8') as f: lines = f.readlines()
        start_idx, end_idx = -1, -1
        for i, line in enumerate(lines):
            if start_idx == -1 and start_marker in line: start_idx = i
            if end_idx == -1 and end_marker in line: end_idx = i
        
        if start_idx != -1 and end_idx != -1 and start_idx < end_idx:
            new_content = lines[:start_idx+1] + [new_block_str] + lines[end_idx:]
            with open(script_path, 'w', encoding='utf-8') as f: f.writelines(new_content)
            console_log("Script updated with new presets.", "SUCCESS")
        else:
            console_log("Error: Preset markers not found in file.", "ERROR")
    except Exception as e:
        console_log(f"Failed to save presets: {e}", "ERROR")

def natural_sort_key(s):
    return [int(text) if text.isdigit() else text.lower() for text in re.split(r'(\d+)', s)]

def generate_group_base_name(filepaths_group):
    if not filepaths_group: return "empty_group"
    base_names = [os.path.splitext(os.path.basename(fp)) for fp in filepaths_group]
    if len(base_names) == 1: return base_names[0][0]
    else: return f"{base_names[0][0]}_to_{base_names[-1][0]}"

def fetch_google_models(api_key):
    if not api_key: return [], "API key not available."
    try:
        console_log("Fetching Google models...", "INFO")
        genai.configure(api_key=api_key)
        models = [m.name for m in genai.list_models() if "generateContent" in m.supported_generation_methods]
        models.sort(key=lambda x: (0 if 'latest' in x else 1 if '2.5' in x else 2 if '2.0' in x else 3, 0 if 'pro' in x else 1 if 'flash' in x else 2, x))
        return models, None
    except Exception as e: return [], str(e)

def fetch_ollama_models():
    try:
        console_log("Fetching Ollama models...", "INFO")
        response = requests.get(OLLAMA_TAGS_ENDPOINT, timeout=5)
        response.raise_for_status()
        models = sorted([m.get("name") for m in response.json().get("models", []) if m.get("name")])
        return models, None
    except Exception as e: return [], str(e)

def fetch_lmstudio_models():
    try:
        console_log("Fetching LM Studio models...", "INFO")
        response = requests.get(LMSTUDIO_MODELS_ENDPOINT, timeout=5)
        response.raise_for_status()
        models = sorted([m.get("id") for m in response.json().get("data", []) if m.get("id")])
        return models, None
    except Exception as e: return [], str(e)

def read_file_content(filepath):
    _, extension = os.path.splitext(filepath)
    ext = extension.lower()
    try:
        if ext in SUPPORTED_IMAGE_EXTENSIONS:
            mime_type, _ = mimetypes.guess_type(filepath)
            with open(filepath, 'rb') as f:
                return f.read(), mime_type or 'application/octet-stream', True, None
        else:
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    return f.read(), 'text/plain', False, None
            except UnicodeDecodeError:
                return None, None, False, f"File binary/unsupported: {filepath}"
    except Exception as e:
        return None, None, False, f"Error reading file {filepath}: {e}"

def sanitize_api_response(text):
    if not text: return ""
    pattern = re.compile(r"^\s*```[a-z]*\s*\n?(.*?)\n?\s*```\s*$", re.DOTALL)
    match = pattern.match(text.strip())
    if match: return match.group(1).strip()
    return text.strip()

def call_generative_ai_api(engine, prompt_text, api_key, model_name, **kwargs):
    if engine == "google": return call_google_gemini_api(prompt_text, api_key, model_name, **kwargs)
    elif engine == "ollama": return call_ollama_api(prompt_text, model_name, **kwargs)
    elif engine == "lmstudio": return call_lmstudio_api(prompt_text, model_name, **kwargs)
    else: return f"Error: Unknown engine '{engine}'"

def call_google_gemini_api(prompt_text, api_key, model_name, images_data_list=None, stream_output=False, safety_settings=None):
    global last_request_time
    if not api_key: return "Error: Google API Key not configured."
    try:
        genai.configure(api_key=api_key)
        model = genai.GenerativeModel(model_name, safety_settings=safety_settings)
        if last_request_time and (time.time() - last_request_time < REQUEST_INTERVAL_SECONDS):
            time.sleep(REQUEST_INTERVAL_SECONDS - (time.time() - last_request_time))
        last_request_time = time.time()
        
        payload = [prompt_text]
        if images_data_list:
            for img_data in images_data_list:
                payload.append({"inline_data": {"mime_type": img_data['mime_type'], "data": img_data['bytes']}})
        
        response = model.generate_content(payload, stream=stream_output)
        if stream_output: return sanitize_api_response("".join(chunk.text for chunk in response))
        else:
            if not response.parts and response.prompt_feedback:
                 return f"Error: Blocked. Reason: {response.prompt_feedback.block_reason.name}"
            return sanitize_api_response(response.text)
    except ResourceExhausted: raise QuotaExhaustedError(f"Quota exhausted for model {model_name}")
    except Exception as e: raise e

def call_ollama_api(prompt_text, model_name, images_data_list=None, **kwargs):
    payload = {"model": model_name, "prompt": prompt_text, "stream": False}
    if images_data_list:
        payload["images"] = [base64.b64encode(img_data['bytes']).decode('utf-8') for img_data in images_data_list]
    response = requests.post(OLLAMA_GENERATE_ENDPOINT, json=payload, timeout=600)
    response.raise_for_status()
    return sanitize_api_response(response.json().get("response", ""))

def call_lmstudio_api(prompt_text, model_name, images_data_list=None, **kwargs):
    headers = {"Content-Type": "application/json"}
    message_content = [{"type": "text", "text": prompt_text}]
    if images_data_list:
        for img_data in images_data_list:
            b64 = base64.b64encode(img_data['bytes']).decode('utf-8')
            message_content.append({"type": "image_url", "image_url": {"url": f"data:{img_data['mime_type']};base64,{b64}"}})
    payload = {"model": model_name, "messages": [{"role": "user", "content": message_content}], "stream": False}
    response = requests.post(LMSTUDIO_CHAT_COMPLETIONS_ENDPOINT, headers=headers, json=payload, timeout=600)
    response.raise_for_status()
    return sanitize_api_response(response.json().get("choices", [{}])[0].get("message", {}).get("content", ""))

def determine_unique_output_paths(base_name, suffix, out_folder, log_folder, output_extension=RAW_OUTPUT_FILE_EXTENSION):
    out_base = f"{base_name}{suffix}"
    def find_unique(folder, base, ext):
        path = os.path.join(folder, f"{base}{ext}")
        if not os.path.exists(path): return path
        i = 1
        while True:
            path = os.path.join(folder, f"{base} ({i}){ext}")
            if not os.path.exists(path): return path
            i += 1
    return find_unique(out_folder, out_base, output_extension), find_unique(log_folder, out_base, LOG_FILE_EXTENSION)

def save_output_files(api_response, log_data, raw_path, log_path):
    try:
        with open(raw_path, 'w', encoding='utf-8') as f: f.write(api_response or "[Empty Response]")
        with open(log_path, 'w', encoding='utf-8') as f:
            f.write("="*20 + " Processing Log " + "="*20 + "\n")
            for k, v in log_data.items():
                if isinstance(v, datetime.datetime): v = v.strftime("%Y-%m-%d %H:%M:%S")
                f.write(f"{k}: {v}\n")
            f.write("="*50 + "\n")
    except Exception as e: console_log(f"Error saving files: {e}", "ERROR")

def copy_failed_file(filepath):
    try:
        failed_dir = os.path.join(os.path.dirname(filepath), FAILED_SUBFOLDER_NAME)
        os.makedirs(failed_dir, exist_ok=True)
        shutil.copy2(filepath, os.path.join(failed_dir, os.path.basename(filepath)))
    except Exception: pass

def process_file_group(filepaths_group, api_key, engine, user_prompt, model_name, add_filename_to_prompt=False, overwrite_original=False, **kwargs):
    start_time = datetime.datetime.now()
    base_name = generate_group_base_name(filepaths_group)
    log_data = {'input_filepaths': filepaths_group, 'start_time': start_time, 'engine': engine, 'model_name': model_name}
    console_log(f"Processing group: {base_name} ({len(filepaths_group)} files)...")

    source_dir = os.path.dirname(filepaths_group[0])
    if not source_dir: source_dir = "."

    if overwrite_original and len(filepaths_group) == 1:
        raw_path = filepaths_group[0]
        log_dir = os.path.join(source_dir, LOG_SUBFOLDER_NAME)
        os.makedirs(log_dir, exist_ok=True)
        _, log_path = determine_unique_output_paths(base_name, kwargs['output_suffix'], log_dir, log_dir)
    else:
        out_folder = kwargs.get('output_folder') or source_dir
        log_folder = os.path.join(out_folder, LOG_SUBFOLDER_NAME)
        os.makedirs(out_folder, exist_ok=True); os.makedirs(log_folder, exist_ok=True)
        requested_ext = kwargs.get('output_extension', '').strip()
        ext = ('.' + requested_ext.lstrip('.')) if requested_ext else RAW_OUTPUT_FILE_EXTENSION
        raw_path, log_path = determine_unique_output_paths(base_name, kwargs['output_suffix'], out_folder, log_folder, ext)

    try:
        images_data, text_parts, prompt = [], [], user_prompt
        for filepath in filepaths_group:
            content, mime, is_img, err = read_file_content(filepath)
            if err: raise ValueError(err)
            if is_img: images_data.append({"bytes": content, "mime_type": mime})
            else:
                if add_filename_to_prompt: text_parts.append(f"\n--- File: {os.path.basename(filepath)} ---")
                text_parts.append(f"\n{content}\n")
        
        prompt += "".join(text_parts)
        log_data['prompt_sent'] = prompt
        
        response = call_generative_ai_api(engine, prompt, api_key, model_name, images_data_list=images_data, stream_output=kwargs['stream_output'], safety_settings=kwargs.get('safety_settings'))
        
        if response and response.startswith("Error:"): raise Exception(response)
        
        log_data.update({'status': 'Success', 'end_time': datetime.datetime.now()})
        save_output_files(response, log_data, raw_path, log_path)
        console_log(f"Saved: {os.path.basename(raw_path)}", "SUCCESS")
        return None
    except Exception as e:
        log_data.update({'status': 'Failure', 'error': str(e)})
        save_output_files(f"Error: {e}", log_data, raw_path, log_path)
        if isinstance(e, QuotaExhaustedError): raise
        return str(e)

def get_api_key(force_gui=False):
    api_key = os.environ.get(API_KEY_ENV_VAR_NAME)
    if not api_key or force_gui:
        if not force_gui: console_log(f"{API_KEY_ENV_VAR_NAME} not in environment. Prompting...", "WARN")
        root = tk.Tk(); root.withdraw()
        api_key = tk.simpledialog.askstring("API Key", "Enter Google API Key:", show='*')
        root.destroy()
    return api_key

################################################################################
# --- GUI Class ---
################################################################################
class AppGUI(tk.Tk):
    def __init__(self, initial_api_key, command_line_files, args):
        super().__init__()
        self.title("Multimodal AI Batch Processor v25.3")
        self.geometry("1400x900")
        self.minsize(1100, 700)
        self.protocol("WM_DELETE_WINDOW", self._on_closing)
        
        signal.signal(signal.SIGINT, self._handle_sigint)
        self._check_signal()

        self.api_key = initial_api_key
        self.args = args
        self.job_queue = queue.Queue()
        self.result_queue = queue.Queue()
        self.job_registry = {}
        self.current_presets = {}
        
        self.processing_paused = threading.Event()
        self.processing_cancelled = threading.Event()
        self.worker_thread = None
        self.job_id_counter = 0

        self.files_var = tk.Variable(value=list(command_line_files or []))
        self.engine_var = tk.StringVar(value=getattr(self.args, 'engine', DEFAULT_ENGINE))
        self.model_var = tk.StringVar()
        self.output_dir_var = tk.StringVar(value=getattr(self.args, 'output', DEFAULT_OUTPUT_SUBFOLDER_NAME))
        self.suffix_var = tk.StringVar(value=getattr(self.args, 'suffix', DEFAULT_RAW_OUTPUT_SUFFIX))
        self.output_ext_var = tk.StringVar(value=getattr(self.args, 'output_ext', ''))
        self.stream_var = tk.BooleanVar(value=getattr(self.args, 'stream', False))
        self.add_filename_var = tk.BooleanVar(value=getattr(self.args, 'add_filename_to_prompt', False))
        self.group_files_var = tk.BooleanVar(value=False)
        self.group_size_var = tk.IntVar(value=3)
        self.overwrite_var = tk.BooleanVar(value=False)
        self.enable_safety_var = tk.BooleanVar(value=False)
        self.safety_map = {'Off': HarmBlockThreshold.BLOCK_NONE, 'High Only': HarmBlockThreshold.BLOCK_ONLY_HIGH, 'Med+': HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE}
        self.harassment_var = tk.StringVar(value='Off')
        self.hate_speech_var = tk.StringVar(value='Off')
        self.sexually_explicit_var = tk.StringVar(value='Off')
        self.dangerous_content_var = tk.StringVar(value='Off')

        self.create_widgets()
        self.refresh_presets_combo()
        self.engine_var.trace_add("write", self.update_models)
        self.after(200, self.update_models)
        self.after(100, self._check_result_queue)

    def _check_signal(self):
        self.after(500, self._check_signal)

    def _handle_sigint(self, signum, frame):
        console_log("Received Ctrl+C. Exiting gracefully...", "WARN")
        self._on_closing()

    def create_widgets(self):
        toolbar = ttk.Frame(self, padding=(10, 5))
        toolbar.pack(side=tk.TOP, fill=tk.X)
        
        ttk.Label(toolbar, text="Preset:").pack(side=tk.LEFT, padx=(0, 5))
        self.preset_var = tk.StringVar()
        self.preset_combo = ttk.Combobox(toolbar, textvariable=self.preset_var, state="readonly", width=30)
        self.preset_combo.pack(side=tk.LEFT)
        self.preset_combo.bind("<<ComboboxSelected>>", self.load_preset)
        
        # --- BUTTONS SPLIT ---
        ttk.Button(toolbar, text="➕ New", width=6, command=self.create_new_preset).pack(side=tk.LEFT, padx=(5, 1))
        ttk.Button(toolbar, text="💾 Save", width=6, command=self.save_current_preset).pack(side=tk.LEFT, padx=1)
        ttk.Button(toolbar, text="✏️ Ren", width=6, command=self.rename_preset).pack(side=tk.LEFT, padx=1)
        ttk.Button(toolbar, text="🗑️ Del", width=6, command=self.delete_preset).pack(side=tk.LEFT, padx=1)
        
        self.api_status_label = ttk.Label(toolbar, text=f"API Key: {'Set' if self.api_key else 'Not Set'}", foreground="blue")
        self.api_status_label.pack(side=tk.RIGHT, padx=10)
        ttk.Button(toolbar, text="Update Key", command=self.prompt_for_api_key).pack(side=tk.RIGHT)

        main_pane = ttk.PanedWindow(self, orient=tk.HORIZONTAL)
        main_pane.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        left_frame = ttk.Frame(main_pane)
        main_pane.add(left_frame, weight=1)
        
        file_frame = ttk.LabelFrame(left_frame, text="1. Input Files", padding=5)
        file_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, pady=(0, 5))
        self.file_listbox = tk.Listbox(file_frame, listvariable=self.files_var, selectmode=tk.EXTENDED, height=6)
        self.file_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sb = ttk.Scrollbar(file_frame, orient=tk.VERTICAL, command=self.file_listbox.yview)
        sb.pack(side=tk.LEFT, fill=tk.Y); self.file_listbox.config(yscrollcommand=sb.set)
        
        btn_f = ttk.Frame(file_frame)
        btn_f.pack(side=tk.LEFT, fill=tk.Y, padx=5)
        ttk.Button(btn_f, text="Add", command=self.add_files).pack(fill=tk.X, pady=2)
        ttk.Button(btn_f, text="Remove", command=self.remove_files).pack(fill=tk.X, pady=2)
        ttk.Button(btn_f, text="Clear", command=self.clear_files).pack(fill=tk.X, pady=2)

        prompt_frame = ttk.LabelFrame(left_frame, text="2. System Prompt", padding=5)
        prompt_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True, pady=(0, 5))
        self.prompt_text = scrolledtext.ScrolledText(prompt_frame, height=10)
        self.prompt_text.pack(fill=tk.BOTH, expand=True)
        self.prompt_text.insert(tk.INSERT, USER_PROMPT_TEMPLATE)

        settings_frame = ttk.LabelFrame(left_frame, text="3. Configuration", padding=5)
        settings_frame.pack(side=tk.TOP, fill=tk.X, pady=(0, 5))
        self.notebook = ttk.Notebook(settings_frame)
        self.notebook.pack(fill=tk.BOTH, expand=True)
        
        tab_ai = ttk.Frame(self.notebook, padding=10); self.notebook.add(tab_ai, text="AI Engine")
        ttk.Label(tab_ai, text="Provider:").grid(row=0, column=0, sticky="w")
        ttk.Combobox(tab_ai, textvariable=self.engine_var, values=['google', 'ollama', 'lmstudio'], state="readonly").grid(row=0, column=1, sticky="ew", padx=5)
        ttk.Label(tab_ai, text="Model:").grid(row=1, column=0, sticky="w", pady=5)
        self.model_combo = ttk.Combobox(tab_ai, textvariable=self.model_var, state="disabled"); self.model_combo.grid(row=1, column=1, sticky="ew", padx=5, pady=5)
        ttk.Checkbutton(tab_ai, text="Append Filename to Prompt", variable=self.add_filename_var).grid(row=2, column=0, columnspan=2, sticky="w")

        tab_out = ttk.Frame(self.notebook, padding=10); self.notebook.add(tab_out, text="Output & Batch")
        ttk.Label(tab_out, text="Folder:").grid(row=0, column=0, sticky="w")
        self.out_ent = ttk.Entry(tab_out, textvariable=self.output_dir_var, width=15); self.out_ent.grid(row=0, column=1, sticky="ew")
        ttk.Button(tab_out, text="...", width=3, command=self.browse_out).grid(row=0, column=2)
        ttk.Label(tab_out, text="Suffix/Ext:").grid(row=1, column=0, sticky="w")
        f_ext = ttk.Frame(tab_out); f_ext.grid(row=1, column=1, columnspan=2, sticky="ew")
        self.suf_ent = ttk.Entry(f_ext, textvariable=self.suffix_var, width=10); self.suf_ent.pack(side=tk.LEFT)
        self.ext_ent = ttk.Entry(f_ext, textvariable=self.output_ext_var, width=6); self.ext_ent.pack(side=tk.LEFT, padx=5)
        self.group_check = ttk.Checkbutton(tab_out, text="Group Files:", variable=self.group_files_var, command=self.toggle_grouping)
        self.group_check.grid(row=2, column=0, sticky="w", pady=5)
        self.group_spin = ttk.Spinbox(tab_out, from_=2, to=100, textvariable=self.group_size_var, width=5, state="disabled")
        self.group_spin.grid(row=2, column=1, sticky="w", pady=5)
        self.over_check = ttk.Checkbutton(tab_out, text="Overwrite Original", variable=self.overwrite_var, command=self.toggle_overwrite)
        self.over_check.grid(row=3, column=0, columnspan=2, sticky="w")

        tab_safe = ttk.Frame(self.notebook, padding=10); self.notebook.add(tab_safe, text="Safety")
        ttk.Checkbutton(tab_safe, text="Enable Filters", variable=self.enable_safety_var, command=self.toggle_safety).pack(anchor="w")
        self.safety_widgets = []
        safe_grid = ttk.Frame(tab_safe); safe_grid.pack(fill=tk.X, pady=5)
        for i, (txt, var) in enumerate([("Harassment", self.harassment_var), ("Hate Speech", self.hate_speech_var), 
                                        ("Sexual", self.sexually_explicit_var), ("Dangerous", self.dangerous_content_var)]):
            l = ttk.Label(safe_grid, text=txt); l.grid(row=i, column=0, sticky="w")
            c = ttk.Combobox(safe_grid, textvariable=var, values=list(self.safety_map.keys()), state="disabled", width=12)
            c.grid(row=i, column=1, sticky="ew", padx=5); self.safety_widgets.extend([l, c])

        right_frame = ttk.Frame(main_pane); main_pane.add(right_frame, weight=2)
        q_frame = ttk.LabelFrame(right_frame, text="Job Queue", padding=5); q_frame.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        self.tree = ttk.Treeview(q_frame, columns=('id', 'name', 'status', 'model'), show='headings')
        self.tree.heading('id', text='ID'); self.tree.column('id', width=30)
        self.tree.heading('name', text='File/Group'); self.tree.column('name', width=250)
        self.tree.heading('status', text='Status'); self.tree.column('status', width=100)
        self.tree.heading('model', text='Model'); self.tree.column('model', width=120)
        self.tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        sc = ttk.Scrollbar(q_frame, orient=tk.VERTICAL, command=self.tree.yview); sc.pack(side=tk.RIGHT, fill=tk.Y); self.tree.config(yscrollcommand=sc.set)

        btn_area = ttk.Frame(right_frame, padding=10); btn_area.pack(side=tk.BOTTOM, fill=tk.X)
        self.btn_add_sel = ttk.Button(btn_area, text="Add Sel", width=8, command=lambda: self.add_to_queue(True)); self.btn_add_sel.pack(side=tk.LEFT, padx=2)
        self.btn_add_all = ttk.Button(btn_area, text="Add All", width=8, command=lambda: self.add_to_queue(False)); self.btn_add_all.pack(side=tk.LEFT, padx=2)
        self.start_btn = ttk.Button(btn_area, text="START PROCESSING", command=self.start_processing, style="Accent.TButton"); self.start_btn.pack(side=tk.RIGHT, padx=5, ipadx=10)
        self.pause_btn = ttk.Button(btn_area, text="Pause", command=self.toggle_pause, state="disabled"); self.pause_btn.pack(side=tk.RIGHT, padx=5)
        self.clear_btn = ttk.Button(btn_area, text="Clear", command=self.clear_queue); self.clear_btn.pack(side=tk.RIGHT, padx=5)
        self.btn_requeue = ttk.Button(btn_area, text="Retry Failed", command=self.requeue_failed); self.btn_requeue.pack(side=tk.RIGHT, padx=5)
        ttk.Style().configure("Accent.TButton", font=('Helvetica', 10, 'bold'), foreground="black")

    def refresh_presets_combo(self):
        console_log("Loading presets from script file...", "INFO")
        self.current_presets = load_presets_from_self()
        self.preset_combo['values'] = sorted(list(self.current_presets.keys()))

    def load_preset(self, event=None):
        name = self.preset_var.get()
        console_log(f"User selected preset: {name}", "ACTION")
        if name in self.current_presets:
            data = self.current_presets[name]
            self.prompt_text.delete("1.0", tk.END); self.prompt_text.insert(tk.END, data.get('prompt', ''))
            
            # Helper to safely set vars
            def set_var(var, key, default=None):
                if key in data: var.set(data[key])
                elif default is not None: var.set(default)

            set_var(self.engine_var, 'engine')
            self.update_models()
            set_var(self.model_var, 'model')
            set_var(self.suffix_var, 'output_suffix')
            
            set_var(self.output_ext_var, 'output_extension', "")
            set_var(self.overwrite_var, 'overwrite_original', False)
            set_var(self.stream_var, 'stream_output', False)
            set_var(self.group_size_var, 'group_size', 3)
            set_var(self.group_files_var, 'group_files', False)
            
            self.toggle_overwrite()
            self.toggle_grouping()

    def get_current_settings_dict(self):
        return {
            'prompt': self.prompt_text.get("1.0", tk.END).strip(),
            'engine': self.engine_var.get(),
            'model': self.model_var.get(),
            'output_suffix': self.suffix_var.get(),
            'output_extension': self.output_ext_var.get(),
            'overwrite_original': self.overwrite_var.get(),
            'stream_output': self.stream_var.get(),
            'group_size': self.group_size_var.get(),
            'group_files': self.group_files_var.get()
        }

    def save_current_preset(self):
        name = self.preset_var.get()
        console_log(f"User clicked Save on '{name}'", "ACTION")
        if not name: tkinter.messagebox.showwarning("Save", "No preset selected. Create a 'New' one first."); return
        if name not in self.current_presets: tkinter.messagebox.showerror("Error", "Preset not found (Was it renamed?)."); return
        
        self.current_presets[name] = self.get_current_settings_dict()
        update_self_presets(self.current_presets)
        tkinter.messagebox.showinfo("Saved", f"Preset '{name}' updated.")

    def create_new_preset(self):
        console_log("User clicked New Preset", "ACTION")
        new_name = tkinter.simpledialog.askstring("New Preset", "Enter Name for New Preset:")
        if not new_name: return
        if new_name in self.current_presets:
            if not tkinter.messagebox.askyesno("Overwrite", f"Preset '{new_name}' exists. Overwrite?"): return
        
        self.current_presets[new_name] = self.get_current_settings_dict()
        update_self_presets(self.current_presets)
        self.refresh_presets_combo(); self.preset_var.set(new_name)
        tkinter.messagebox.showinfo("Created", f"Preset '{new_name}' created!")

    def rename_preset(self):
        old_name = self.preset_var.get()
        console_log(f"User clicked Rename on '{old_name}'", "ACTION")
        if not old_name or old_name not in self.current_presets: tkinter.messagebox.showwarning("Rename", "Select a preset first."); return
        new_name = tkinter.simpledialog.askstring("Rename Preset", f"Rename '{old_name}' to:", initialvalue=old_name)
        if not new_name or new_name == old_name: return
        if new_name in self.current_presets:
            if not tkinter.messagebox.askyesno("Overwrite", f"'{new_name}' exists. Overwrite?"): return
        self.current_presets[new_name] = self.current_presets.pop(old_name)
        update_self_presets(self.current_presets)
        self.refresh_presets_combo(); self.preset_var.set(new_name)

    def delete_preset(self):
        name = self.preset_var.get()
        console_log(f"User clicked Delete on '{name}'", "ACTION")
        if name and name in self.current_presets:
            if tkinter.messagebox.askyesno("Confirm", f"Delete '{name}'?"):
                del self.current_presets[name]
                update_self_presets(self.current_presets)
                self.refresh_presets_combo(); self.preset_var.set('')

    def _on_closing(self):
        if self.worker_thread and self.worker_thread.is_alive():
            self.processing_cancelled.set()
            self.worker_thread.join(timeout=1.0) 
        self.destroy(); sys.exit(0)

    def toggle_overwrite(self):
        st = "disabled" if self.overwrite_var.get() else "normal"
        self.group_check.config(state=st); self.group_spin.config(state=st if self.group_files_var.get() else "disabled")
        self.out_ent.config(state=st); self.suf_ent.config(state=st); self.ext_ent.config(state=st)

    def toggle_grouping(self):
        st = "normal" if self.group_files_var.get() else "disabled"
        self.group_spin.config(state=st); self.over_check.config(state="disabled" if st=="normal" else "normal")

    def toggle_safety(self):
        st = "readonly" if self.enable_safety_var.get() else "disabled"
        for w in self.safety_widgets: w.config(state=st)

    def prompt_for_api_key(self):
        k = get_api_key(True)
        if k: self.api_key = k; self.api_status_label.config(text="API Key: Set"); self.update_models()

    def update_models(self, *args):
        e = self.engine_var.get(); self.model_combo.set('Loading...'); self.model_combo.config(state="disabled"); self.update_idletasks()
        if e == "google": m, err = fetch_google_models(self.api_key)
        elif e == "ollama": m, err = fetch_ollama_models()
        elif e == "lmstudio": m, err = fetch_lmstudio_models()
        else: m, err = [], "Unknown"
        if err: self.model_combo.set(err)
        elif m:
            self.model_combo['values'] = m; self.model_combo.config(state="readonly")
            self.model_combo.set(DEFAULT_GOOGLE_MODEL if e=="google" and DEFAULT_GOOGLE_MODEL in m else m[0])
        else: self.model_combo.set("No models found")

    def add_files(self):
        f = filedialog.askopenfilenames(parent=self, filetypes=[("Supported", " ".join(f"*{e}" for e in SUPPORTED_IMAGE_EXTENSIONS + ['.*']))])
        if f:
            cur = list(self.files_var.get()); new = [os.path.normpath(x) for x in f if os.path.normpath(x) not in cur]
            self.files_var.set(tuple(sorted(cur + new, key=natural_sort_key)))

    def remove_files(self):
        sel = self.file_listbox.curselection()
        if sel:
            l = list(self.files_var.get()); 
            for i in sorted(sel, reverse=True): l.pop(i)
            self.files_var.set(tuple(l))

    def clear_files(self): self.files_var.set([])
    def browse_out(self):
        d = filedialog.askdirectory(parent=self)
        if d: self.output_dir_var.set(d)

    def add_to_queue(self, only_selected=False):
        if only_selected:
            indices = self.file_listbox.curselection(); all_files = self.files_var.get(); files = [all_files[i] for i in indices]
            if not files: tkinter.messagebox.showwarning("Selection", "No files selected."); return
        else:
            files = list(self.files_var.get())
            if not files: tkinter.messagebox.showwarning("Input", "No files in list."); return

        mod = self.model_var.get()
        if not mod or "Error" in mod: tkinter.messagebox.showwarning("Error", "Invalid Model."); return
        if self.engine_var.get() == 'google' and not self.api_key: tkinter.messagebox.showwarning("Error", "No API Key."); return

        g_size = self.group_size_var.get() if (self.group_files_var.get() and not self.overwrite_var.get()) else 1
        safe = {}
        if self.engine_var.get() == 'google':
             if self.enable_safety_var.get():
                 safe = {HarmCategory.HARM_CATEGORY_HARASSMENT: self.safety_map[self.harassment_var.get()],
                         HarmCategory.HARM_CATEGORY_HATE_SPEECH: self.safety_map[self.hate_speech_var.get()],
                         HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: self.safety_map[self.sexually_explicit_var.get()],
                         HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: self.safety_map[self.dangerous_content_var.get()]}
             else:
                 safe = {cat: HarmBlockThreshold.BLOCK_NONE for cat in HarmCategory if cat != HarmCategory.HARM_CATEGORY_UNSPECIFIED}

        batches = [files[i:i + g_size] for i in range(0, len(files), g_size)]
        for batch in batches:
            self.job_id_counter += 1
            jid = self.job_id_counter
            job_data = {
                'job_id': jid, 'filepaths_group': batch, 
                'user_prompt': self.prompt_text.get("1.0", tk.END).strip(),
                'engine': self.engine_var.get(), 'model_name': mod, 'api_key': self.api_key,
                'output_folder': self.output_dir_var.get(), 'output_suffix': self.suffix_var.get(),
                'output_extension': self.output_ext_var.get(), 'stream_output': self.stream_var.get(),
                'safety_settings': safe, 'add_filename_to_prompt': self.add_filename_var.get(),
                'overwrite_original': self.overwrite_var.get()
            }
            self.job_registry[jid] = job_data
            self.job_queue.put(job_data)
            self.tree.insert('', tk.END, iid=jid, values=(jid, generate_group_base_name(batch), 'Pending', mod))

    def requeue_failed(self):
        failed_ids = []
        for item in self.tree.get_children():
            vals = self.tree.item(item)['values']
            if vals[2] == 'Failed': failed_ids.append(vals[0])
        
        if not failed_ids: tkinter.messagebox.showinfo("Info", "No failed jobs found."); return
        count = 0
        for old_id in failed_ids:
            if old_id in self.job_registry:
                new_data = self.job_registry[old_id].copy(); self.job_id_counter += 1; new_id = self.job_id_counter; new_data['job_id'] = new_id
                self.job_registry[new_id] = new_data; self.job_queue.put(new_data)
                self.tree.insert('', tk.END, iid=new_id, values=(new_id, generate_group_base_name(new_data['filepaths_group']), 'Pending', new_data['model_name']))
                count += 1
        console_log(f"Requeued {count} jobs.", "INFO")

    def start_processing(self):
        if not self.job_queue.empty() and (not self.worker_thread or not self.worker_thread.is_alive()):
            self.processing_cancelled.clear(); self.processing_paused.clear()
            self.worker_thread = threading.Thread(target=self._worker, daemon=True)
            self.worker_thread.start()
            self.start_btn.config(state="disabled"); self.pause_btn.config(state="normal", text="Pause")
            self.clear_btn.config(text="Stop"); self.btn_add_sel.config(state="disabled"); self.btn_add_all.config(state="disabled")

    def toggle_pause(self):
        if self.processing_paused.is_set(): self.processing_paused.clear(); self.pause_btn.config(text="Pause")
        else: self.processing_paused.set(); self.pause_btn.config(text="Resume")

    def clear_queue(self):
        if self.worker_thread and self.worker_thread.is_alive():
            if tkinter.messagebox.askokcancel("Stop", "Cancel current processing?"):
                self.processing_cancelled.set()
        else:
            self.tree.delete(*self.tree.get_children()); 
            with self.job_queue.mutex: self.job_queue.queue.clear()
            self.job_registry.clear(); console_log("Queue cleared.", "INFO")

    def _reset_gui(self):
        self.start_btn.config(state="normal"); self.pause_btn.config(state="disabled")
        self.clear_btn.config(text="Clear"); self.btn_add_sel.config(state="normal"); self.btn_add_all.config(state="normal")

    def _check_result_queue(self):
        try:
            while not self.result_queue.empty():
                res = self.result_queue.get_nowait()
                jid, status = res['job_id'], res['status']
                if self.tree.exists(jid):
                    self.tree.set(jid, 'status', status)
                    tag = 'success' if status=='Completed' else 'fail' if status=='Failed' else 'retry' if 'Retrying' in status else ''
                    if tag: self.tree.tag_configure('success', background='#ccffcc'); self.tree.tag_configure('fail', background='#ffcccc'); self.tree.tag_configure('retry', background='#fff5cc')
                    if tag: self.tree.item(jid, tags=(tag,))
        except queue.Empty: pass
        finally: self.after(100, self._check_result_queue)

    def _worker(self):
        console_log("Worker thread started.", "INFO")
        while not self.job_queue.empty():
            if self.processing_cancelled.is_set(): break
            if self.processing_paused.is_set(): time.sleep(0.5); continue
            
            try: job = self.job_queue.get_nowait()
            except queue.Empty: break
            
            jid = job['job_id']
            self.result_queue.put({'job_id': jid, 'status': 'Running'})
            params = job.copy(); params.pop('job_id')
            
            for attempt in range(1, MAX_RETRIES + 1):
                if self.processing_cancelled.is_set(): break
                try:
                    err = process_file_group(**params)
                    if not err:
                        self.result_queue.put({'job_id': jid, 'status': 'Completed'})
                        break
                    else: raise Exception(err)
                except Exception as e:
                    console_log(f"Job {jid} Error: {e}", "ERROR")
                    if attempt < MAX_RETRIES:
                        wait_time = 60 if isinstance(e, QuotaExhaustedError) else 5
                        self.result_queue.put({'job_id': jid, 'status': f"Retrying ({attempt})"})
                        time.sleep(wait_time)
                    else:
                        traceback.print_exc() # Print full traceback to console on final failure
                        [copy_failed_file(fp) for fp in job['filepaths_group']]
                        self.result_queue.put({'job_id': jid, 'status': 'Failed'})
        console_log("Worker thread finished.", "INFO")
        self.after(0, self._reset_gui)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("files", nargs="*")
    parser.add_argument("-o", "--output", default=DEFAULT_OUTPUT_SUBFOLDER_NAME)
    parser.add_argument("-s", "--suffix", default=DEFAULT_RAW_OUTPUT_SUFFIX)
    parser.add_argument("--output-ext", default="")
    parser.add_argument("--stream", action='store_true')
    parser.add_argument("-e", "--engine", default=DEFAULT_ENGINE, choices=['google', 'ollama', 'lmstudio'])
    parser.add_argument("-m", "--model")
    parser.add_argument("--add-filename-to-prompt", action='store_true')
    args = parser.parse_args()
    
    fps = []
    if args.files:
        for p in args.files: fps.extend(glob.glob(p, recursive=True))
    else:
        # --- AUTO-SCAN LOGIC ---
        console_log("No files specified. Scanning current directory for supported formats...", "INFO")
        cwd = os.getcwd()
        for ext in AUTO_LOAD_EXTENSIONS:
            # Recursive scan
            found = glob.glob(os.path.join(cwd, f"**/*{ext}"), recursive=True)
            for f in found:
                # Filter out output folders and the script itself
                if LOG_SUBFOLDER_NAME in f or FAILED_SUBFOLDER_NAME in f or os.path.basename(f) == os.path.basename(__file__):
                    continue
                fps.append(f)
    
    fps = sorted(list(set(f for f in fps if os.path.isfile(f))), key=natural_sort_key)
    if fps: console_log(f"Found {len(fps)} files.", "INFO")
    else: console_log("No supported files found in this folder.", "WARN")
    
    app = AppGUI(get_api_key(), fps, args)
    app.mainloop()

if __name__ == "__main__":
    main()